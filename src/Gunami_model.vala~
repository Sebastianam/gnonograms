public class Gunami_model {
	private int _rows;
	private int _cols;
	private My2DCellArray _display_data;  //points to grid being displayed
	private My2DCellArray _solution_data; //display when setting
	private My2DCellArray _working_data; //display when solving
	public CellState[] _arr;
	private Rand _rand_gen;
	public double _grade;
	
	public Gunami_model(int r, int c) {
	_rows = r; _cols = c;
	_solution_data=new My2DCellArray(Resource.MAXSIZE,Resource.MAXSIZE,CellState.EMPTY);
	_working_data=new My2DCellArray(Resource.MAXSIZE,Resource.MAXSIZE,CellState.UNKNOWN);
	_arr = new CellState[Resource.MAXSIZE];
	_display_data = _solution_data;
	_rand_gen = new Rand();
	}

//======================================================================
	public void check_solution()
	{
		CellState cs;
		for (int r=0;r<=_rows; r++)
		{
			for (int c=0;c<=_cols;c++)
			{
				cs=_working_data.get_cell(r,c).state;
				if (cs!=CellState.UNKNOWN && cs!=_solution_data.get_cell(r,c).state)
				{
					_working_data.set_data_from_rc(r,c,CellState.ERROR);
				}
			}
		}
	}
//======================================================================
	public void clear()
	{
		_solution_data.set_all(CellState.EMPTY);
		_working_data.set_all(CellState.UNKNOWN);
	}
//======================================================================
	public void blank_working(CellState blank=CellState.UNKNOWN)
	{
		_working_data.set_all(blank);
	}
//======================================================================
	public void set_dimensions(int r, int c)
	{
		_rows=r;
		_cols=c;
		clear();
	}
//======================================================================
	public void blank_solution(CellState blank=CellState.EMPTY)
	{
		_solution_data.set_all(blank);
	}
//======================================================================
	public void use_working() {_display_data=_working_data;}
//======================================================================
	public void use_solution() {_display_data=_solution_data;}
//======================================================================
	public void set_difficulty(double d) {_grade=d.clamp(1.0,10.0);}
	public void reduce_difficulty() {_grade=double.max(_grade-1.0,1.0);}
//======================================================================
	public string get_label_text(int idx, bool is_column)
	{
		return _display_data.id2text(idx,is_column);
	}
//======================================================================
	public Cell get_cell(int r, int c){	return _display_data.get_cell(r,c);}
//======================================================================
	public void set_data_from_cell(Cell cell){_display_data.set_data_from_cell(cell);}
//======================================================================
	public void set_data_from_rc(int r, int c, CellState s)
	{
		_display_data.set_data_from_rc(r,c,s);
	}
//======================================================================
	public bool set_row_data_from_string(int r, string s)
	{
		CellState[] cs =new CellState[_cols];
		string[] data=s.split(",");
		if (data.length!=_cols)
		{
			Utils.show_warning_dialog(_("Position file error - wrong number of columns"));
			return false; 
		}
		for (int i=0; i<_cols; i++) cs[i]=int.parse((CellState)data[i]);
		_display_data.set_row(r,cs);
		return true;
	}
//======================================================================
	public void fill_random()
	{
		clear();
		int midcol = _rows/2; 
		int midrow =_cols/2;
		int mincdf = 1+int.min(1+_rows/3, (int)((_rows*_grade)/25.0));
		int minrdf = 1+int.min(1+_cols/3, (int)((_cols*_grade)/25.0));
		
		for (int e=0; e<_arr.length; e++) _arr[e]=CellState.EMPTY;

		int maxb=1+(int)(_cols*(1.0-_grade/15.0));
		for (int r=0;r<_rows;r++)
		{
			_solution_data.get_row(r, ref _arr);
			fill_region(_cols, ref _arr, (r-midcol).abs(), maxb, _cols);
			_solution_data.set_row(r,_arr);
		}
		maxb=1+(int)(_rows*(1.0-_grade/15.0));
		for (int c=0;c<_cols;c++)
		{
			_solution_data.get_col(c, ref _arr);
			fill_region(_rows, ref _arr,(c-midrow).abs(), maxb, _rows);
			_solution_data.set_col(c, _arr);
		}

		if (_grade<5) return;
		
		for (int r=0;r<_rows;r++)
		{
			_solution_data.get_row(r, ref _arr);
			adjust_region(_cols, ref _arr,minrdf);
			_solution_data.set_row(r, _arr);
		}
		
		for (int c=0;c<_cols;c++)
		{
			_solution_data.get_col(c, ref _arr);
			adjust_region(_rows, ref _arr,mincdf);
			_solution_data.set_col(c, _arr);
		}
	}
//=========================================================================
	public string to_string()
	{	
		StringBuilder sb= new StringBuilder("");
		for (int r=0; r<_rows; r++) {
			for (int c=0;c<_cols-1;c++) {
				sb.append(((int)(_display_data.get_cell(r,c).state)).to_string());
				sb.append(",");
			}
			sb.append(((int)(_display_data.get_cell(r,_cols-1).state)).to_string());
			sb.append("\n");
		}
		return sb.str;
	}
//=========================================================================		
	private void fill_region (int size, ref CellState[] _arr, int e, int maxb, int maxp)
	{
		//e is larger for rows/cols further from edge
		//do not want too many edge cells filled
		//maxb is maximum size of one random block
		//maxp is range of random number generator 
		
		if (maxb<=1) return;
		
		int p=0; //pointer
		int mid=size/2;
		int bsize; // blocksize
		int baseline = e+(int)_grade-10; // relates to the probability of a filled block before adjusting for distance from edge of region.
		bool fill;
		
		while (p<size)
		{
			// random length up to remaining space but not larger than maxb
			bsize=int.min(_rand_gen.int_range(0,size-p),maxb);
			// random choice whether to be full or empty, weighted so less likely to fill squares close to edge
			fill=_rand_gen.int_range(0,maxp)>(baseline+(p-mid).abs());
			
			for (int i=0; i<bsize; i++)
			{
				if (fill) _arr[p]=CellState.FILLED;
				p++;
			}
			p++; //at least one space between blocks
			
			if (fill && p<size) _arr[p]=CellState.EMPTY;
		}
	}
//=========================================================================		
	private void adjust_region(int s, ref CellState [] arr, int mindf)
	{	//s is size of region
		// mindf = minimum degrees of freedom
		int b=0; // count of filled cells
		int bc=0; // count of filled blocks
		int df=0; // degrees of freedom
		for (int i=0; i<s; i++)
		{
			if (arr[i]==CellState.FILLED)
			{
				b++;
				if (i==0 || arr[i-1]==CellState.EMPTY) bc++;
			}
		}
		df=s-b-bc+1;
		
		if (df>s) //completely empty
		{
			arr[_rand_gen.int_range(0,s)]=CellState.FILLED;
		}
		else
		{
			int count=0;
			while (df<mindf&&count<30)
			{
				count++;
				int i=_rand_gen.int_range(0,s);
				if (arr[i]==CellState.FILLED)
				{
					arr[i]=CellState.EMPTY;
					df++;
				}
			}
		}
	}
}

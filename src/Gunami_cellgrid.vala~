using Gtk;
using Gdk;
using Cairo;

public class Gunami_CellGrid : DrawingArea
{
	public signal void cursor_moved(int r, int c);
	
	private int _rows;
	private int _cols;
	private double _aw;
	private double _ah;
	private double _wd;
	private double _ht;
//	private Gdk.GC _mygc;
//	private Cairo.Context _cr;
	private 	Gdk.Color cr_color;
	private double _cell_offset;
	private double _cell_body_width;
	private double _cell_body_height;
	private double[] minor_grid_dash = {3.0, 1.0};
//======================================================================
	public Gunami_CellGrid(int r, int c)
	{
		_rows=r;
		_cols=c;

		add_events(
		EventMask.BUTTON_PRESS_MASK|
		EventMask.BUTTON_RELEASE_MASK|
		EventMask.POINTER_MOTION_MASK|
		EventMask.KEY_PRESS_MASK|
		EventMask.KEY_RELEASE_MASK
		);
			
		motion_notify_event.connect(pointer_moved);
	}
//=========================================================================
	public void resize(int r, int c) {_rows=r;_cols=c;}
//=========================================================================
	public void prepare_to_redraw_cells(bool show_grid)
	{ stdout.printf("In prepare to redraw\n");
		_aw=(double)allocation.width;
		_ah=(double)allocation.height;
		_wd=(_aw-2)/(double)_cols;
		_ht=(_ah-2)/(double)_rows;
		window.clear();
//		_mygc=new Gdk.GC(window);
/* 		_cr=Gdk.cairo_create(this.window);
		_cr.set_line_cap(Cairo.LineCap.BUTT);
		_cr.set_line_join(Cairo.LineJoin.MITER);
		_cr.set_line_width(1.0);
		_cr.set_dash(null,0.0);
		cr_color=style.bg[Gtk.StateType.NORMAL];
		Gdk.cairo_set_source_color(_cr, cr_color);
 */		
		if (show_grid)
		{
			_cell_offset=3.0;
			draw_grid();
		}
		else _cell_offset=1.0;

		//dimensions of filled part
		_cell_body_width=_wd-_cell_offset*2.0;
		_cell_body_height=_ht-_cell_offset*2.0;
	}
//=====================================================================
	
	public void draw_cell(Cell cell, GameState gs, bool isvalid=true)
	{
		//coords of top left corner of filled part (excluding grid if present and highlight line)
		double x=cell.col*_wd +_cell_offset+1.0;
		double y= cell.row*_ht +_cell_offset+1.0;
		
		int cs =(int) cell.state;
		var _cr=Gdk.cairo_create(this.window);
		if (cs==CellState.UNKNOWN)
		{
//			draw_cell_body(,x,y);
			cr_color=style.bg[Gtk.StateType.NORMAL];
		}
		else
		{
//			_mygc.set_rgb_fg_color(Resource.colors[gs,cs]);
			cr_color=Resource.colors[gs,cs];
//			stdout.printf(@"Color set $(cr_color.red) $(cr_color.green) $(cr_color.blue)\n");
		}
//		stdout.printf(@"Drawing cell $x $y\n");
//		cr_color=Resource.colors[gs,cs];
//		_cr.set_source_rgb((double)cr_color.red, (double)cr_color.green, (double)cr_color.blue);
		Gdk.cairo_set_source_color(_cr, cr_color);
		draw_cell_body(_cr, x,y);
	}
//=========================================================================
	private void draw_cell_body(Cairo.Context _cr, double x, double y)
	{
//		Gdk.draw_rectangle(window,gc,true,x,y,_cell_body_width,_cell_body_height);
		_cr.rectangle(x, y, _cell_body_width, _cell_body_height);
		_cr.fill();
	}
//=========================================================================
	public void highlight_cell(Cell cell, bool highlight)
	{	//coords of top left corner of highlight square)
		double x= cell.col*_wd+_cell_offset;
		double y= cell.row*_ht+_cell_offset;
		var _cr=Gdk.cairo_create(this.window);
//		var gc= highlight ? style.fg_gc[Gtk.StateType.NORMAL] : style.bg_gc[Gtk.StateType.NORMAL];
		if (highlight) cr_color=style.fg[ Gtk.StateType.NORMAL ];
		else cr_color=style.bg[Gtk.StateType.NORMAL];
		
//		_cr.set_source_rgb((double)(cr_color.red), (double)(cr_color.green), (double)(cr_color.blue));
		Gdk.cairo_set_source_color(_cr, cr_color);
		draw_cell_highlight(_cr, x,y);
	}
//=========================================================================
	private void draw_cell_highlight(Cairo.Context _cr, double x, double y)
	{
		_cr.rectangle(x,y,_cell_body_width+2.0,_cell_body_height+2.0);
		_cr.stroke();
	}
//======================================================================
	private void draw_grid()
	{stdout.printf("In draw grid\n");
		double x1=0.0, x2=_aw-1, y1, y2;
//		_mygc.copy(style.fg_gc[Gtk.StateType.NORMAL]);
//		_mygc.set_line_attributes(1, LineStyle.ON_OFF_DASH, CapStyle.BUTT, JoinStyle.MITER);
		
		var _cr=Gdk.cairo_create(this.window);
		_cr.set_dash(minor_grid_dash,0.0);
		_cr.set_line_width(1.0);
		
		for (int r=0; r<=_rows; r++)
		{
			y1=1.0+r*_ht;
//			Gdk.draw_line(window, _mygc, x1, y1, x2, y1);
			_cr.move_to(x1,y1);
			_cr.line_to(x2,y1);
			_cr.stroke();
		}
		y1=0; y2=_ah-1;
		for (int c=0; c<=_cols; c++)
		{
			x1=1.0+c*_wd;
			_cr.move_to(x1,y1);
			_cr.line_to(x1,y2);
			_cr.stroke();
//			Gdk.draw_line(window, _mygc, x1, y1, x1, y2);
		}
		
//		_mygc.set_line_attributes(2, LineStyle.SOLID, CapStyle.BUTT, JoinStyle.MITER);	
		_cr.set_dash(null,0.0);
		_cr.set_line_width(2.0);
		
		x1=0;x2=_aw-1;
		for (int r=0; r<=_rows; r+=5)
		{
			y1=1+(int) (r*_ht);
//			Gdk.draw_line(window, _mygc, x1, y1, x2, y1);
			_cr.move_to(x1,y1);
			_cr.line_to(x2,y1);
			_cr.stroke();
		}
		y1=0; y2=_ah-1;
		for (int c=0; c<=_cols; c+=5)
		{
			x1=1+(int) (c*_wd);
//			Gdk.draw_line(window, _mygc, x1, y1, x1, y2);
			_cr.move_to(x1,y1);
			_cr.line_to(x1,y2);
			_cr.stroke();
		}
	}
//======================================================================
	private bool pointer_moved(Widget w, Gdk.EventMotion e)
	{
		int r= ((int) (e.y/_ah*_rows)).clamp(0,_rows-1);
		int c= ((int) (e.x/_aw*_cols)).clamp(0,_cols-1);
		cursor_moved(r,c); //signal connected to controller
		return false;
	}
//=========================================================================
/*  	private Gdk.Point[] rect_points(int x, int y, int sx, int sy)
	{
		Gdk.Point p0,p1,p2,p3;
		p0={x,y};
		p1={x+sx,y};
		p2={x+sx,y+sy};
		p3={x,y+sy};
		return {p0,p1,p2,p3,p0};
	}*/
//=========================================================================

}	

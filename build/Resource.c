/* Resource.c generated by valac 0.11.6, the Vala compiler
 * generated from Resource.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 *
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <stdio.h>
#include <gio/gio.h>
#include <glib/gi18n-lib.h>
#include <gdk-pixbuf/gdk-pixdata.h>


#define RESOURCE_TYPE_ICON_ID (resource_icon_id_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_CONFIG (config_get_type ())
#define CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG, Config))
#define CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG, ConfigClass))
#define IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG))
#define IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG))
#define CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG, ConfigClass))

typedef struct _Config Config;
typedef struct _ConfigClass ConfigClass;
#define _config_unref0(var) ((var == NULL) ? NULL : (var = (config_unref (var), NULL)))

#define TYPE_GAME_STATE (game_state_get_type ())

#define TYPE_CELL_STATE (cell_state_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef enum  {
	RESOURCE_ICON_ID_PEEK,
	RESOURCE_ICON_ID_SOLVE,
	RESOURCE_ICON_ID_RANDOM,
	RESOURCE_ICON_ID_RESIZE,
	RESOURCE_ICON_ID_HIDE,
	RESOURCE_ICON_ID_REVEAL
} ResourceIconID;

typedef enum  {
	GAME_STATE_SETTING,
	GAME_STATE_SOLVING
} GameState;

typedef enum  {
	CELL_STATE_UNKNOWN,
	CELL_STATE_EMPTY,
	CELL_STATE_FILLED,
	CELL_STATE_ERROR,
	CELL_STATE_COMPLETED
} CellState;


extern gint resource_MAXROWSIZE;
gint resource_MAXROWSIZE = 100;
extern gint resource_MAXCOLSIZE;
gint resource_MAXCOLSIZE = 100;
extern gint resource_MAXGRADE;
gint resource_MAXGRADE = 10;
extern gint resource_MAXTRIES;
gint resource_MAXTRIES = 30;
extern gint resource_MINFONTSIZE;
gint resource_MINFONTSIZE = 6;
extern gint resource_MAXFONTSIZE;
gint resource_MAXFONTSIZE = 16;
extern gchar* resource_font_desc;
gchar* resource_font_desc = NULL;
extern gdouble resource_CELLOFFSET_NOGRID;
gdouble resource_CELLOFFSET_NOGRID = 0.0;
extern gdouble resource_CELLOFFSET_WITHGRID;
gdouble resource_CELLOFFSET_WITHGRID = 2.0;
extern gdouble* resource_MINORGRIDDASH;
extern gint resource_MINORGRIDDASH_length1;
gdouble* resource_MINORGRIDDASH = NULL;
gint resource_MINORGRIDDASH_length1 = 0;
extern GdkColor* resource_colors;
extern gint resource_colors_length1;
extern gint resource_colors_length2;
GdkColor* resource_colors = NULL;
gint resource_colors_length1 = 0;
gint resource_colors_length2 = 0;
extern gchar* resource_exec_dir;
gchar* resource_exec_dir = NULL;
extern gchar* resource_resource_dir;
gchar* resource_resource_dir = NULL;
extern gchar* resource_locale_dir;
gchar* resource_locale_dir = NULL;
extern gchar* resource_game_dir;
gchar* resource_game_dir = NULL;
extern gchar* resource_game_name;
gchar* resource_game_name = NULL;
extern gchar* resource_icon_dir;
gchar* resource_icon_dir = NULL;
extern gchar* resource_mallard_manual_dir;
gchar* resource_mallard_manual_dir = NULL;
extern gchar* resource_html_manual_dir;
gchar* resource_html_manual_dir = NULL;
extern gchar* resource_prefix;
gchar* resource_prefix = NULL;
extern gboolean resource_installed;
gboolean resource_installed = FALSE;
extern gint resource_icon_size;
gint resource_icon_size = 24;
extern GtkIconTheme* resource_icon_theme;
GtkIconTheme* resource_icon_theme = NULL;

GType resource_icon_id_get_type (void) G_GNUC_CONST;
#define RESOURCE_APP_GETTEXT_PACKAGE GETTEXT_PACKAGE
#define RESOURCE_DEFAULTGAMENAME "New game"
#define RESOURCE_GAMEFILEEXTENSION ".gno"
#define RESOURCE_POSITIONFILENAME "currentposition"
#define RESOURCE_RANDOMICONFILENAME "dice.png"
#define RESOURCE_PEEKICONFILENAME "errorcheck.png"
#define RESOURCE_RESIZEICONFILENAME "resize.png"
#define RESOURCE_SOLVEICONFILENAME "laptop.png"
#define RESOURCE_HIDEICONFILENAME "eyes-open.png"
#define RESOURCE_REVEALICONFILENAME "eyes-closed.png"
#define RESOURCE_MISSINGICONFILENAME ""
#define RESOURCE_SOLVEICONTHEMENAME "computer"
#define RESOURCE_PEEKICONTHEMENAME ""
#define RESOURCE_RANDOMICONTHEMENAME ""
#define RESOURCE_RESIZEICONTHEMENAME "resize"
#define RESOURCE_HIDEICONTHEMENAME "hide"
#define RESOURCE_REVEALICONTHEMENAME "reveal"
#define RESOURCE_MISSINGICONTHEMENAME "image-missing"
#define RESOURCE_BLOCKSEPARATOR ","
void resource_init (const gchar* arg0);
gboolean resource_is_installed (const gchar* exec_dir);
gpointer config_ref (gpointer instance);
void config_unref (gpointer instance);
GParamSpec* param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_config (GValue* value, gpointer v_object);
void value_take_config (GValue* value, gpointer v_object);
gpointer value_get_config (const GValue* value);
GType config_get_type (void) G_GNUC_CONST;
Config* config_get_instance (void);
gchar* config_get_game_dir (Config* self, const gchar* defaultdir);
gchar* config_get_game_name (Config* self, const gchar* defaultname);
GType game_state_get_type (void) G_GNUC_CONST;
GType cell_state_get_type (void) G_GNUC_CONST;
gchar** config_get_colors (Config* self, int* result_length1);
gchar* resource_get_langpack_dir (void);
void resource_set_colors (void);
void resource_set_font (void);
void resource_get_icon_theme (void);
GdkPixbuf* resource_get_theme_icon (const gchar* icon_name);
GdkPixbuf* resource_get_app_icon (const gchar* icon_filename);
GdkPixbuf* resource_get_icon (ResourceIconID id);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GType resource_icon_id_get_type (void) {
	static volatile gsize resource_icon_id_type_id__volatile = 0;
	if (g_once_init_enter (&resource_icon_id_type_id__volatile)) {
		static const GEnumValue values[] = {{RESOURCE_ICON_ID_PEEK, "RESOURCE_ICON_ID_PEEK", "peek"}, {RESOURCE_ICON_ID_SOLVE, "RESOURCE_ICON_ID_SOLVE", "solve"}, {RESOURCE_ICON_ID_RANDOM, "RESOURCE_ICON_ID_RANDOM", "random"}, {RESOURCE_ICON_ID_RESIZE, "RESOURCE_ICON_ID_RESIZE", "resize"}, {RESOURCE_ICON_ID_HIDE, "RESOURCE_ICON_ID_HIDE", "hide"}, {RESOURCE_ICON_ID_REVEAL, "RESOURCE_ICON_ID_REVEAL", "reveal"}, {0, NULL, NULL}};
		GType resource_icon_id_type_id;
		resource_icon_id_type_id = g_enum_register_static ("ResourceIconID", values);
		g_once_init_leave (&resource_icon_id_type_id__volatile, resource_icon_id_type_id);
	}
	return resource_icon_id_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


void resource_init (const gchar* arg0) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	GtkIconTheme* _tmp2_ = NULL;
	GtkIconTheme* _tmp3_;
	GtkIconTheme* _tmp4_;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	GFile* _tmp8_ = NULL;
	GFile* _tmp9_;
	GFile* exec_file;
	GFile* _tmp10_ = NULL;
	GFile* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	gboolean _tmp14_;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* _tmp27_;
	gchar* _tmp28_;
	gchar* _tmp29_ = NULL;
	gchar* _tmp38_;
	gchar* _tmp39_;
	gchar* _tmp40_;
	gchar* _tmp41_;
	gchar* _tmp42_;
	Config* _tmp43_ = NULL;
	Config* _tmp44_;
	gchar* _tmp45_;
	gchar* _tmp46_ = NULL;
	gchar* _tmp47_;
	Config* _tmp48_ = NULL;
	Config* _tmp49_;
	gchar* _tmp50_ = NULL;
	gchar* _tmp51_;
	GdkColor* _tmp52_ = NULL;
	GdkColor* _tmp53_;
	gint setting;
	GdkColor _tmp54_ = {0};
	GdkColor _tmp55_ = {0};
	GdkColor _tmp56_ = {0};
	GdkColor _tmp57_ = {0};
	gint solving;
	GdkColor _tmp58_ = {0};
	GdkColor _tmp59_ = {0};
	GdkColor _tmp60_ = {0};
	GdkColor _tmp61_ = {0};
	Config* _tmp62_ = NULL;
	Config* _tmp63_;
	gint _tmp64_;
	gchar** _tmp65_ = NULL;
	gchar** _tmp66_;
	gchar** config_colors;
	gint config_colors_length1;
	gint _config_colors_size_;
	GdkColor _tmp67_ = {0};
	GdkColor _tmp68_ = {0};
	GdkColor _tmp69_ = {0};
	GdkColor _tmp70_ = {0};
	gchar* _tmp71_;
	gchar* _tmp72_;
	gdouble* _tmp73_ = NULL;
	gdouble* _tmp74_;
	g_return_if_fail (arg0 != NULL);
	_tmp0_ = g_strdup (_PREFIX);
	_tmp1_ = _tmp0_;
	_g_free0 (resource_prefix);
	resource_prefix = _tmp1_;
	fprintf (stdout, "Prefix is %s \n", resource_prefix);
	fprintf (stdout, "gettext package is %s \n", RESOURCE_APP_GETTEXT_PACKAGE);
	_tmp2_ = gtk_icon_theme_get_default ();
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_tmp4_ = _tmp3_;
	_g_object_unref0 (resource_icon_theme);
	resource_icon_theme = _tmp4_;
	_tmp5_ = gtk_icon_theme_get_example_icon_name (resource_icon_theme);
	fprintf (stdout, "Icon theme is %s\n", _tmp5_);
	_tmp6_ = g_find_program_in_path (arg0);
	_tmp7_ = _tmp6_;
	_tmp8_ = g_file_new_for_path (_tmp7_);
	exec_file = (_tmp9_ = _tmp8_, _g_free0 (_tmp7_), _tmp9_);
	_tmp10_ = g_file_get_parent (exec_file);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_file_get_path (_tmp11_);
	_tmp13_ = _tmp12_;
	_g_free0 (resource_exec_dir);
	resource_exec_dir = _tmp13_;
	_g_object_unref0 (_tmp11_);
	fprintf (stdout, "Exec_dir is %s \n", resource_exec_dir);
	_tmp14_ = resource_is_installed (resource_exec_dir);
	resource_installed = _tmp14_;
	_tmp15_ = bool_to_string (resource_installed);
	_tmp16_ = _tmp15_;
	fprintf (stdout, "Is installed is %s\n", _tmp16_);
	_g_free0 (_tmp16_);
	if (resource_installed) {
		GFile* _tmp18_ = NULL;
		GFile* _tmp19_;
		GFile* _tmp20_ = NULL;
		GFile* _tmp21_;
		gchar* _tmp22_ = NULL;
		gchar* _tmp23_;
		gchar* _tmp24_;
		_tmp18_ = g_file_get_parent (exec_file);
		_tmp19_ = _tmp18_;
		_tmp20_ = g_file_get_parent (_tmp19_);
		_tmp21_ = _tmp20_;
		_tmp22_ = g_file_get_path (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp24_ = g_strconcat (_tmp23_, "/share/gnonograms", NULL);
		_g_free0 (_tmp17_);
		_tmp17_ = _tmp24_;
		_g_free0 (_tmp23_);
		_g_object_unref0 (_tmp21_);
		_g_object_unref0 (_tmp19_);
	} else {
		gchar* _tmp25_;
		gchar* _tmp26_;
		_tmp25_ = g_strdup (resource_exec_dir);
		_tmp26_ = _tmp25_;
		_g_free0 (_tmp17_);
		_tmp17_ = _tmp26_;
	}
	_tmp27_ = g_strdup (_tmp17_);
	_tmp28_ = _tmp27_;
	_g_free0 (resource_resource_dir);
	resource_resource_dir = _tmp28_;
	fprintf (stdout, "Resource_dir is %s \n", resource_resource_dir);
	if (resource_installed) {
		GFile* _tmp30_ = NULL;
		GFile* _tmp31_;
		GFile* _tmp32_ = NULL;
		GFile* _tmp33_;
		gchar* _tmp34_ = NULL;
		gchar* _tmp35_;
		gchar* _tmp36_;
		_tmp30_ = g_file_get_parent (exec_file);
		_tmp31_ = _tmp30_;
		_tmp32_ = g_file_get_parent (_tmp31_);
		_tmp33_ = _tmp32_;
		_tmp34_ = g_file_get_path (_tmp33_);
		_tmp35_ = _tmp34_;
		_tmp36_ = g_strconcat (_tmp35_, "/share/locale", NULL);
		_g_free0 (_tmp29_);
		_tmp29_ = _tmp36_;
		_g_free0 (_tmp35_);
		_g_object_unref0 (_tmp33_);
		_g_object_unref0 (_tmp31_);
	} else {
		gchar* _tmp37_;
		_tmp37_ = g_strconcat (resource_resource_dir, "/locale", NULL);
		_g_free0 (_tmp29_);
		_tmp29_ = _tmp37_;
	}
	_tmp38_ = g_strdup (_tmp29_);
	_tmp39_ = _tmp38_;
	_g_free0 (resource_locale_dir);
	resource_locale_dir = _tmp39_;
	fprintf (stdout, "Locale_dir is %s \n", resource_locale_dir);
	_tmp40_ = g_strconcat (resource_resource_dir, "/icons", NULL);
	_g_free0 (resource_icon_dir);
	resource_icon_dir = _tmp40_;
	_tmp41_ = g_strconcat (resource_resource_dir, "/mallard", NULL);
	_g_free0 (resource_mallard_manual_dir);
	resource_mallard_manual_dir = _tmp41_;
	_tmp42_ = g_strconcat (resource_resource_dir, "/html", NULL);
	_g_free0 (resource_html_manual_dir);
	resource_html_manual_dir = _tmp42_;
	_tmp43_ = config_get_instance ();
	_tmp44_ = _tmp43_;
	_tmp45_ = g_strconcat (resource_resource_dir, "/games", NULL);
	_tmp46_ = config_get_game_dir (_tmp44_, _tmp45_);
	_tmp47_ = _tmp46_;
	_g_free0 (resource_game_dir);
	resource_game_dir = _tmp47_;
	_g_free0 (_tmp45_);
	_config_unref0 (_tmp44_);
	_tmp48_ = config_get_instance ();
	_tmp49_ = _tmp48_;
	_tmp50_ = config_get_game_name (_tmp49_, RESOURCE_DEFAULTGAMENAME);
	_tmp51_ = _tmp50_;
	_g_free0 (resource_game_name);
	resource_game_name = _tmp51_;
	_config_unref0 (_tmp49_);
	_tmp52_ = g_new0 (GdkColor, 2 * 4);
	_tmp53_ = _tmp52_;
	resource_colors = (g_free (resource_colors), NULL);
	resource_colors_length1 = 2;
	resource_colors_length2 = 4;
	resource_colors = _tmp53_;
	setting = (gint) GAME_STATE_SETTING;
	gdk_color_parse ("GREY", &_tmp54_);
	resource_colors[(setting * resource_colors_length2) + ((gint) CELL_STATE_UNKNOWN)] = _tmp54_;
	gdk_color_parse ("WHITE", &_tmp55_);
	resource_colors[(setting * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)] = _tmp55_;
	gdk_color_parse ("BLACK", &_tmp56_);
	resource_colors[(setting * resource_colors_length2) + ((gint) CELL_STATE_FILLED)] = _tmp56_;
	gdk_color_parse ("RED", &_tmp57_);
	resource_colors[(setting * resource_colors_length2) + ((gint) CELL_STATE_ERROR)] = _tmp57_;
	solving = (gint) GAME_STATE_SOLVING;
	gdk_color_parse ("GREY", &_tmp58_);
	resource_colors[(solving * resource_colors_length2) + ((gint) CELL_STATE_UNKNOWN)] = _tmp58_;
	gdk_color_parse ("YELLOW", &_tmp59_);
	resource_colors[(solving * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)] = _tmp59_;
	gdk_color_parse ("BLUE", &_tmp60_);
	resource_colors[(solving * resource_colors_length2) + ((gint) CELL_STATE_FILLED)] = _tmp60_;
	gdk_color_parse ("RED", &_tmp61_);
	resource_colors[(solving * resource_colors_length2) + ((gint) CELL_STATE_ERROR)] = _tmp61_;
	_tmp62_ = config_get_instance ();
	_tmp63_ = _tmp62_;
	_tmp65_ = config_get_colors (_tmp63_, &_tmp64_);
	config_colors = (_tmp66_ = _tmp65_, _config_unref0 (_tmp63_), _tmp66_);
	config_colors_length1 = _tmp64_;
	_config_colors_size_ = _tmp64_;
	gdk_color_parse (config_colors[0], &_tmp67_);
	resource_colors[(setting * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)] = _tmp67_;
	gdk_color_parse (config_colors[1], &_tmp68_);
	resource_colors[(setting * resource_colors_length2) + ((gint) CELL_STATE_FILLED)] = _tmp68_;
	gdk_color_parse (config_colors[2], &_tmp69_);
	resource_colors[(solving * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)] = _tmp69_;
	gdk_color_parse (config_colors[3], &_tmp70_);
	resource_colors[(solving * resource_colors_length2) + ((gint) CELL_STATE_FILLED)] = _tmp70_;
	_tmp71_ = g_strdup ("Ariel");
	_tmp72_ = _tmp71_;
	_g_free0 (resource_font_desc);
	resource_font_desc = _tmp72_;
	_tmp73_ = g_new0 (gdouble, 2);
	_tmp73_[0] = 0.5;
	_tmp73_[1] = 3.0;
	_tmp74_ = _tmp73_;
	resource_MINORGRIDDASH = (g_free (resource_MINORGRIDDASH), NULL);
	resource_MINORGRIDDASH_length1 = 2;
	resource_MINORGRIDDASH = _tmp74_;
	config_colors = (_vala_array_free (config_colors, config_colors_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (_tmp29_);
	_g_free0 (_tmp17_);
	_g_object_unref0 (exec_file);
}


gboolean resource_is_installed (const gchar* exec_dir) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (exec_dir != NULL, FALSE);
	_tmp1_ = g_str_has_prefix (exec_dir, resource_prefix);
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


gchar* resource_get_langpack_dir (void) {
	gchar* result = NULL;
	gchar* _tmp0_;
	_tmp0_ = g_strdup (resource_locale_dir);
	result = _tmp0_;
	return result;
}


void resource_set_colors (void) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GtkDialog* _tmp2_ = NULL;
	GtkDialog* dialog;
	const gchar* _tmp3_ = NULL;
	GtkLabel* _tmp4_ = NULL;
	GtkLabel* fset_label;
	const gchar* _tmp5_ = NULL;
	GtkLabel* _tmp6_ = NULL;
	GtkLabel* eset_label;
	const gchar* _tmp7_ = NULL;
	GtkLabel* _tmp8_ = NULL;
	GtkLabel* fsolve_label;
	const gchar* _tmp9_ = NULL;
	GtkLabel* _tmp10_ = NULL;
	GtkLabel* esolve_label;
	GtkVBox* _tmp11_ = NULL;
	GtkVBox* label_box;
	GdkColor _tmp12_;
	GtkColorButton* _tmp13_ = NULL;
	GtkColorButton* filled_setting;
	const gchar* _tmp14_ = NULL;
	GdkColor _tmp15_;
	GtkColorButton* _tmp16_ = NULL;
	GtkColorButton* empty_setting;
	const gchar* _tmp17_ = NULL;
	GdkColor _tmp18_;
	GtkColorButton* _tmp19_ = NULL;
	GtkColorButton* filled_solving;
	const gchar* _tmp20_ = NULL;
	GdkColor _tmp21_;
	GtkColorButton* _tmp22_ = NULL;
	GtkColorButton* empty_solving;
	const gchar* _tmp23_ = NULL;
	GtkVBox* _tmp24_ = NULL;
	GtkVBox* button_box;
	GtkHBox* _tmp25_ = NULL;
	GtkHBox* hbox;
	gint _tmp26_;
	_tmp0_ = _ ("Ok");
	_tmp1_ = _ ("Cancel");
	_tmp2_ = (GtkDialog*) gtk_dialog_new_with_buttons (NULL, NULL, GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT, _tmp0_, GTK_RESPONSE_OK, _tmp1_, GTK_RESPONSE_CANCEL, NULL);
	dialog = g_object_ref_sink (_tmp2_);
	_tmp3_ = _ ("Color of filled cell when setting");
	_tmp4_ = (GtkLabel*) gtk_label_new (_tmp3_);
	fset_label = g_object_ref_sink (_tmp4_);
	_tmp5_ = _ ("Color of empty cell when setting");
	_tmp6_ = (GtkLabel*) gtk_label_new (_tmp5_);
	eset_label = g_object_ref_sink (_tmp6_);
	_tmp7_ = _ ("Color of filled cell when solving");
	_tmp8_ = (GtkLabel*) gtk_label_new (_tmp7_);
	fsolve_label = g_object_ref_sink (_tmp8_);
	_tmp9_ = _ ("Color of empty cell when solving");
	_tmp10_ = (GtkLabel*) gtk_label_new (_tmp9_);
	esolve_label = g_object_ref_sink (_tmp10_);
	_tmp11_ = (GtkVBox*) gtk_vbox_new (FALSE, 5);
	label_box = g_object_ref_sink (_tmp11_);
	gtk_container_add (GTK_CONTAINER (label_box), GTK_WIDGET (fset_label));
	gtk_container_add (GTK_CONTAINER (label_box), GTK_WIDGET (eset_label));
	gtk_container_add (GTK_CONTAINER (label_box), GTK_WIDGET (fsolve_label));
	gtk_container_add (GTK_CONTAINER (label_box), GTK_WIDGET (esolve_label));
	_tmp13_ = (GtkColorButton*) gtk_color_button_new_with_color ((_tmp12_ = resource_colors[(((gint) GAME_STATE_SETTING) * resource_colors_length2) + ((gint) CELL_STATE_FILLED)], &_tmp12_));
	filled_setting = g_object_ref_sink (_tmp13_);
	_tmp14_ = _ ("Color of filled cell when setting");
	gtk_color_button_set_title (filled_setting, _tmp14_);
	_tmp16_ = (GtkColorButton*) gtk_color_button_new_with_color ((_tmp15_ = resource_colors[(((gint) GAME_STATE_SETTING) * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)], &_tmp15_));
	empty_setting = g_object_ref_sink (_tmp16_);
	_tmp17_ = _ ("Color of empty cell when setting");
	gtk_color_button_set_title (empty_setting, _tmp17_);
	_tmp19_ = (GtkColorButton*) gtk_color_button_new_with_color ((_tmp18_ = resource_colors[(((gint) GAME_STATE_SOLVING) * resource_colors_length2) + ((gint) CELL_STATE_FILLED)], &_tmp18_));
	filled_solving = g_object_ref_sink (_tmp19_);
	_tmp20_ = _ ("Color of filled cell when solving");
	gtk_color_button_set_title (filled_solving, _tmp20_);
	_tmp22_ = (GtkColorButton*) gtk_color_button_new_with_color ((_tmp21_ = resource_colors[(((gint) GAME_STATE_SOLVING) * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)], &_tmp21_));
	empty_solving = g_object_ref_sink (_tmp22_);
	_tmp23_ = _ ("Color of empty cell when solving");
	gtk_color_button_set_title (empty_solving, _tmp23_);
	_tmp24_ = (GtkVBox*) gtk_vbox_new (FALSE, 5);
	button_box = g_object_ref_sink (_tmp24_);
	gtk_container_add (GTK_CONTAINER (button_box), GTK_WIDGET (filled_setting));
	gtk_container_add (GTK_CONTAINER (button_box), GTK_WIDGET (empty_setting));
	gtk_container_add (GTK_CONTAINER (button_box), GTK_WIDGET (filled_solving));
	gtk_container_add (GTK_CONTAINER (button_box), GTK_WIDGET (empty_solving));
	_tmp25_ = (GtkHBox*) gtk_hbox_new (FALSE, 5);
	hbox = g_object_ref_sink (_tmp25_);
	gtk_container_add (GTK_CONTAINER (hbox), GTK_WIDGET (label_box));
	gtk_container_add (GTK_CONTAINER (hbox), GTK_WIDGET (button_box));
	gtk_container_add (GTK_CONTAINER (dialog->vbox), GTK_WIDGET (hbox));
	gtk_widget_show_all (GTK_WIDGET (dialog));
	_tmp26_ = gtk_dialog_run (dialog);
	if (_tmp26_ == GTK_RESPONSE_OK) {
		GdkColor _tmp27_ = {0};
		GdkColor _tmp28_ = {0};
		GdkColor _tmp29_ = {0};
		GdkColor _tmp30_ = {0};
		gtk_color_button_get_color (filled_setting, &_tmp27_);
		resource_colors[(((gint) GAME_STATE_SETTING) * resource_colors_length2) + ((gint) CELL_STATE_FILLED)] = _tmp27_;
		gtk_color_button_get_color (empty_setting, &_tmp28_);
		resource_colors[(((gint) GAME_STATE_SETTING) * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)] = _tmp28_;
		gtk_color_button_get_color (filled_solving, &_tmp29_);
		resource_colors[(((gint) GAME_STATE_SOLVING) * resource_colors_length2) + ((gint) CELL_STATE_FILLED)] = _tmp29_;
		gtk_color_button_get_color (empty_solving, &_tmp30_);
		resource_colors[(((gint) GAME_STATE_SOLVING) * resource_colors_length2) + ((gint) CELL_STATE_EMPTY)] = _tmp30_;
	}
	gtk_object_destroy (GTK_OBJECT (dialog));
	_g_object_unref0 (hbox);
	_g_object_unref0 (button_box);
	_g_object_unref0 (empty_solving);
	_g_object_unref0 (filled_solving);
	_g_object_unref0 (empty_setting);
	_g_object_unref0 (filled_setting);
	_g_object_unref0 (label_box);
	_g_object_unref0 (esolve_label);
	_g_object_unref0 (fsolve_label);
	_g_object_unref0 (eset_label);
	_g_object_unref0 (fset_label);
	_g_object_unref0 (dialog);
}


void resource_set_font (void) {
	GtkFontSelectionDialog* _tmp0_ = NULL;
	GtkFontSelectionDialog* dialog;
	gint _tmp1_;
	_tmp0_ = (GtkFontSelectionDialog*) gtk_font_selection_dialog_new ("Select font used for the clues");
	dialog = g_object_ref_sink (_tmp0_);
	_tmp1_ = gtk_dialog_run (GTK_DIALOG (dialog));
	if (_tmp1_ != GTK_RESPONSE_CANCEL) {
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		_tmp2_ = gtk_font_selection_dialog_get_font_name (dialog);
		_tmp3_ = g_strdup (_tmp2_);
		_tmp4_ = _tmp3_;
		_g_free0 (resource_font_desc);
		resource_font_desc = _tmp4_;
	}
	gtk_object_destroy (GTK_OBJECT (dialog));
	_g_object_unref0 (dialog);
}


void resource_get_icon_theme (void) {
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_;
	GtkIconTheme* _tmp2_;
	const gchar* _tmp3_ = NULL;
	_tmp0_ = gtk_icon_theme_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_tmp2_ = _tmp1_;
	_g_object_unref0 (resource_icon_theme);
	resource_icon_theme = _tmp2_;
	_tmp3_ = gtk_icon_theme_get_example_icon_name (resource_icon_theme);
	fprintf (stdout, "Icon theme is %s\n", _tmp3_);
}


GdkPixbuf* resource_get_theme_icon (const gchar* icon_name) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* icon;
	GdkPixbuf* _tmp0_ = NULL;
	GdkPixbuf* _tmp1_;
	GdkPixbuf* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (icon_name != NULL, NULL);
	icon = NULL;
	fprintf (stdout, "Looking up theme icon %s\n", icon_name);
	_tmp0_ = gtk_icon_theme_load_icon (resource_icon_theme, icon_name, resource_icon_size, GTK_ICON_LOOKUP_NO_SVG | GTK_ICON_LOOKUP_FORCE_SIZE, &_inner_error_);
	_tmp1_ = _tmp0_;
	if (_inner_error_ != NULL) {
		goto __catch9_g_error;
	}
	_tmp2_ = _tmp1_;
	_g_object_unref0 (icon);
	icon = _tmp2_;
	goto __finally9;
	__catch9_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Failed to load theme icon %s\n", icon_name);
		_g_error_free0 (e);
	}
	__finally9:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (icon);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = icon;
	return result;
}


GdkPixbuf* resource_get_app_icon (const gchar* icon_filename) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* icon;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	GdkPixbuf* _tmp4_ = NULL;
	GdkPixbuf* _tmp5_;
	GdkPixbuf* _tmp6_;
	GdkPixbuf* _tmp7_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (icon_filename != NULL, NULL);
	icon = NULL;
	_tmp0_ = g_strconcat (resource_icon_dir, "/", NULL);
	_tmp1_ = g_strconcat (_tmp0_, icon_filename, NULL);
	fprintf (stdout, "Looking up app icon %s\n", _tmp1_);
	_g_free0 (_tmp1_);
	_g_free0 (_tmp0_);
	_tmp2_ = g_strconcat (resource_icon_dir, "/", NULL);
	_tmp3_ = g_strconcat (_tmp2_, icon_filename, NULL);
	_tmp4_ = gdk_pixbuf_new_from_file (_tmp3_, &_inner_error_);
	_tmp6_ = (_tmp5_ = _tmp4_, _g_free0 (_tmp3_), _g_free0 (_tmp2_), _tmp5_);
	if (_inner_error_ != NULL) {
		goto __catch10_g_error;
	}
	_tmp7_ = _tmp6_;
	_g_object_unref0 (icon);
	icon = _tmp7_;
	goto __finally10;
	__catch10_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		fprintf (stdout, "Failed to load app icon %s\n", icon_filename);
		_g_error_free0 (e);
	}
	__finally10:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (icon);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = icon;
	return result;
}


GdkPixbuf* resource_get_icon (ResourceIconID id) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* icon;
	gchar* icon_filename = NULL;
	gchar* icon_themename = NULL;
	GdkPixbuf* _tmp28_ = NULL;
	GdkPixbuf* _tmp29_;
	icon = NULL;
	switch (id) {
		case RESOURCE_ICON_ID_PEEK:
		{
			gchar* _tmp0_;
			gchar* _tmp1_;
			gchar* _tmp2_;
			gchar* _tmp3_;
			_tmp0_ = g_strdup (RESOURCE_PEEKICONFILENAME);
			_tmp1_ = _tmp0_;
			_g_free0 (icon_filename);
			icon_filename = _tmp1_;
			_tmp2_ = g_strdup (RESOURCE_PEEKICONTHEMENAME);
			_tmp3_ = _tmp2_;
			_g_free0 (icon_themename);
			icon_themename = _tmp3_;
			break;
		}
		case RESOURCE_ICON_ID_SOLVE:
		{
			gchar* _tmp4_;
			gchar* _tmp5_;
			gchar* _tmp6_;
			gchar* _tmp7_;
			_tmp4_ = g_strdup (RESOURCE_SOLVEICONFILENAME);
			_tmp5_ = _tmp4_;
			_g_free0 (icon_filename);
			icon_filename = _tmp5_;
			_tmp6_ = g_strdup (RESOURCE_SOLVEICONTHEMENAME);
			_tmp7_ = _tmp6_;
			_g_free0 (icon_themename);
			icon_themename = _tmp7_;
			break;
		}
		case RESOURCE_ICON_ID_RANDOM:
		{
			gchar* _tmp8_;
			gchar* _tmp9_;
			gchar* _tmp10_;
			gchar* _tmp11_;
			_tmp8_ = g_strdup (RESOURCE_RANDOMICONFILENAME);
			_tmp9_ = _tmp8_;
			_g_free0 (icon_filename);
			icon_filename = _tmp9_;
			_tmp10_ = g_strdup (RESOURCE_RANDOMICONTHEMENAME);
			_tmp11_ = _tmp10_;
			_g_free0 (icon_themename);
			icon_themename = _tmp11_;
			break;
		}
		case RESOURCE_ICON_ID_RESIZE:
		{
			gchar* _tmp12_;
			gchar* _tmp13_;
			gchar* _tmp14_;
			gchar* _tmp15_;
			_tmp12_ = g_strdup (RESOURCE_RESIZEICONFILENAME);
			_tmp13_ = _tmp12_;
			_g_free0 (icon_filename);
			icon_filename = _tmp13_;
			_tmp14_ = g_strdup (RESOURCE_RESIZEICONTHEMENAME);
			_tmp15_ = _tmp14_;
			_g_free0 (icon_themename);
			icon_themename = _tmp15_;
			break;
		}
		case RESOURCE_ICON_ID_HIDE:
		{
			gchar* _tmp16_;
			gchar* _tmp17_;
			gchar* _tmp18_;
			gchar* _tmp19_;
			_tmp16_ = g_strdup (RESOURCE_HIDEICONFILENAME);
			_tmp17_ = _tmp16_;
			_g_free0 (icon_filename);
			icon_filename = _tmp17_;
			_tmp18_ = g_strdup (RESOURCE_HIDEICONTHEMENAME);
			_tmp19_ = _tmp18_;
			_g_free0 (icon_themename);
			icon_themename = _tmp19_;
			break;
		}
		case RESOURCE_ICON_ID_REVEAL:
		{
			gchar* _tmp20_;
			gchar* _tmp21_;
			gchar* _tmp22_;
			gchar* _tmp23_;
			_tmp20_ = g_strdup (RESOURCE_REVEALICONFILENAME);
			_tmp21_ = _tmp20_;
			_g_free0 (icon_filename);
			icon_filename = _tmp21_;
			_tmp22_ = g_strdup (RESOURCE_REVEALICONTHEMENAME);
			_tmp23_ = _tmp22_;
			_g_free0 (icon_themename);
			icon_themename = _tmp23_;
			break;
		}
		default:
		{
			gchar* _tmp24_;
			gchar* _tmp25_;
			gchar* _tmp26_;
			gchar* _tmp27_;
			_tmp24_ = g_strdup (RESOURCE_MISSINGICONFILENAME);
			_tmp25_ = _tmp24_;
			_g_free0 (icon_filename);
			icon_filename = _tmp25_;
			_tmp26_ = g_strdup (RESOURCE_MISSINGICONTHEMENAME);
			_tmp27_ = _tmp26_;
			_g_free0 (icon_themename);
			icon_themename = _tmp27_;
			break;
		}
	}
	_tmp28_ = resource_get_theme_icon (icon_themename);
	_tmp29_ = _tmp28_;
	_g_object_unref0 (icon);
	icon = _tmp29_;
	if (icon == NULL) {
		GdkPixbuf* _tmp30_ = NULL;
		GdkPixbuf* _tmp31_;
		_tmp30_ = resource_get_app_icon (icon_filename);
		_tmp31_ = _tmp30_;
		_g_object_unref0 (icon);
		icon = _tmp31_;
		if (icon == NULL) {
			GdkPixbuf* _tmp32_ = NULL;
			GdkPixbuf* _tmp33_;
			_tmp32_ = resource_get_theme_icon (RESOURCE_MISSINGICONTHEMENAME);
			_tmp33_ = _tmp32_;
			_g_object_unref0 (icon);
			icon = _tmp33_;
		}
	}
	result = icon;
	_g_free0 (icon_themename);
	_g_free0 (icon_filename);
	return result;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




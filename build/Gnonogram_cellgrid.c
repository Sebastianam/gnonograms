/* Gnonogram_cellgrid.c generated by valac 0.11.6, the Vala compiler
 * generated from Gnonogram_cellgrid.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 * 
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <cairo.h>


#define TYPE_GNONOGRAM_CELLGRID (gnonogram_cellgrid_get_type ())
#define GNONOGRAM_CELLGRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGrid))
#define GNONOGRAM_CELLGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGridClass))
#define IS_GNONOGRAM_CELLGRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_CELLGRID))
#define IS_GNONOGRAM_CELLGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_CELLGRID))
#define GNONOGRAM_CELLGRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGridClass))

typedef struct _Gnonogram_CellGrid Gnonogram_CellGrid;
typedef struct _Gnonogram_CellGridClass Gnonogram_CellGridClass;
typedef struct _Gnonogram_CellGridPrivate Gnonogram_CellGridPrivate;

#define TYPE_CELL (cell_get_type ())

#define TYPE_CELL_STATE (cell_state_get_type ())
typedef struct _Cell Cell;

#define TYPE_GAME_STATE (game_state_get_type ())
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

struct _Gnonogram_CellGrid {
	GtkDrawingArea parent_instance;
	Gnonogram_CellGridPrivate * priv;
};

struct _Gnonogram_CellGridClass {
	GtkDrawingAreaClass parent_class;
};

struct _Gnonogram_CellGridPrivate {
	gint _rows;
	gint _cols;
	gdouble _aw;
	gdouble _ah;
	gdouble _wd;
	gdouble _ht;
	GdkColor cr_color;
	gdouble _cell_offset;
	gdouble _cell_body_width;
	gdouble _cell_body_height;
	gdouble* minor_grid_dash;
	gint minor_grid_dash_length1;
	gint _minor_grid_dash_size_;
};

typedef enum  {
	CELL_STATE_UNKNOWN,
	CELL_STATE_EMPTY,
	CELL_STATE_FILLED,
	CELL_STATE_ERROR,
	CELL_STATE_COMPLETED
} CellState;

struct _Cell {
	gint row;
	gint col;
	CellState state;
};

typedef enum  {
	GAME_STATE_SETTING,
	GAME_STATE_SOLVING
} GameState;


static gpointer gnonogram_cellgrid_parent_class = NULL;
extern GdkColor* resource_colors;
extern gint resource_colors_length1;
extern gint resource_colors_length2;

GType gnonogram_cellgrid_get_type (void) G_GNUC_CONST;
#define GNONOGRAM_CELLGRID_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGridPrivate))
enum  {
	GNONOGRAM_CELLGRID_DUMMY_PROPERTY
};
Gnonogram_CellGrid* gnonogram_cellgrid_new (gint r, gint c);
Gnonogram_CellGrid* gnonogram_cellgrid_construct (GType object_type, gint r, gint c);
static gboolean gnonogram_cellgrid_pointer_moved (Gnonogram_CellGrid* self, GtkWidget* w, GdkEventMotion* e);
static gboolean _gnonogram_cellgrid_pointer_moved_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self);
void gnonogram_cellgrid_resize (Gnonogram_CellGrid* self, gint r, gint c);
void gnonogram_cellgrid_prepare_to_redraw_cells (Gnonogram_CellGrid* self, gboolean show_grid);
static void gnonogram_cellgrid_draw_grid (Gnonogram_CellGrid* self);
GType cell_get_type (void) G_GNUC_CONST;
GType cell_state_get_type (void) G_GNUC_CONST;
Cell* cell_dup (const Cell* self);
void cell_free (Cell* self);
GType game_state_get_type (void) G_GNUC_CONST;
void gnonogram_cellgrid_draw_cell (Gnonogram_CellGrid* self, Cell* cell, GameState gs, gboolean isvalid);
static void gnonogram_cellgrid_draw_cell_body (Gnonogram_CellGrid* self, cairo_t* _cr, gdouble x, gdouble y);
void gnonogram_cellgrid_highlight_cell (Gnonogram_CellGrid* self, Cell* cell, gboolean highlight);
static void gnonogram_cellgrid_draw_cell_highlight (Gnonogram_CellGrid* self, cairo_t* _cr, gdouble x, gdouble y);
static void g_cclosure_user_marshal_VOID__INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void gnonogram_cellgrid_finalize (GObject* obj);


static gboolean _gnonogram_cellgrid_pointer_moved_gtk_widget_motion_notify_event (GtkWidget* _sender, GdkEventMotion* event, gpointer self) {
	gboolean result;
	result = gnonogram_cellgrid_pointer_moved (self, _sender, event);
	return result;
}


Gnonogram_CellGrid* gnonogram_cellgrid_construct (GType object_type, gint r, gint c) {
	Gnonogram_CellGrid * self = NULL;
	self = (Gnonogram_CellGrid*) g_object_new (object_type, NULL);
	self->priv->_rows = r;
	self->priv->_cols = c;
	gtk_widget_add_events (GTK_WIDGET (self), (gint) ((((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_POINTER_MOTION_MASK) | GDK_KEY_PRESS_MASK) | GDK_KEY_RELEASE_MASK));
	g_signal_connect_object (GTK_WIDGET (self), "motion-notify-event", (GCallback) _gnonogram_cellgrid_pointer_moved_gtk_widget_motion_notify_event, self, 0);
	return self;
}


Gnonogram_CellGrid* gnonogram_cellgrid_new (gint r, gint c) {
	return gnonogram_cellgrid_construct (TYPE_GNONOGRAM_CELLGRID, r, c);
}


void gnonogram_cellgrid_resize (Gnonogram_CellGrid* self, gint r, gint c) {
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	self->priv->_rows = r;
	self->priv->_cols = c;
}


void gnonogram_cellgrid_prepare_to_redraw_cells (Gnonogram_CellGrid* self, gboolean show_grid) {
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	self->priv->_aw = (gdouble) GTK_WIDGET (self)->allocation.width;
	self->priv->_ah = (gdouble) GTK_WIDGET (self)->allocation.height;
	self->priv->_wd = (self->priv->_aw - 2) / ((gdouble) self->priv->_cols);
	self->priv->_ht = (self->priv->_ah - 2) / ((gdouble) self->priv->_rows);
	gdk_window_clear (GTK_WIDGET (self)->window);
	if (show_grid) {
		self->priv->_cell_offset = 3.0;
		gnonogram_cellgrid_draw_grid (self);
	} else {
		self->priv->_cell_offset = 1.0;
	}
	self->priv->_cell_body_width = self->priv->_wd - (self->priv->_cell_offset * 2.0);
	self->priv->_cell_body_height = self->priv->_ht - (self->priv->_cell_offset * 2.0);
}


void gnonogram_cellgrid_draw_cell (Gnonogram_CellGrid* self, Cell* cell, GameState gs, gboolean isvalid) {
	gdouble x;
	gdouble y;
	gint cs;
	cairo_t* _tmp0_ = NULL;
	cairo_t* _cr;
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	x = (((*cell).col * self->priv->_wd) + self->priv->_cell_offset) + 1.0;
	y = (((*cell).row * self->priv->_ht) + self->priv->_cell_offset) + 1.0;
	cs = (gint) (*cell).state;
	_tmp0_ = gdk_cairo_create (GDK_DRAWABLE (GTK_WIDGET (self)->window));
	_cr = _tmp0_;
	if (cs == CELL_STATE_UNKNOWN) {
		GtkStyle* _tmp1_ = NULL;
		_tmp1_ = gtk_widget_get_style (GTK_WIDGET (self));
		self->priv->cr_color = _tmp1_->bg[GTK_STATE_NORMAL];
	} else {
		self->priv->cr_color = resource_colors[(gs * resource_colors_length2) + cs];
	}
	gdk_cairo_set_source_color (_cr, &self->priv->cr_color);
	gnonogram_cellgrid_draw_cell_body (self, _cr, x, y);
	_cairo_destroy0 (_cr);
}


static void gnonogram_cellgrid_draw_cell_body (Gnonogram_CellGrid* self, cairo_t* _cr, gdouble x, gdouble y) {
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	g_return_if_fail (_cr != NULL);
	cairo_rectangle (_cr, x, y, self->priv->_cell_body_width, self->priv->_cell_body_height);
	cairo_fill (_cr);
}


void gnonogram_cellgrid_highlight_cell (Gnonogram_CellGrid* self, Cell* cell, gboolean highlight) {
	gdouble x;
	gdouble y;
	cairo_t* _tmp0_ = NULL;
	cairo_t* _cr;
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	x = ((*cell).col * self->priv->_wd) + self->priv->_cell_offset;
	y = ((*cell).row * self->priv->_ht) + self->priv->_cell_offset;
	_tmp0_ = gdk_cairo_create (GDK_DRAWABLE (GTK_WIDGET (self)->window));
	_cr = _tmp0_;
	if (highlight) {
		GtkStyle* _tmp1_ = NULL;
		_tmp1_ = gtk_widget_get_style (GTK_WIDGET (self));
		self->priv->cr_color = _tmp1_->bg[GTK_STATE_SELECTED];
	} else {
		GtkStyle* _tmp2_ = NULL;
		_tmp2_ = gtk_widget_get_style (GTK_WIDGET (self));
		self->priv->cr_color = _tmp2_->bg[GTK_STATE_NORMAL];
	}
	gdk_cairo_set_source_color (_cr, &self->priv->cr_color);
	gnonogram_cellgrid_draw_cell_highlight (self, _cr, x, y);
	_cairo_destroy0 (_cr);
}


static void gnonogram_cellgrid_draw_cell_highlight (Gnonogram_CellGrid* self, cairo_t* _cr, gdouble x, gdouble y) {
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	g_return_if_fail (_cr != NULL);
	cairo_rectangle (_cr, x, y, self->priv->_cell_body_width + 2.0, self->priv->_cell_body_height + 2.0);
	cairo_stroke (_cr);
}


static void gnonogram_cellgrid_draw_grid (Gnonogram_CellGrid* self) {
	gdouble x1 = 0.0;
	gdouble x2 = 0.0;
	gdouble y1 = 0.0;
	gdouble y2 = 0.0;
	cairo_t* _tmp0_ = NULL;
	cairo_t* _cr;
	g_return_if_fail (IS_GNONOGRAM_CELLGRID (self));
	_tmp0_ = gdk_cairo_create (GDK_DRAWABLE (GTK_WIDGET (self)->window));
	_cr = _tmp0_;
	cairo_set_dash (_cr, self->priv->minor_grid_dash, self->priv->minor_grid_dash_length1, 0.0);
	cairo_set_line_width (_cr, 1.0);
	x1 = (gdouble) 0;
	x2 = self->priv->_aw - 1;
	{
		gint r;
		r = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					r++;
				}
				_tmp1_ = FALSE;
				if (!(r <= self->priv->_rows)) {
					break;
				}
				y1 = 1.0 + (r * self->priv->_ht);
				cairo_move_to (_cr, x1, y1);
				cairo_line_to (_cr, x2, y1);
				cairo_stroke (_cr);
			}
		}
	}
	y1 = (gdouble) 0;
	y2 = self->priv->_ah - 1;
	{
		gint c;
		c = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					c++;
				}
				_tmp2_ = FALSE;
				if (!(c <= self->priv->_cols)) {
					break;
				}
				x1 = 1.0 + (c * self->priv->_wd);
				cairo_move_to (_cr, x1, y1);
				cairo_line_to (_cr, x1, y2);
				cairo_stroke (_cr);
			}
		}
	}
	cairo_set_dash (_cr, NULL, 0, 0.0);
	cairo_set_line_width (_cr, 1.0);
	x1 = (gdouble) 0;
	x2 = self->priv->_aw - 1;
	{
		gint r;
		r = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				if (!_tmp3_) {
					r = r + 5;
				}
				_tmp3_ = FALSE;
				if (!(r <= self->priv->_rows)) {
					break;
				}
				y1 = 1 + (r * self->priv->_ht);
				cairo_move_to (_cr, x1, y1);
				cairo_line_to (_cr, x2, y1);
				cairo_stroke (_cr);
			}
		}
	}
	y1 = (gdouble) 0;
	y2 = self->priv->_ah - 1;
	{
		gint c;
		c = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					c = c + 5;
				}
				_tmp4_ = FALSE;
				if (!(c <= self->priv->_cols)) {
					break;
				}
				x1 = 1 + (c * self->priv->_wd);
				cairo_move_to (_cr, x1, y1);
				cairo_line_to (_cr, x1, y2);
				cairo_stroke (_cr);
			}
		}
	}
	_cairo_destroy0 (_cr);
}


static gboolean gnonogram_cellgrid_pointer_moved (Gnonogram_CellGrid* self, GtkWidget* w, GdkEventMotion* e) {
	gboolean result = FALSE;
	gint _tmp0_;
	gint r;
	gint _tmp1_;
	gint c;
	g_return_val_if_fail (IS_GNONOGRAM_CELLGRID (self), FALSE);
	g_return_val_if_fail (GTK_IS_WIDGET (w), FALSE);
	_tmp0_ = CLAMP ((gint) (((*e).y / self->priv->_ah) * self->priv->_rows), 0, self->priv->_rows - 1);
	r = _tmp0_;
	_tmp1_ = CLAMP ((gint) (((*e).x / self->priv->_aw) * self->priv->_cols), 0, self->priv->_cols - 1);
	c = _tmp1_;
	g_signal_emit_by_name (self, "cursor-moved", r, c);
	result = FALSE;
	return result;
}


static void g_cclosure_user_marshal_VOID__INT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__INT_INT) (gpointer data1, gint arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__INT_INT callback;
	register GCClosure * cc;
	register gpointer data1, data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__INT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_int (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void gnonogram_cellgrid_class_init (Gnonogram_CellGridClass * klass) {
	gnonogram_cellgrid_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (Gnonogram_CellGridPrivate));
	G_OBJECT_CLASS (klass)->finalize = gnonogram_cellgrid_finalize;
	g_signal_new ("cursor_moved", TYPE_GNONOGRAM_CELLGRID, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT_INT, G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_INT);
}


static void gnonogram_cellgrid_instance_init (Gnonogram_CellGrid * self) {
	gdouble* _tmp0_ = NULL;
	self->priv = GNONOGRAM_CELLGRID_GET_PRIVATE (self);
	_tmp0_ = g_new0 (gdouble, 2);
	_tmp0_[0] = 1.0;
	_tmp0_[1] = 2.0;
	self->priv->minor_grid_dash = _tmp0_;
	self->priv->minor_grid_dash_length1 = 2;
	self->priv->_minor_grid_dash_size_ = self->priv->minor_grid_dash_length1;
}


static void gnonogram_cellgrid_finalize (GObject* obj) {
	Gnonogram_CellGrid * self;
	self = GNONOGRAM_CELLGRID (obj);
	self->priv->minor_grid_dash = (g_free (self->priv->minor_grid_dash), NULL);
	G_OBJECT_CLASS (gnonogram_cellgrid_parent_class)->finalize (obj);
}


GType gnonogram_cellgrid_get_type (void) {
	static volatile gsize gnonogram_cellgrid_type_id__volatile = 0;
	if (g_once_init_enter (&gnonogram_cellgrid_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Gnonogram_CellGridClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnonogram_cellgrid_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Gnonogram_CellGrid), 0, (GInstanceInitFunc) gnonogram_cellgrid_instance_init, NULL };
		GType gnonogram_cellgrid_type_id;
		gnonogram_cellgrid_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "Gnonogram_CellGrid", &g_define_type_info, 0);
		g_once_init_leave (&gnonogram_cellgrid_type_id__volatile, gnonogram_cellgrid_type_id);
	}
	return gnonogram_cellgrid_type_id__volatile;
}




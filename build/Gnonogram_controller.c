/* Gnonogram_controller.c generated by valac 0.11.6, the Vala compiler
 * generated from Gnonogram_controller.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 * 
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */
/* experimental*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GNONOGRAM_CONTROLLER (gnonogram_controller_get_type ())
#define GNONOGRAM_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_CONTROLLER, Gnonogram_controller))
#define GNONOGRAM_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_CONTROLLER, Gnonogram_controllerClass))
#define IS_GNONOGRAM_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_CONTROLLER))
#define IS_GNONOGRAM_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_CONTROLLER))
#define GNONOGRAM_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_CONTROLLER, Gnonogram_controllerClass))

typedef struct _Gnonogram_controller Gnonogram_controller;
typedef struct _Gnonogram_controllerClass Gnonogram_controllerClass;
typedef struct _Gnonogram_controllerPrivate Gnonogram_controllerPrivate;

#define TYPE_GNONOGRAM_VIEW (gnonogram_view_get_type ())
#define GNONOGRAM_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_VIEW, Gnonogram_view))
#define GNONOGRAM_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_VIEW, Gnonogram_viewClass))
#define IS_GNONOGRAM_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_VIEW))
#define IS_GNONOGRAM_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_VIEW))
#define GNONOGRAM_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_VIEW, Gnonogram_viewClass))

typedef struct _Gnonogram_view Gnonogram_view;
typedef struct _Gnonogram_viewClass Gnonogram_viewClass;

#define TYPE_GNONOGRAM_LABELBOX (gnonogram_labelbox_get_type ())
#define GNONOGRAM_LABELBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBox))
#define GNONOGRAM_LABELBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBoxClass))
#define IS_GNONOGRAM_LABELBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_LABELBOX))
#define IS_GNONOGRAM_LABELBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_LABELBOX))
#define GNONOGRAM_LABELBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBoxClass))

typedef struct _Gnonogram_LabelBox Gnonogram_LabelBox;
typedef struct _Gnonogram_LabelBoxClass Gnonogram_LabelBoxClass;

#define TYPE_GNONOGRAM_CELLGRID (gnonogram_cellgrid_get_type ())
#define GNONOGRAM_CELLGRID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGrid))
#define GNONOGRAM_CELLGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGridClass))
#define IS_GNONOGRAM_CELLGRID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_CELLGRID))
#define IS_GNONOGRAM_CELLGRID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_CELLGRID))
#define GNONOGRAM_CELLGRID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_CELLGRID, Gnonogram_CellGridClass))

typedef struct _Gnonogram_CellGrid Gnonogram_CellGrid;
typedef struct _Gnonogram_CellGridClass Gnonogram_CellGridClass;

#define TYPE_GNONOGRAM_MODEL (gnonogram_model_get_type ())
#define GNONOGRAM_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_MODEL, Gnonogram_model))
#define GNONOGRAM_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_MODEL, Gnonogram_modelClass))
#define IS_GNONOGRAM_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_MODEL))
#define IS_GNONOGRAM_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_MODEL))
#define GNONOGRAM_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_MODEL, Gnonogram_modelClass))

typedef struct _Gnonogram_model Gnonogram_model;
typedef struct _Gnonogram_modelClass Gnonogram_modelClass;

#define TYPE_GNONOGRAM_SOLVER (gnonogram_solver_get_type ())
#define GNONOGRAM_SOLVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_SOLVER, Gnonogram_solver))
#define GNONOGRAM_SOLVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_SOLVER, Gnonogram_solverClass))
#define IS_GNONOGRAM_SOLVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_SOLVER))
#define IS_GNONOGRAM_SOLVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_SOLVER))
#define GNONOGRAM_SOLVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_SOLVER, Gnonogram_solverClass))

typedef struct _Gnonogram_solver Gnonogram_solver;
typedef struct _Gnonogram_solverClass Gnonogram_solverClass;

#define TYPE_CELL (cell_get_type ())

#define TYPE_CELL_STATE (cell_state_get_type ())
typedef struct _Cell Cell;

#define TYPE_GAME_STATE (game_state_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _gnonogram_model_unref0(var) ((var == NULL) ? NULL : (var = (gnonogram_model_unref (var), NULL)))
#define _gnonogram_solver_unref0(var) ((var == NULL) ? NULL : (var = (gnonogram_solver_unref (var), NULL)))

#define TYPE_CONFIG (config_get_type ())
#define CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG, Config))
#define CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG, ConfigClass))
#define IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG))
#define IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG))
#define CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG, ConfigClass))

typedef struct _Config Config;
typedef struct _ConfigClass ConfigClass;
#define _config_unref0(var) ((var == NULL) ? NULL : (var = (config_unref (var), NULL)))

#define TYPE_BUTTON_PRESS (button_press_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

#define TYPE_GNONOGRAM_FILETYPE (gnonogram_filetype_get_type ())

#define TYPE_GNONOGRAM_FILEREADER (gnonogram_filereader_get_type ())
#define GNONOGRAM_FILEREADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereader))
#define GNONOGRAM_FILEREADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereaderClass))
#define IS_GNONOGRAM_FILEREADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_FILEREADER))
#define IS_GNONOGRAM_FILEREADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_FILEREADER))
#define GNONOGRAM_FILEREADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereaderClass))

typedef struct _Gnonogram_filereader Gnonogram_filereader;
typedef struct _Gnonogram_filereaderClass Gnonogram_filereaderClass;
typedef struct _Gnonogram_filereaderPrivate Gnonogram_filereaderPrivate;
#define _gnonogram_filereader_unref0(var) ((var == NULL) ? NULL : (var = (gnonogram_filereader_unref (var), NULL)))
#define _g_source_unref0(var) ((var == NULL) ? NULL : (var = (g_source_unref (var), NULL)))

#define TYPE_MY2_DCELL_ARRAY (my2_dcell_array_get_type ())
#define MY2_DCELL_ARRAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MY2_DCELL_ARRAY, My2DCellArray))
#define MY2_DCELL_ARRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MY2_DCELL_ARRAY, My2DCellArrayClass))
#define IS_MY2_DCELL_ARRAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MY2_DCELL_ARRAY))
#define IS_MY2_DCELL_ARRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MY2_DCELL_ARRAY))
#define MY2_DCELL_ARRAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MY2_DCELL_ARRAY, My2DCellArrayClass))

typedef struct _My2DCellArray My2DCellArray;
typedef struct _My2DCellArrayClass My2DCellArrayClass;
#define _my2_dcell_array_unref0(var) ((var == NULL) ? NULL : (var = (my2_dcell_array_unref (var), NULL)))
typedef struct _ParamSpecGnonogram_controller ParamSpecGnonogram_controller;

struct _Gnonogram_controller {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Gnonogram_controllerPrivate * priv;
	Gnonogram_view* _gnonogram_view;
	Gnonogram_LabelBox* _colbox;
	Gnonogram_LabelBox* _rowbox;
	Gnonogram_CellGrid* _cellgrid;
	Gnonogram_model* _model;
	Gnonogram_solver* _solver;
};

struct _Gnonogram_controllerClass {
	GTypeClass parent_class;
	void (*finalize) (Gnonogram_controller *self);
};

typedef enum  {
	CELL_STATE_UNKNOWN,
	CELL_STATE_EMPTY,
	CELL_STATE_FILLED,
	CELL_STATE_ERROR,
	CELL_STATE_COMPLETED
} CellState;

struct _Cell {
	gint row;
	gint col;
	CellState state;
};

typedef enum  {
	GAME_STATE_SETTING,
	GAME_STATE_SOLVING
} GameState;

struct _Gnonogram_controllerPrivate {
	gint _rows;
	gint _cols;
	Cell _current_cell;
	Cell _previous_cell;
	gboolean _is_button_down;
	gboolean _have_solution;
	GameState __state;
	gboolean _gridlinesvisible;
	gboolean _debug;
	gboolean _advanced;
	gboolean _difficult;
	gint _grade;
};

typedef enum  {
	BUTTON_PRESS_LEFT_SINGLE,
	BUTTON_PRESS_LEFT_DOUBLE,
	BUTTON_PRESS_MIDDLE_SINGLE,
	BUTTON_PRESS_MIDDLE_DOUBLE,
	BUTTON_PRESS_RIGHT_SINGLE,
	BUTTON_PRESS_RIGHT_DOUBLE,
	BUTTON_PRESS_UNDEFINED
} ButtonPress;

typedef enum  {
	GNONOGRAM_FILETYPE_GAME,
	GNONOGRAM_FILETYPE_POSITION
} Gnonogram_FileType;

struct _Gnonogram_filereader {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Gnonogram_filereaderPrivate * priv;
	gchar* filename;
	gint rows;
	gint cols;
	gchar** row_clues;
	gint row_clues_length1;
	gchar** col_clues;
	gint col_clues_length1;
	gchar* state;
	gchar* name;
	gchar* author;
	gchar* date;
	gchar* score;
	gboolean in_error;
	gboolean has_dimensions;
	gboolean has_row_clues;
	gboolean has_col_clues;
	gboolean has_solution;
	gboolean has_working;
	gboolean has_state;
	gchar** solution;
	gint solution_length1;
	gchar** working;
	gint working_length1;
};

struct _Gnonogram_filereaderClass {
	GTypeClass parent_class;
	void (*finalize) (Gnonogram_filereader *self);
};

struct _ParamSpecGnonogram_controller {
	GParamSpec parent_instance;
};


static gpointer gnonogram_controller_parent_class = NULL;
extern gint resource_MAXROWSIZE;
extern gint resource_MAXCOLSIZE;
extern gchar* resource_game_dir;
extern gint resource_MAXTRIES;

gpointer gnonogram_controller_ref (gpointer instance);
void gnonogram_controller_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_controller (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_controller (GValue* value, gpointer v_object);
void value_take_gnonogram_controller (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_controller (const GValue* value);
GType gnonogram_controller_get_type (void) G_GNUC_CONST;
GType gnonogram_view_get_type (void) G_GNUC_CONST;
GType gnonogram_labelbox_get_type (void) G_GNUC_CONST;
GType gnonogram_cellgrid_get_type (void) G_GNUC_CONST;
gpointer gnonogram_model_ref (gpointer instance);
void gnonogram_model_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_model (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_model (GValue* value, gpointer v_object);
void value_take_gnonogram_model (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_model (const GValue* value);
GType gnonogram_model_get_type (void) G_GNUC_CONST;
gpointer gnonogram_solver_ref (gpointer instance);
void gnonogram_solver_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_solver (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_solver (GValue* value, gpointer v_object);
void value_take_gnonogram_solver (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_solver (const GValue* value);
GType gnonogram_solver_get_type (void) G_GNUC_CONST;
GType cell_get_type (void) G_GNUC_CONST;
GType cell_state_get_type (void) G_GNUC_CONST;
Cell* cell_dup (const Cell* self);
void cell_free (Cell* self);
GType game_state_get_type (void) G_GNUC_CONST;
#define GNONOGRAM_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GNONOGRAM_CONTROLLER, Gnonogram_controllerPrivate))
enum  {
	GNONOGRAM_CONTROLLER_DUMMY_PROPERTY
};
Gnonogram_controller* gnonogram_controller_new (gint r, gint c);
Gnonogram_controller* gnonogram_controller_construct (GType object_type, gint r, gint c);
gpointer config_ref (gpointer instance);
void config_unref (gpointer instance);
GParamSpec* param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_config (GValue* value, gpointer v_object);
void value_take_config (GValue* value, gpointer v_object);
gpointer value_get_config (const GValue* value);
GType config_get_type (void) G_GNUC_CONST;
Config* config_get_instance (void);
void config_get_dimensions (Config* self, gint* r, gint* c);
Gnonogram_model* gnonogram_model_new (gint r, gint c);
Gnonogram_model* gnonogram_model_construct (GType object_type, gint r, gint c);
Gnonogram_solver* gnonogram_solver_new (gint rows, gint cols, gboolean testing, gboolean debug, gboolean test_column, gint test_idx);
Gnonogram_solver* gnonogram_solver_construct (GType object_type, gint rows, gint cols, gboolean testing, gboolean debug, gboolean test_column, gint test_idx);
static void gnonogram_controller_show_solver_grid (Gnonogram_controller* self);
static void _gnonogram_controller_show_solver_grid_gnonogram_solver_showsolvergrid (Gnonogram_solver* _sender, gpointer self);
gdouble config_get_difficulty (Config* self);
static void gnonogram_controller_create_view (Gnonogram_controller* self);
static void gnonogram_controller_initialize_view (Gnonogram_controller* self);
static void gnonogram_controller_change_state (Gnonogram_controller* self, GameState gs);
Gnonogram_LabelBox* gnonogram_labelbox_new (gint size, gint other_size, gboolean is_col);
Gnonogram_LabelBox* gnonogram_labelbox_construct (GType object_type, gint size, gint other_size, gboolean is_col);
Gnonogram_CellGrid* gnonogram_cellgrid_new (gint r, gint c);
Gnonogram_CellGrid* gnonogram_cellgrid_construct (GType object_type, gint r, gint c);
Gnonogram_view* gnonogram_view_new (Gnonogram_LabelBox* rb, Gnonogram_LabelBox* cb, Gnonogram_CellGrid* dg, Gnonogram_controller* controller);
Gnonogram_view* gnonogram_view_construct (GType object_type, Gnonogram_LabelBox* rb, Gnonogram_LabelBox* cb, Gnonogram_CellGrid* dg, Gnonogram_controller* controller);
static void gnonogram_controller_viewer_solve_game (Gnonogram_controller* self);
static void _gnonogram_controller_viewer_solve_game_gnonogram_view_solvegame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_save_game (Gnonogram_controller* self);
static void _gnonogram_controller_save_game_gnonogram_view_savegame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_load_game (Gnonogram_controller* self);
static void _gnonogram_controller_load_game_gnonogram_view_loadgame (Gnonogram_view* _sender, gpointer self);
static void gnonogram_controller_save_position (Gnonogram_controller* self);
static void _gnonogram_controller_save_position_gnonogram_view_saveposition (Gnonogram_view* _sender, gpointer self);
static void _lambda33_ (Gnonogram_controller* self);
void gnonogram_controller_load_position (Gnonogram_controller* self);
static GameState gnonogram_controller_get__state (Gnonogram_controller* self);
static void __lambda33__gnonogram_view_loadposition (Gnonogram_view* _sender, gpointer self);
static void _lambda34_ (Gnonogram_controller* self);
void gnonogram_controller_quit_game (Gnonogram_controller* self);
static void __lambda34__gnonogram_view_quitgamesignal (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_new_game (Gnonogram_controller* self);
static void _gnonogram_controller_new_game_gnonogram_view_newgame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_start_solving (Gnonogram_controller* self);
static void _gnonogram_controller_start_solving_gnonogram_view_hidegame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_reveal_solution (Gnonogram_controller* self);
static void _gnonogram_controller_reveal_solution_gnonogram_view_revealgame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_peek_game (Gnonogram_controller* self);
static void _gnonogram_controller_peek_game_gnonogram_view_peekgame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_restart_game (Gnonogram_controller* self);
static void _gnonogram_controller_restart_game_gnonogram_view_restartgame (Gnonogram_view* _sender, gpointer self);
void gnonogram_controller_random_game (Gnonogram_controller* self);
static void _gnonogram_controller_random_game_gnonogram_view_randomgame (Gnonogram_view* _sender, gpointer self);
static void _lambda36_ (Gnonogram_controller* self);
void resource_set_colors (void);
static void gnonogram_controller_redraw_all (Gnonogram_controller* self);
static void __lambda36__gnonogram_view_setcolors (Gnonogram_view* _sender, gpointer self);
static void _lambda37_ (Gnonogram_controller* self);
void resource_set_font (void);
void gnonogram_labelbox_change_font_height (Gnonogram_LabelBox* self, gboolean increase);
static void __lambda37__gnonogram_view_setfont (Gnonogram_view* _sender, gpointer self);
static void gnonogram_controller_change_size (Gnonogram_controller* self);
static void _gnonogram_controller_change_size_gnonogram_view_resizegame (Gnonogram_view* _sender, gpointer self);
static gboolean gnonogram_controller_key_pressed (Gnonogram_controller* self, GdkEventKey* e);
static gboolean _gnonogram_controller_key_pressed_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static gboolean gnonogram_controller_key_released (Gnonogram_controller* self, GdkEventKey* e);
static gboolean _gnonogram_controller_key_released_gtk_widget_key_release_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
void gnonogram_controller_set_difficulty (Gnonogram_controller* self, gdouble d);
static void _gnonogram_controller_set_difficulty_gnonogram_view_setdifficulty (Gnonogram_view* _sender, gdouble grade, gpointer self);
static void gnonogram_controller_gridlines_toggled (Gnonogram_controller* self, gboolean active);
static void _gnonogram_controller_gridlines_toggled_gnonogram_view_togglegrid (Gnonogram_view* _sender, gboolean active, gpointer self);
static void gnonogram_controller_change_font_size (Gnonogram_controller* self, gboolean increase);
static void _gnonogram_controller_change_font_size_gnonogram_view_changefont (Gnonogram_view* _sender, gboolean increase, gpointer self);
static void _lambda38_ (gboolean debug, Gnonogram_controller* self);
static void __lambda38__gnonogram_view_debugmode (Gnonogram_view* _sender, gboolean debug, gpointer self);
static void _lambda39_ (gboolean advanced, Gnonogram_controller* self);
static void __lambda39__gnonogram_view_advancedmode (Gnonogram_view* _sender, gboolean advanced, gpointer self);
static void _lambda40_ (gboolean difficult, Gnonogram_controller* self);
static void __lambda40__gnonogram_view_difficultmode (Gnonogram_view* _sender, gboolean difficult, gpointer self);
void gnonogram_controller_grid_cursor_moved (Gnonogram_controller* self, gint r, gint c);
static void _gnonogram_controller_grid_cursor_moved_gnonogram_cellgrid_cursor_moved (Gnonogram_CellGrid* _sender, gint r, gint c, gpointer self);
static gboolean gnonogram_controller_button_pressed (Gnonogram_controller* self, GdkEventButton* e);
static gboolean _gnonogram_controller_button_pressed_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean _lambda41_ (Gnonogram_controller* self);
static gboolean __lambda41__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static gboolean _lambda42_ (Gnonogram_controller* self);
static gboolean __lambda42__gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self);
void gnonogram_view_set_grade_spin_value (Gnonogram_view* self, gdouble d);
static void gnonogram_controller_initialize_cursor (Gnonogram_controller* self);
static void gnonogram_controller_update_labels_from_model (Gnonogram_controller* self);
void gnonogram_view_set_size (Gnonogram_view* self, gint r, gint c);
gboolean utils_get_dimensions (gint* r, gint* c, gint currentr, gint currentc);
static void gnonogram_controller_resize (Gnonogram_controller* self, gint r, gint c);
static void gnonogram_controller_resize_view (Gnonogram_controller* self, gint r, gint c);
void gnonogram_solver_set_dimensions (Gnonogram_solver* self, gint r, gint c);
void gnonogram_model_set_dimensions (Gnonogram_model* self, gint r, gint c);
void gnonogram_labelbox_resize (Gnonogram_LabelBox* self, gint new_size, gint other_size);
void gnonogram_cellgrid_resize (Gnonogram_CellGrid* self, gint r, gint c);
GType button_press_get_type (void) G_GNUC_CONST;
void gnonogram_controller_update_cell (Gnonogram_controller* self, Cell* c, gboolean highlight);
static void gnonogram_controller_highlight_labels (Gnonogram_controller* self, Cell* c, gboolean is_highlight);
void gnonogram_cellgrid_draw_cell (Gnonogram_CellGrid* self, Cell* cell, GameState gs, gboolean highlight);
void cell_copy (Cell *self, Cell* b);
gboolean cell_changed (Cell *self, gint r, gint c);
void gnonogram_model_get_cell (Gnonogram_model* self, gint r, gint c, Cell* result);
void gnonogram_labelbox_highlight (Gnonogram_LabelBox* self, gint idx, gboolean is_highlight);
void gnonogram_model_set_data_from_cell (Gnonogram_model* self, Cell* cell);
void gnonogram_labelbox_update_label (Gnonogram_LabelBox* self, gint idx, const gchar* txt);
gchar* gnonogram_model_get_label_text (Gnonogram_model* self, gint idx, gboolean is_column);
void gnonogram_cellgrid_prepare_to_redraw_cells (Gnonogram_CellGrid* self, gboolean show_grid);
void gnonogram_model_clear (Gnonogram_model* self);
void gnonogram_view_set_name (Gnonogram_view* self, const gchar* name);
void gnonogram_view_set_author (Gnonogram_view* self, const gchar* author);
void gnonogram_view_set_date (Gnonogram_view* self, const gchar* date);
void gnonogram_view_set_score_label (Gnonogram_view* self, const gchar* score);
void gnonogram_model_blank_working (Gnonogram_model* self, CellState blank);
gchar* utils_get_filename (GtkFileChooserAction action, const gchar* dialogname, gchar** filternames, int filternames_length1, gchar** filters, int filters_length1, const gchar* start_path);
#define RESOURCE_GAMEFILEEXTENSION ".gno"
static gboolean gnonogram_controller_write_game_file (Gnonogram_controller* self, FILE* f);
void utils_show_info_dialog (const gchar* msg);
gchar* gnonogram_view_get_name (Gnonogram_view* self);
gchar* gnonogram_view_get_author (Gnonogram_view* self);
gchar* gnonogram_view_get_date (Gnonogram_view* self);
gchar* gnonogram_view_get_score (Gnonogram_view* self);
gchar* gnonogram_labelbox_to_string (Gnonogram_LabelBox* self);
void gnonogram_model_use_solution (Gnonogram_model* self);
gchar* gnonogram_model_to_string (Gnonogram_model* self);
void gnonogram_model_use_working (Gnonogram_model* self);
#define RESOURCE_POSITIONFILENAME "currentposition"
static gboolean gnonogram_controller_write_position_file (Gnonogram_controller* self, FILE* f);
void utils_show_warning_dialog (const gchar* msg);
const gchar* game_state_to_string (GameState self);
GType gnonogram_filetype_get_type (void) G_GNUC_CONST;
Gnonogram_filereader* gnonogram_filereader_new (Gnonogram_FileType type);
Gnonogram_filereader* gnonogram_filereader_construct (GType object_type, Gnonogram_FileType type);
gpointer gnonogram_filereader_ref (gpointer instance);
void gnonogram_filereader_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_filereader (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_filereader (GValue* value, gpointer v_object);
void value_take_gnonogram_filereader (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_filereader (const GValue* value);
GType gnonogram_filereader_get_type (void) G_GNUC_CONST;
static gboolean gnonogram_controller_load_common (Gnonogram_controller* self, Gnonogram_filereader* reader);
static gboolean gnonogram_controller_load_position_extra (Gnonogram_controller* self, Gnonogram_filereader* reader);
gboolean gnonogram_model_set_row_data_from_string (Gnonogram_model* self, gint r, const gchar* s);
gboolean gnonogram_filereader_open_datainputstream (Gnonogram_filereader* self);
gboolean gnonogram_filereader_parse_game_file (Gnonogram_filereader* self);
static gint gnonogram_controller_solve_game (Gnonogram_controller* self, gboolean use_startgrid, gboolean use_advanced);
static void gnonogram_controller_set_solution_from_solver (Gnonogram_controller* self);
void gnonogram_controller_unpeek_game (Gnonogram_controller* self);
void gnonogram_model_check_solution (Gnonogram_model* self);
static gboolean _lambda35_ (Gnonogram_controller* self);
static gboolean __lambda35__gsource_func (gpointer self);
static void gnonogram_controller_set_working_from_solver (Gnonogram_controller* self);
gpointer my2_dcell_array_ref (gpointer instance);
void my2_dcell_array_unref (gpointer instance);
GParamSpec* param_spec_my2_dcell_array (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_my2_dcell_array (GValue* value, gpointer v_object);
void value_take_my2_dcell_array (GValue* value, gpointer v_object);
gpointer value_get_my2_dcell_array (const GValue* value);
GType my2_dcell_array_get_type (void) G_GNUC_CONST;
static gint gnonogram_controller_solve_clues (Gnonogram_controller* self, gchar** row_clues, int row_clues_length1, gchar** col_clues, int col_clues_length1, My2DCellArray* startgrid, gboolean use_advanced);
gboolean gnonogram_solver_initialize (Gnonogram_solver* self, gchar** row_clues, int row_clues_length1, gchar** col_clues, int col_clues_length1, My2DCellArray* start_grid);
gint gnonogram_solver_solve_it (Gnonogram_solver* self, gboolean debug, gboolean use_advanced);
My2DCellArray* my2_dcell_array_new (gint rows, gint cols, CellState init);
My2DCellArray* my2_dcell_array_construct (GType object_type, gint rows, gint cols, CellState init);
void my2_dcell_array_set_data_from_cell (My2DCellArray* self, Cell* c);
gchar* gnonogram_labelbox_get_label_text (Gnonogram_LabelBox* self, gint idx);
static void gnonogram_controller_set_model_from_solver (Gnonogram_controller* self);
void gnonogram_solver_get_cell (Gnonogram_solver* self, gint r, gint c, Cell* result);
static gint gnonogram_controller_generate_difficult_game (Gnonogram_controller* self, gint grade);
static gint gnonogram_controller_generate_simple_game (Gnonogram_controller* self, gint grade);
gchar* utils_get_todays_date_string (void);
gchar* gnonogram_solver_get_error (Gnonogram_solver* self);
static gint gnonogram_controller_generate_game (Gnonogram_controller* self, gint grade);
void gnonogram_model_fill_random (Gnonogram_model* self, gint grade);
static void gnonogram_controller_save_config (Gnonogram_controller* self);
void config_set_difficulty (Config* self, gdouble difficulty);
gdouble gnonogram_view_get_grade_spin_value (Gnonogram_view* self);
void config_set_dimensions (Config* self, gint r, gint c);
void config_set_colors (Config* self);
static void gnonogram_controller_set__state (Gnonogram_controller* self, GameState value);
void gnonogram_view_state_has_changed (Gnonogram_view* self, GameState gs);
static void gnonogram_controller_finalize (Gnonogram_controller* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _gnonogram_controller_show_solver_grid_gnonogram_solver_showsolvergrid (Gnonogram_solver* _sender, gpointer self) {
	gnonogram_controller_show_solver_grid (self);
}


Gnonogram_controller* gnonogram_controller_construct (GType object_type, gint r, gint c) {
	Gnonogram_controller* self = NULL;
	gboolean _tmp0_ = FALSE;
	Gnonogram_model* _tmp5_ = NULL;
	Gnonogram_model* _tmp6_;
	Gnonogram_solver* _tmp7_ = NULL;
	Gnonogram_solver* _tmp8_;
	Config* _tmp9_ = NULL;
	Config* _tmp10_;
	gdouble _tmp11_;
	self = (Gnonogram_controller*) g_type_create_instance (object_type);
	if (r < 1) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = c < 1;
	}
	if (_tmp0_) {
		Config* _tmp1_ = NULL;
		Config* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		_tmp1_ = config_get_instance ();
		_tmp2_ = _tmp1_;
		config_get_dimensions (_tmp2_, &_tmp3_, &_tmp4_);
		self->priv->_rows = _tmp3_;
		self->priv->_cols = _tmp4_;
		_config_unref0 (_tmp2_);
	} else {
		self->priv->_rows = r;
		self->priv->_cols = c;
	}
	_tmp5_ = gnonogram_model_new (self->priv->_rows, self->priv->_cols);
	_tmp6_ = _tmp5_;
	_gnonogram_model_unref0 (self->_model);
	self->_model = _tmp6_;
	_tmp7_ = gnonogram_solver_new (self->priv->_rows, self->priv->_cols, FALSE, FALSE, FALSE, -1);
	_tmp8_ = _tmp7_;
	_gnonogram_solver_unref0 (self->_solver);
	self->_solver = _tmp8_;
	g_signal_connect (self->_solver, "showsolvergrid", (GCallback) _gnonogram_controller_show_solver_grid_gnonogram_solver_showsolvergrid, self);
	self->priv->_have_solution = FALSE;
	_tmp9_ = config_get_instance ();
	_tmp10_ = _tmp9_;
	_tmp11_ = config_get_difficulty (_tmp10_);
	self->priv->_grade = (gint) _tmp11_;
	_config_unref0 (_tmp10_);
	gnonogram_controller_create_view (self);
	gnonogram_controller_initialize_view (self);
	gtk_widget_show_all (GTK_WIDGET (self->_gnonogram_view));
	gnonogram_controller_change_state (self, GAME_STATE_SETTING);
	return self;
}


Gnonogram_controller* gnonogram_controller_new (gint r, gint c) {
	return gnonogram_controller_construct (TYPE_GNONOGRAM_CONTROLLER, r, c);
}


static void _gnonogram_controller_viewer_solve_game_gnonogram_view_solvegame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_viewer_solve_game (self);
}


static void _gnonogram_controller_save_game_gnonogram_view_savegame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_save_game (self);
}


static void _gnonogram_controller_load_game_gnonogram_view_loadgame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_load_game (self);
}


static void _gnonogram_controller_save_position_gnonogram_view_saveposition (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_save_position (self);
}


static void _lambda33_ (Gnonogram_controller* self) {
	gnonogram_controller_load_position (self);
	gnonogram_controller_change_state (self, self->priv->__state);
}


static void __lambda33__gnonogram_view_loadposition (Gnonogram_view* _sender, gpointer self) {
	_lambda33_ (self);
}


static void _lambda34_ (Gnonogram_controller* self) {
	gnonogram_controller_quit_game (self);
}


static void __lambda34__gnonogram_view_quitgamesignal (Gnonogram_view* _sender, gpointer self) {
	_lambda34_ (self);
}


static void _gnonogram_controller_new_game_gnonogram_view_newgame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_new_game (self);
}


static void _gnonogram_controller_start_solving_gnonogram_view_hidegame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_start_solving (self);
}


static void _gnonogram_controller_reveal_solution_gnonogram_view_revealgame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_reveal_solution (self);
}


static void _gnonogram_controller_peek_game_gnonogram_view_peekgame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_peek_game (self);
}


static void _gnonogram_controller_restart_game_gnonogram_view_restartgame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_restart_game (self);
}


static void _gnonogram_controller_random_game_gnonogram_view_randomgame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_random_game (self);
}


static void _lambda36_ (Gnonogram_controller* self) {
	resource_set_colors ();
	gnonogram_controller_redraw_all (self);
}


static void __lambda36__gnonogram_view_setcolors (Gnonogram_view* _sender, gpointer self) {
	_lambda36_ (self);
}


static void _lambda37_ (Gnonogram_controller* self) {
	resource_set_font ();
	gnonogram_labelbox_change_font_height (self->_rowbox, FALSE);
	gnonogram_labelbox_change_font_height (self->_colbox, FALSE);
}


static void __lambda37__gnonogram_view_setfont (Gnonogram_view* _sender, gpointer self) {
	_lambda37_ (self);
}


static void _gnonogram_controller_change_size_gnonogram_view_resizegame (Gnonogram_view* _sender, gpointer self) {
	gnonogram_controller_change_size (self);
}


static gboolean _gnonogram_controller_key_pressed_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = gnonogram_controller_key_pressed (self, event);
	return result;
}


static gboolean _gnonogram_controller_key_released_gtk_widget_key_release_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = gnonogram_controller_key_released (self, event);
	return result;
}


static void _gnonogram_controller_set_difficulty_gnonogram_view_setdifficulty (Gnonogram_view* _sender, gdouble grade, gpointer self) {
	gnonogram_controller_set_difficulty (self, grade);
}


static void _gnonogram_controller_gridlines_toggled_gnonogram_view_togglegrid (Gnonogram_view* _sender, gboolean active, gpointer self) {
	gnonogram_controller_gridlines_toggled (self, active);
}


static void _gnonogram_controller_change_font_size_gnonogram_view_changefont (Gnonogram_view* _sender, gboolean increase, gpointer self) {
	gnonogram_controller_change_font_size (self, increase);
}


static void _lambda38_ (gboolean debug, Gnonogram_controller* self) {
	self->priv->_debug = debug;
}


static void __lambda38__gnonogram_view_debugmode (Gnonogram_view* _sender, gboolean debug, gpointer self) {
	_lambda38_ (debug, self);
}


static void _lambda39_ (gboolean advanced, Gnonogram_controller* self) {
	self->priv->_advanced = advanced;
}


static void __lambda39__gnonogram_view_advancedmode (Gnonogram_view* _sender, gboolean advanced, gpointer self) {
	_lambda39_ (advanced, self);
}


static void _lambda40_ (gboolean difficult, Gnonogram_controller* self) {
	self->priv->_difficult = difficult;
}


static void __lambda40__gnonogram_view_difficultmode (Gnonogram_view* _sender, gboolean difficult, gpointer self) {
	_lambda40_ (difficult, self);
}


static void _gnonogram_controller_grid_cursor_moved_gnonogram_cellgrid_cursor_moved (Gnonogram_CellGrid* _sender, gint r, gint c, gpointer self) {
	gnonogram_controller_grid_cursor_moved (self, r, c);
}


static gboolean _gnonogram_controller_button_pressed_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = gnonogram_controller_button_pressed (self, event);
	return result;
}


static gboolean _lambda41_ (Gnonogram_controller* self) {
	gboolean result = FALSE;
	self->priv->_is_button_down = FALSE;
	result = TRUE;
	return result;
}


static gboolean __lambda41__gtk_widget_button_release_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = _lambda41_ (self);
	return result;
}


static gboolean _lambda42_ (Gnonogram_controller* self) {
	gboolean result = FALSE;
	gnonogram_controller_redraw_all (self);
	result = FALSE;
	return result;
}


static gboolean __lambda42__gtk_widget_expose_event (GtkWidget* _sender, GdkEventExpose* event, gpointer self) {
	gboolean result;
	result = _lambda42_ (self);
	return result;
}


static void gnonogram_controller_create_view (Gnonogram_controller* self) {
	Gnonogram_LabelBox* _tmp0_ = NULL;
	Gnonogram_LabelBox* _tmp1_;
	Gnonogram_LabelBox* _tmp2_ = NULL;
	Gnonogram_LabelBox* _tmp3_;
	Gnonogram_CellGrid* _tmp4_ = NULL;
	Gnonogram_CellGrid* _tmp5_;
	Gnonogram_view* _tmp6_ = NULL;
	Gnonogram_view* _tmp7_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp0_ = gnonogram_labelbox_new (self->priv->_rows, self->priv->_cols, FALSE);
	_tmp1_ = g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->_rowbox);
	self->_rowbox = _tmp1_;
	_tmp2_ = gnonogram_labelbox_new (self->priv->_cols, self->priv->_rows, TRUE);
	_tmp3_ = g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->_colbox);
	self->_colbox = _tmp3_;
	_tmp4_ = gnonogram_cellgrid_new (self->priv->_rows, self->priv->_cols);
	_tmp5_ = g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->_cellgrid);
	self->_cellgrid = _tmp5_;
	self->priv->_gridlinesvisible = FALSE;
	_tmp6_ = gnonogram_view_new (self->_rowbox, self->_colbox, self->_cellgrid, self);
	_tmp7_ = g_object_ref_sink (_tmp6_);
	_g_object_unref0 (self->_gnonogram_view);
	self->_gnonogram_view = _tmp7_;
	g_signal_connect (self->_gnonogram_view, "solvegame", (GCallback) _gnonogram_controller_viewer_solve_game_gnonogram_view_solvegame, self);
	g_signal_connect (self->_gnonogram_view, "savegame", (GCallback) _gnonogram_controller_save_game_gnonogram_view_savegame, self);
	g_signal_connect (self->_gnonogram_view, "loadgame", (GCallback) _gnonogram_controller_load_game_gnonogram_view_loadgame, self);
	g_signal_connect (self->_gnonogram_view, "saveposition", (GCallback) _gnonogram_controller_save_position_gnonogram_view_saveposition, self);
	g_signal_connect (self->_gnonogram_view, "loadposition", (GCallback) __lambda33__gnonogram_view_loadposition, self);
	g_signal_connect (self->_gnonogram_view, "quitgamesignal", (GCallback) __lambda34__gnonogram_view_quitgamesignal, self);
	g_signal_connect (self->_gnonogram_view, "newgame", (GCallback) _gnonogram_controller_new_game_gnonogram_view_newgame, self);
	g_signal_connect (self->_gnonogram_view, "hidegame", (GCallback) _gnonogram_controller_start_solving_gnonogram_view_hidegame, self);
	g_signal_connect (self->_gnonogram_view, "revealgame", (GCallback) _gnonogram_controller_reveal_solution_gnonogram_view_revealgame, self);
	g_signal_connect (self->_gnonogram_view, "peekgame", (GCallback) _gnonogram_controller_peek_game_gnonogram_view_peekgame, self);
	g_signal_connect (self->_gnonogram_view, "restartgame", (GCallback) _gnonogram_controller_restart_game_gnonogram_view_restartgame, self);
	g_signal_connect (self->_gnonogram_view, "randomgame", (GCallback) _gnonogram_controller_random_game_gnonogram_view_randomgame, self);
	g_signal_connect (self->_gnonogram_view, "setcolors", (GCallback) __lambda36__gnonogram_view_setcolors, self);
	g_signal_connect (self->_gnonogram_view, "setfont", (GCallback) __lambda37__gnonogram_view_setfont, self);
	g_signal_connect (self->_gnonogram_view, "resizegame", (GCallback) _gnonogram_controller_change_size_gnonogram_view_resizegame, self);
	g_signal_connect (GTK_WIDGET (self->_gnonogram_view), "key-press-event", (GCallback) _gnonogram_controller_key_pressed_gtk_widget_key_press_event, self);
	g_signal_connect (GTK_WIDGET (self->_gnonogram_view), "key-release-event", (GCallback) _gnonogram_controller_key_released_gtk_widget_key_release_event, self);
	g_signal_connect (self->_gnonogram_view, "setdifficulty", (GCallback) _gnonogram_controller_set_difficulty_gnonogram_view_setdifficulty, self);
	g_signal_connect (self->_gnonogram_view, "togglegrid", (GCallback) _gnonogram_controller_gridlines_toggled_gnonogram_view_togglegrid, self);
	g_signal_connect (self->_gnonogram_view, "changefont", (GCallback) _gnonogram_controller_change_font_size_gnonogram_view_changefont, self);
	g_signal_connect (self->_gnonogram_view, "debugmode", (GCallback) __lambda38__gnonogram_view_debugmode, self);
	g_signal_connect (self->_gnonogram_view, "advancedmode", (GCallback) __lambda39__gnonogram_view_advancedmode, self);
	g_signal_connect (self->_gnonogram_view, "difficultmode", (GCallback) __lambda40__gnonogram_view_difficultmode, self);
	g_signal_connect (self->_cellgrid, "cursor-moved", (GCallback) _gnonogram_controller_grid_cursor_moved_gnonogram_cellgrid_cursor_moved, self);
	g_signal_connect (GTK_WIDGET (self->_cellgrid), "button-press-event", (GCallback) _gnonogram_controller_button_pressed_gtk_widget_button_press_event, self);
	g_signal_connect (GTK_WIDGET (self->_cellgrid), "button-release-event", (GCallback) __lambda41__gtk_widget_button_release_event, self);
	g_signal_connect (GTK_WIDGET (self->_cellgrid), "expose-event", (GCallback) __lambda42__gtk_widget_expose_event, self);
	gnonogram_view_set_grade_spin_value (self->_gnonogram_view, (gdouble) self->priv->_grade);
}


static void gnonogram_controller_initialize_view (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_initialize_cursor (self);
	if (self->priv->_have_solution) {
		gnonogram_controller_update_labels_from_model (self);
	}
	gnonogram_view_set_size (self->_gnonogram_view, self->priv->_rows, self->priv->_cols);
}


static void gnonogram_controller_initialize_cursor (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	self->priv->_current_cell.row = -1;
	self->priv->_current_cell.col = -1;
	self->priv->_current_cell.state = CELL_STATE_UNKNOWN;
	self->priv->_previous_cell.row = -1;
	self->priv->_previous_cell.col = -1;
	self->priv->_previous_cell.state = CELL_STATE_UNKNOWN;
	self->priv->_is_button_down = FALSE;
}


static void gnonogram_controller_change_size (Gnonogram_controller* self) {
	gint r = 0;
	gint c = 0;
	gint _tmp0_;
	gint _tmp1_;
	gboolean _tmp2_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp2_ = utils_get_dimensions (&_tmp0_, &_tmp1_, self->priv->_rows, self->priv->_cols);
	r = _tmp0_;
	c = _tmp1_;
	if (_tmp2_) {
		gnonogram_controller_new_game (self);
		gnonogram_controller_resize (self, r, c);
		gnonogram_controller_change_state (self, GAME_STATE_SETTING);
		gnonogram_controller_initialize_view (self);
		gtk_widget_show_all (GTK_WIDGET (self->_gnonogram_view));
	}
}


static void gnonogram_controller_resize (Gnonogram_controller* self, gint r, gint c) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	if (r > resource_MAXROWSIZE) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = c > resource_MAXCOLSIZE;
	}
	if (_tmp0_) {
		return;
	}
	if (r == self->priv->_rows) {
		_tmp1_ = c == self->priv->_cols;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		return;
	}
	gnonogram_controller_resize_view (self, r, c);
	gnonogram_solver_set_dimensions (self->_solver, r, c);
	gnonogram_model_set_dimensions (self->_model, r, c);
	self->priv->_rows = r;
	self->priv->_cols = c;
}


static void gnonogram_controller_resize_view (Gnonogram_controller* self, gint r, gint c) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_labelbox_resize (self->_rowbox, r, c);
	gnonogram_labelbox_resize (self->_colbox, c, r);
	gnonogram_cellgrid_resize (self->_cellgrid, r, c);
}


static void gnonogram_controller_gridlines_toggled (Gnonogram_controller* self, gboolean active) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	if (self->priv->_gridlinesvisible != active) {
		self->priv->_gridlinesvisible = active;
		gnonogram_controller_redraw_all (self);
	}
}


static gboolean gnonogram_controller_button_pressed (Gnonogram_controller* self, GdkEventButton* e) {
	gboolean result = FALSE;
	ButtonPress b;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	b = BUTTON_PRESS_UNDEFINED;
	if ((*e).type != GDK_2BUTTON_PRESS) {
		switch ((*e).button) {
			case 1:
			{
				b = BUTTON_PRESS_LEFT_SINGLE;
				break;
			}
			case 3:
			{
				b = BUTTON_PRESS_RIGHT_SINGLE;
				break;
			}
			default:
			{
				break;
			}
		}
	} else {
		b = BUTTON_PRESS_LEFT_DOUBLE;
	}
	if (b != BUTTON_PRESS_UNDEFINED) {
		switch (b) {
			case BUTTON_PRESS_LEFT_SINGLE:
			{
				self->priv->_current_cell.state = CELL_STATE_FILLED;
				break;
			}
			case BUTTON_PRESS_RIGHT_SINGLE:
			{
				self->priv->_current_cell.state = CELL_STATE_EMPTY;
				break;
			}
			default:
			{
				if (self->priv->__state == GAME_STATE_SOLVING) {
					self->priv->_current_cell.state = CELL_STATE_UNKNOWN;
				}
				break;
			}
		}
		self->priv->_is_button_down = TRUE;
		gnonogram_controller_update_cell (self, &self->priv->_current_cell, TRUE);
	}
	result = TRUE;
	return result;
}


static gboolean gnonogram_controller_key_pressed (Gnonogram_controller* self, GdkEventKey* e) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* name;
	gint currentrow;
	gint currentcol;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	GQuark _tmp6_;
	static GQuark _tmp6__label0 = 0;
	static GQuark _tmp6__label1 = 0;
	static GQuark _tmp6__label2 = 0;
	static GQuark _tmp6__label3 = 0;
	static GQuark _tmp6__label4 = 0;
	static GQuark _tmp6__label5 = 0;
	static GQuark _tmp6__label6 = 0;
	static GQuark _tmp6__label7 = 0;
	static GQuark _tmp6__label8 = 0;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	_tmp0_ = gdk_keyval_name ((*e).keyval);
	_tmp1_ = g_utf8_strup (_tmp0_, (gssize) (-1));
	name = _tmp1_;
	currentrow = self->priv->_current_cell.row;
	currentcol = self->priv->_current_cell.col;
	if (currentrow < 0) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = currentcol < 0;
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = currentrow > (self->priv->_rows - 1);
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = currentcol > (self->priv->_cols - 1);
	}
	if (_tmp2_) {
		result = FALSE;
		_g_free0 (name);
		return result;
	}
	_tmp5_ = name;
	_tmp6_ = (NULL == _tmp5_) ? 0 : g_quark_from_string (_tmp5_);
	if (_tmp6_ == ((0 != _tmp6__label0) ? _tmp6__label0 : (_tmp6__label0 = g_quark_from_static_string ("UP")))) {
		switch (0) {
			default:
			{
				if (currentrow > 0) {
					currentrow = currentrow - 1;
				}
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label1) ? _tmp6__label1 : (_tmp6__label1 = g_quark_from_static_string ("DOWN")))) {
		switch (0) {
			default:
			{
				if (currentrow < (self->priv->_rows - 1)) {
					currentrow = currentrow + 1;
				}
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label2) ? _tmp6__label2 : (_tmp6__label2 = g_quark_from_static_string ("LEFT")))) {
		switch (0) {
			default:
			{
				if (currentcol > 0) {
					currentcol = currentcol - 1;
				}
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label3) ? _tmp6__label3 : (_tmp6__label3 = g_quark_from_static_string ("RIGHT")))) {
		switch (0) {
			default:
			{
				if (currentcol < (self->priv->_cols - 1)) {
					currentcol = currentcol + 1;
				}
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label4) ? _tmp6__label4 : (_tmp6__label4 = g_quark_from_static_string ("CONTROL_L")))) {
		switch (0) {
			default:
			{
				self->priv->_current_cell.state = CELL_STATE_FILLED;
				gnonogram_controller_update_cell (self, &self->priv->_current_cell, TRUE);
				self->priv->_is_button_down = TRUE;
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label5) ? _tmp6__label5 : (_tmp6__label5 = g_quark_from_static_string ("SHIFT_L")))) {
		switch (0) {
			default:
			{
				self->priv->_current_cell.state = CELL_STATE_EMPTY;
				gnonogram_controller_update_cell (self, &self->priv->_current_cell, TRUE);
				self->priv->_is_button_down = TRUE;
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label6) ? _tmp6__label6 : (_tmp6__label6 = g_quark_from_static_string ("ALT_L")))) {
		switch (0) {
			default:
			{
				if (self->priv->__state == GAME_STATE_SOLVING) {
					self->priv->_current_cell.state = CELL_STATE_UNKNOWN;
					gnonogram_controller_update_cell (self, &self->priv->_current_cell, TRUE);
					self->priv->_is_button_down = TRUE;
				}
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label7) ? _tmp6__label7 : (_tmp6__label7 = g_quark_from_static_string ("EQUAL")))) {
		switch (0) {
			default:
			{
				gnonogram_controller_change_font_size (self, TRUE);
				break;
			}
		}
	} else if (_tmp6_ == ((0 != _tmp6__label8) ? _tmp6__label8 : (_tmp6__label8 = g_quark_from_static_string ("MINUS")))) {
		switch (0) {
			default:
			{
				gnonogram_controller_change_font_size (self, FALSE);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				break;
			}
		}
	}
	gnonogram_controller_grid_cursor_moved (self, currentrow, currentcol);
	result = TRUE;
	_g_free0 (name);
	return result;
}


static gboolean gnonogram_controller_key_released (Gnonogram_controller* self, GdkEventKey* e) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* name;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	_tmp0_ = gdk_keyval_name ((*e).keyval);
	_tmp1_ = g_utf8_strup (_tmp0_, (gssize) (-1));
	name = _tmp1_;
	if (g_strcmp0 (name, "CONTROL_L") == 0) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = g_strcmp0 (name, "ALT_L") == 0;
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = g_strcmp0 (name, "SHIFT_L") == 0;
	}
	if (_tmp2_) {
		self->priv->_is_button_down = FALSE;
	}
	result = TRUE;
	_g_free0 (name);
	return result;
}


static void gnonogram_controller_change_font_size (Gnonogram_controller* self, gboolean increase) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_labelbox_change_font_height (self->_rowbox, increase);
	gnonogram_labelbox_change_font_height (self->_colbox, increase);
	if (!increase) {
		gtk_window_resize (GTK_WINDOW (self->_gnonogram_view), 100, 150);
	}
}


void gnonogram_controller_grid_cursor_moved (Gnonogram_controller* self, gint r, gint c) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	if (r < 0) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = r >= self->priv->_rows;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = c < 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = c >= self->priv->_cols;
	}
	if (_tmp0_) {
		gnonogram_controller_highlight_labels (self, &self->priv->_previous_cell, FALSE);
		gnonogram_cellgrid_draw_cell (self->_cellgrid, &self->priv->_previous_cell, self->priv->__state, FALSE);
		return;
	}
	cell_copy (&self->priv->_previous_cell, &self->priv->_current_cell);
	_tmp3_ = cell_changed (&self->priv->_current_cell, r, c);
	if (!_tmp3_) {
		return;
	}
	gnonogram_controller_highlight_labels (self, &self->priv->_previous_cell, FALSE);
	gnonogram_cellgrid_draw_cell (self->_cellgrid, &self->priv->_previous_cell, self->priv->__state, FALSE);
	if (self->priv->_is_button_down) {
		gnonogram_controller_update_cell (self, &self->priv->_current_cell, TRUE);
	} else {
		Cell _tmp4_ = {0};
		Cell _tmp5_ = {0};
		_tmp5_ = (gnonogram_model_get_cell (self->_model, r, c, &_tmp4_), _tmp4_);
		self->priv->_current_cell = _tmp5_;
		gnonogram_cellgrid_draw_cell (self->_cellgrid, &self->priv->_current_cell, self->priv->__state, TRUE);
	}
	gnonogram_controller_highlight_labels (self, &self->priv->_current_cell, TRUE);
	cell_copy (&self->priv->_previous_cell, &self->priv->_current_cell);
}


static void gnonogram_controller_highlight_labels (Gnonogram_controller* self, Cell* c, gboolean is_highlight) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_labelbox_highlight (self->_rowbox, (*c).row, is_highlight);
	gnonogram_labelbox_highlight (self->_colbox, (*c).col, is_highlight);
}


void gnonogram_controller_update_cell (Gnonogram_controller* self, Cell* c, gboolean highlight) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_model_set_data_from_cell (self->_model, c);
	gnonogram_cellgrid_draw_cell (self->_cellgrid, c, self->priv->__state, highlight);
	if (self->priv->__state == GAME_STATE_SETTING) {
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		_tmp0_ = gnonogram_model_get_label_text (self->_model, (*c).row, FALSE);
		_tmp1_ = _tmp0_;
		gnonogram_labelbox_update_label (self->_rowbox, (*c).row, _tmp1_);
		_g_free0 (_tmp1_);
		_tmp2_ = gnonogram_model_get_label_text (self->_model, (*c).col, TRUE);
		_tmp3_ = _tmp2_;
		gnonogram_labelbox_update_label (self->_colbox, (*c).col, _tmp3_);
		_g_free0 (_tmp3_);
	}
}


static void gnonogram_controller_redraw_all (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_cellgrid_prepare_to_redraw_cells (self->_cellgrid, self->priv->_gridlinesvisible);
	{
		gint r;
		r = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					r++;
				}
				_tmp0_ = FALSE;
				if (!(r < self->priv->_rows)) {
					break;
				}
				{
					gint c;
					c = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							Cell _tmp2_ = {0};
							Cell _tmp3_ = {0};
							if (!_tmp1_) {
								c++;
							}
							_tmp1_ = FALSE;
							if (!(c < self->priv->_cols)) {
								break;
							}
							_tmp3_ = (gnonogram_model_get_cell (self->_model, r, c, &_tmp2_), _tmp2_);
							gnonogram_cellgrid_draw_cell (self->_cellgrid, &_tmp3_, self->priv->__state, FALSE);
						}
					}
				}
			}
		}
	}
}


void gnonogram_controller_new_game (Gnonogram_controller* self) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_model_clear (self->_model);
	self->priv->_have_solution = FALSE;
	gnonogram_controller_change_state (self, GAME_STATE_SETTING);
	gnonogram_controller_update_labels_from_model (self);
	_tmp0_ = _ ("New game");
	gnonogram_view_set_name (self->_gnonogram_view, _tmp0_);
	gnonogram_view_set_author (self->_gnonogram_view, " ");
	gnonogram_view_set_date (self->_gnonogram_view, " ");
	gnonogram_view_set_score_label (self->_gnonogram_view, "  ");
	gnonogram_controller_initialize_view (self);
}


void gnonogram_controller_restart_game (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_model_blank_working (self->_model, CELL_STATE_UNKNOWN);
	gnonogram_controller_initialize_view (self);
	gnonogram_controller_redraw_all (self);
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	gint _tmp0_;
	glong string_length;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	string_length = (glong) _tmp0_;
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp1_ = start <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	if (end >= 0) {
		_tmp2_ = end <= string_length;
	} else {
		_tmp2_ = FALSE;
	}
	g_return_val_if_fail (_tmp2_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + start, (gsize) (end - start));
	result = _tmp3_;
	return result;
}


void gnonogram_controller_save_game (Gnonogram_controller* self) {
	gchar* filename = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gchar* _tmp5_;
	gchar** _tmp6_ = NULL;
	gchar** _tmp7_;
	gint _tmp7__length1;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gboolean _tmp10_ = FALSE;
	gint _tmp12_;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_;
	gboolean _tmp15_;
	FILE* _tmp17_ = NULL;
	FILE* f;
	gboolean _tmp18_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp0_ = _ ("Name and save this game");
	_tmp1_ = _ ("Gnonogram games");
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = 1;
	_tmp5_ = g_strdup ("*" RESOURCE_GAMEFILEEXTENSION);
	_tmp6_ = g_new0 (gchar*, 1 + 1);
	_tmp6_[0] = _tmp5_;
	_tmp7_ = _tmp6_;
	_tmp7__length1 = 1;
	_tmp8_ = utils_get_filename (GTK_FILE_CHOOSER_ACTION_SAVE, _tmp0_, _tmp4_, 1, _tmp7_, 1, resource_game_dir);
	_tmp9_ = _tmp8_;
	_g_free0 (filename);
	filename = _tmp9_;
	_tmp7_ = (_vala_array_free (_tmp7_, _tmp7__length1, (GDestroyNotify) g_free), NULL);
	_tmp4_ = (_vala_array_free (_tmp4_, _tmp4__length1, (GDestroyNotify) g_free), NULL);
	if (filename == NULL) {
		_tmp10_ = TRUE;
	} else {
		gint _tmp11_;
		_tmp11_ = strlen (filename);
		_tmp10_ = _tmp11_ < 5;
	}
	if (_tmp10_) {
		_g_free0 (filename);
		return;
	}
	_tmp12_ = strlen (filename);
	_tmp13_ = string_slice (filename, (glong) (-4), (glong) _tmp12_);
	_tmp14_ = _tmp13_;
	if ((_tmp15_ = g_strcmp0 (_tmp14_, RESOURCE_GAMEFILEEXTENSION) != 0, _g_free0 (_tmp14_), _tmp15_)) {
		gchar* _tmp16_;
		_tmp16_ = g_strconcat (filename, RESOURCE_GAMEFILEEXTENSION, NULL);
		_g_free0 (filename);
		filename = _tmp16_;
	}
	_tmp17_ = fopen (filename, "w");
	f = _tmp17_;
	_tmp18_ = gnonogram_controller_write_game_file (self, f);
	if (_tmp18_) {
		const gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		gchar* _tmp22_;
		_tmp19_ = _ ("Saved as ");
		_tmp20_ = g_path_get_basename (filename);
		_tmp21_ = _tmp20_;
		_tmp22_ = g_strconcat (_tmp19_, _tmp21_, NULL);
		utils_show_info_dialog (_tmp22_);
		_g_free0 (_tmp22_);
		_g_free0 (_tmp21_);
	}
	_fclose0 (f);
	_g_free0 (filename);
}


static gboolean gnonogram_controller_write_game_file (Gnonogram_controller* self, FILE* f) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	g_return_val_if_fail (f != NULL, FALSE);
	fprintf (f, "[Description]\n");
	_tmp0_ = gnonogram_view_get_name (self->_gnonogram_view);
	_tmp1_ = _tmp0_;
	fprintf (f, "%s\n", _tmp1_);
	_g_free0 (_tmp1_);
	_tmp2_ = gnonogram_view_get_author (self->_gnonogram_view);
	_tmp3_ = _tmp2_;
	fprintf (f, "%s\n", _tmp3_);
	_g_free0 (_tmp3_);
	_tmp4_ = gnonogram_view_get_date (self->_gnonogram_view);
	_tmp5_ = _tmp4_;
	fprintf (f, "%s\n", _tmp5_);
	_g_free0 (_tmp5_);
	_tmp6_ = gnonogram_view_get_score (self->_gnonogram_view);
	_tmp7_ = _tmp6_;
	fprintf (f, "%s\n", _tmp7_);
	_g_free0 (_tmp7_);
	fprintf (f, "[Dimensions]\n");
	fprintf (f, "%d\n", self->priv->_rows);
	fprintf (f, "%d\n", self->priv->_cols);
	fprintf (f, "[Row clues]\n");
	_tmp8_ = gnonogram_labelbox_to_string (self->_rowbox);
	_tmp9_ = _tmp8_;
	fprintf (f, "%s", _tmp9_);
	_g_free0 (_tmp9_);
	fprintf (f, "[Column clues]\n");
	_tmp10_ = gnonogram_labelbox_to_string (self->_colbox);
	_tmp11_ = _tmp10_;
	fprintf (f, "%s", _tmp11_);
	_g_free0 (_tmp11_);
	gnonogram_model_use_solution (self->_model);
	fprintf (f, "[Solution]\n");
	_tmp12_ = gnonogram_model_to_string (self->_model);
	_tmp13_ = _tmp12_;
	fprintf (f, "%s", _tmp13_);
	_g_free0 (_tmp13_);
	if (self->priv->__state == GAME_STATE_SOLVING) {
		gnonogram_model_use_working (self->_model);
	}
	fflush (f);
	result = TRUE;
	return result;
}


static void gnonogram_controller_save_position (Gnonogram_controller* self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* filename;
	FILE* _tmp2_ = NULL;
	FILE* f;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp0_ = g_strconcat (resource_game_dir, "/", NULL);
	filename = (_tmp1_ = g_strconcat (_tmp0_, RESOURCE_POSITIONFILENAME, NULL), _g_free0 (_tmp0_), _tmp1_);
	_tmp2_ = fopen (filename, "w");
	f = _tmp2_;
	if (f == NULL) {
		_tmp3_ = TRUE;
	} else {
		gboolean _tmp4_;
		_tmp4_ = gnonogram_controller_write_position_file (self, f);
		_tmp3_ = !_tmp4_;
	}
	if (_tmp3_) {
		const gchar* _tmp5_ = NULL;
		_tmp5_ = _ ("An error occured creating the position file");
		utils_show_warning_dialog (_tmp5_);
		_fclose0 (f);
		_g_free0 (filename);
		return;
	}
	_fclose0 (f);
	_g_free0 (filename);
}


static gboolean gnonogram_controller_write_position_file (Gnonogram_controller* self, FILE* f) {
	gboolean result = FALSE;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GEnumValue* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	g_return_val_if_fail (f != NULL, FALSE);
	gnonogram_controller_write_game_file (self, f);
	gnonogram_model_use_working (self->_model);
	fprintf (f, "[Working grid]\n");
	_tmp0_ = gnonogram_model_to_string (self->_model);
	_tmp1_ = _tmp0_;
	fprintf (f, "%s", _tmp1_);
	_g_free0 (_tmp1_);
	fprintf (f, "[State]\n");
	_tmp3_ = g_strconcat ((_tmp2_ = g_enum_get_value (g_type_class_ref (TYPE_GAME_STATE), self->priv->__state), (_tmp2_ != NULL) ? _tmp2_->value_name : NULL), "\n", NULL);
	fprintf (f, "%s", _tmp3_);
	_g_free0 (_tmp3_);
	fflush (f);
	result = TRUE;
	return result;
}


void gnonogram_controller_load_game (Gnonogram_controller* self) {
	Gnonogram_filereader* _tmp0_ = NULL;
	Gnonogram_filereader* reader;
	gboolean _tmp1_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp0_ = gnonogram_filereader_new (GNONOGRAM_FILETYPE_GAME);
	reader = _tmp0_;
	if (g_strcmp0 (reader->filename, "") == 0) {
		_gnonogram_filereader_unref0 (reader);
		return;
	}
	gnonogram_controller_new_game (self);
	_tmp1_ = gnonogram_controller_load_common (self, reader);
	if (_tmp1_) {
		gnonogram_controller_initialize_view (self);
		gnonogram_controller_start_solving (self);
	}
	_gnonogram_filereader_unref0 (reader);
}


void gnonogram_controller_load_position (Gnonogram_controller* self) {
	Gnonogram_filereader* _tmp0_ = NULL;
	Gnonogram_filereader* reader;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_new_game (self);
	_tmp0_ = gnonogram_filereader_new (GNONOGRAM_FILETYPE_POSITION);
	reader = _tmp0_;
	_tmp2_ = gnonogram_controller_load_common (self, reader);
	if (_tmp2_) {
		gboolean _tmp3_;
		_tmp3_ = gnonogram_controller_load_position_extra (self, reader);
		_tmp1_ = _tmp3_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
	} else {
		const gchar* _tmp4_ = NULL;
		_tmp4_ = _ ("Failed to load saved position");
		utils_show_warning_dialog (_tmp4_);
	}
	_gnonogram_filereader_unref0 (reader);
}


static gboolean gnonogram_controller_load_position_extra (Gnonogram_controller* self, Gnonogram_filereader* reader) {
	gboolean result = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (reader), FALSE);
	if (reader->has_working) {
		gnonogram_model_use_working (self->_model);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					if (!_tmp0_) {
						i++;
					}
					_tmp0_ = FALSE;
					if (!(i < self->priv->_rows)) {
						break;
					}
					gnonogram_model_set_row_data_from_string (self->_model, i, reader->working[i]);
				}
			}
		}
	} else {
		utils_show_warning_dialog ("Working missing");
		result = FALSE;
		return result;
	}
	if (reader->has_state) {
		GEnumValue* _tmp1_;
		if (g_strcmp0 (reader->state, (_tmp1_ = g_enum_get_value (g_type_class_ref (TYPE_GAME_STATE), GAME_STATE_SETTING), (_tmp1_ != NULL) ? _tmp1_->value_name : NULL)) == 0) {
			gnonogram_controller_change_state (self, GAME_STATE_SETTING);
			gnonogram_controller_redraw_all (self);
		} else {
			gnonogram_controller_change_state (self, GAME_STATE_SOLVING);
		}
	} else {
		utils_show_warning_dialog ("State missing");
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gboolean gnonogram_controller_load_common (Gnonogram_controller* self, Gnonogram_filereader* reader) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	gboolean _tmp1_;
	gint _tmp8_;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), FALSE);
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (reader), FALSE);
	self->priv->_have_solution = FALSE;
	_tmp0_ = gnonogram_filereader_open_datainputstream (reader);
	if (!_tmp0_) {
		utils_show_warning_dialog ("Could not open game file");
		result = FALSE;
		return result;
	}
	_tmp1_ = gnonogram_filereader_parse_game_file (reader);
	if (!_tmp1_) {
		utils_show_warning_dialog ("Game file format incorrect");
		result = FALSE;
		return result;
	}
	if (reader->has_dimensions) {
		gint rows;
		gint cols;
		gboolean _tmp2_ = FALSE;
		rows = reader->rows;
		cols = reader->cols;
		if (rows > resource_MAXROWSIZE) {
			_tmp2_ = TRUE;
		} else {
			_tmp2_ = cols > resource_MAXCOLSIZE;
		}
		if (_tmp2_) {
			utils_show_warning_dialog ("Dimensions too large");
			result = FALSE;
			return result;
		} else {
			gnonogram_controller_resize (self, rows, cols);
		}
		gnonogram_view_set_size (self->_gnonogram_view, self->priv->_rows, self->priv->_cols);
	} else {
		utils_show_warning_dialog ("Dimensions missing");
		result = FALSE;
		return result;
	}
	if (reader->has_solution) {
		gnonogram_model_use_solution (self->_model);
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < self->priv->_rows)) {
						break;
					}
					gnonogram_model_set_row_data_from_string (self->_model, i, reader->solution[i]);
				}
			}
		}
		gnonogram_controller_update_labels_from_model (self);
		self->priv->_have_solution = TRUE;
	} else {
		gboolean _tmp4_ = FALSE;
		if (reader->has_row_clues) {
			_tmp4_ = reader->has_col_clues;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			gint _tmp7_;
			gint passes;
			fprintf (stdout, "loading clues\n");
			{
				gint i;
				i = 0;
				{
					gboolean _tmp5_;
					_tmp5_ = TRUE;
					while (TRUE) {
						if (!_tmp5_) {
							i++;
						}
						_tmp5_ = FALSE;
						if (!(i < self->priv->_rows)) {
							break;
						}
						gnonogram_labelbox_update_label (self->_rowbox, i, reader->row_clues[i]);
					}
				}
			}
			{
				gint i;
				i = 0;
				{
					gboolean _tmp6_;
					_tmp6_ = TRUE;
					while (TRUE) {
						if (!_tmp6_) {
							i++;
						}
						_tmp6_ = FALSE;
						if (!(i < self->priv->_cols)) {
							break;
						}
						gnonogram_labelbox_update_label (self->_colbox, i, reader->col_clues[i]);
					}
				}
			}
			_tmp7_ = gnonogram_controller_solve_game (self, FALSE, TRUE);
			passes = _tmp7_;
			fprintf (stdout, "Solver returned %d\n", passes);
			if (passes > 0) {
				self->priv->_have_solution = TRUE;
				gnonogram_controller_set_solution_from_solver (self);
			} else {
				if (passes < 0) {
					utils_show_warning_dialog ("Clues contradictory");
					result = FALSE;
					return result;
				} else {
					utils_show_info_dialog ("Game not soluble by computer");
				}
			}
		} else {
			utils_show_warning_dialog ("Clues and solution both missing");
			result = FALSE;
			return result;
		}
	}
	_tmp8_ = strlen (reader->name);
	if (_tmp8_ > 1) {
		gnonogram_view_set_name (self->_gnonogram_view, reader->name);
	} else {
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		_tmp9_ = g_path_get_basename (reader->filename);
		_tmp10_ = _tmp9_;
		gnonogram_view_set_name (self->_gnonogram_view, _tmp10_);
		_g_free0 (_tmp10_);
	}
	gnonogram_view_set_author (self->_gnonogram_view, reader->author);
	gnonogram_view_set_date (self->_gnonogram_view, reader->date);
	gnonogram_view_set_score_label (self->_gnonogram_view, reader->score);
	result = TRUE;
	return result;
}


void gnonogram_controller_start_solving (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_change_state (self, GAME_STATE_SOLVING);
}


void gnonogram_controller_reveal_solution (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_change_state (self, GAME_STATE_SETTING);
}


void gnonogram_controller_unpeek_game (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_model_check_solution (self->_model);
	gnonogram_controller_change_state (self, GAME_STATE_SOLVING);
}


static gboolean _lambda35_ (Gnonogram_controller* self) {
	gboolean result = FALSE;
	gnonogram_controller_unpeek_game (self);
	result = FALSE;
	return result;
}


static gboolean __lambda35__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda35_ (self);
	return result;
}


void gnonogram_controller_peek_game (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	if (self->priv->_have_solution) {
		GSource* _tmp0_ = NULL;
		GSource* timer;
		gnonogram_controller_change_state (self, GAME_STATE_SETTING);
		_tmp0_ = g_timeout_source_new_seconds ((guint) 1);
		timer = _tmp0_;
		g_source_set_callback (timer, __lambda35__gsource_func, gnonogram_controller_ref (self), gnonogram_controller_unref);
		g_source_attach (timer, NULL);
		_g_source_unref0 (timer);
	} else {
		const gchar* _tmp1_ = NULL;
		_tmp1_ = _ ("No solution available");
		utils_show_info_dialog (_tmp1_);
	}
}


static void gnonogram_controller_viewer_solve_game (Gnonogram_controller* self) {
	gint _tmp0_;
	gint passes;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp0_ = gnonogram_controller_solve_game (self, TRUE, self->priv->_advanced);
	passes = _tmp0_;
	switch (passes) {
		case -2:
		{
			break;
		}
		case -1:
		{
			const gchar* _tmp1_ = NULL;
			_tmp1_ = _ ("Invalid - no solution");
			utils_show_warning_dialog (_tmp1_);
			break;
		}
		case 0:
		{
			const gchar* _tmp2_ = NULL;
			_tmp2_ = _ ("Failed to solve or no unique solution");
			utils_show_info_dialog (_tmp2_);
			break;
		}
		default:
		{
			gchar* _tmp3_ = NULL;
			gchar* _tmp4_;
			_tmp3_ = g_strdup_printf ("%i", passes);
			_tmp4_ = _tmp3_;
			gnonogram_view_set_score_label (self->_gnonogram_view, _tmp4_);
			_g_free0 (_tmp4_);
			break;
		}
	}
	gnonogram_controller_show_solver_grid (self);
	gnonogram_controller_change_state (self, GAME_STATE_SOLVING);
}


static void gnonogram_controller_show_solver_grid (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_set_working_from_solver (self);
	gnonogram_controller_redraw_all (self);
}


static gint gnonogram_controller_solve_clues (Gnonogram_controller* self, gchar** row_clues, int row_clues_length1, gchar** col_clues, int col_clues_length1, My2DCellArray* startgrid, gboolean use_advanced) {
	gint result = 0;
	gint passes;
	gint _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), 0);
	g_return_val_if_fail ((startgrid == NULL) || IS_MY2_DCELL_ARRAY (startgrid), 0);
	passes = 0;
	gnonogram_solver_initialize (self->_solver, row_clues, row_clues_length1, col_clues, col_clues_length1, startgrid);
	_tmp0_ = gnonogram_solver_solve_it (self->_solver, self->priv->_debug, use_advanced);
	passes = _tmp0_;
	result = passes;
	return result;
}


static gint gnonogram_controller_solve_game (Gnonogram_controller* self, gboolean use_startgrid, gboolean use_advanced) {
	gint result = 0;
	gchar** _tmp0_ = NULL;
	gchar** row_clues;
	gint row_clues_length1;
	gint _row_clues_size_;
	gchar** _tmp1_ = NULL;
	gchar** col_clues;
	gint col_clues_length1;
	gint _col_clues_size_;
	My2DCellArray* startgrid = NULL;
	gint _tmp15_;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), 0);
	_tmp0_ = g_new0 (gchar*, self->priv->_rows + 1);
	row_clues = _tmp0_;
	row_clues_length1 = self->priv->_rows;
	_row_clues_size_ = self->priv->_rows;
	_tmp1_ = g_new0 (gchar*, self->priv->_cols + 1);
	col_clues = _tmp1_;
	col_clues_length1 = self->priv->_cols;
	_col_clues_size_ = self->priv->_cols;
	if (use_startgrid) {
		My2DCellArray* _tmp2_ = NULL;
		My2DCellArray* _tmp3_;
		_tmp2_ = my2_dcell_array_new (self->priv->_rows, self->priv->_cols, CELL_STATE_UNKNOWN);
		_tmp3_ = _tmp2_;
		_my2_dcell_array_unref0 (startgrid);
		startgrid = _tmp3_;
		{
			gint r;
			r = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					if (!_tmp4_) {
						r++;
					}
					_tmp4_ = FALSE;
					if (!(r < self->priv->_rows)) {
						break;
					}
					{
						gint c;
						c = 0;
						{
							gboolean _tmp5_;
							_tmp5_ = TRUE;
							while (TRUE) {
								Cell _tmp6_ = {0};
								Cell _tmp7_ = {0};
								if (!_tmp5_) {
									c++;
								}
								_tmp5_ = FALSE;
								if (!(c < self->priv->_cols)) {
									break;
								}
								_tmp7_ = (gnonogram_model_get_cell (self->_model, r, c, &_tmp6_), _tmp6_);
								my2_dcell_array_set_data_from_cell (startgrid, &_tmp7_);
							}
						}
					}
				}
			}
		}
	} else {
		My2DCellArray* _tmp8_;
		_tmp8_ = NULL;
		_my2_dcell_array_unref0 (startgrid);
		startgrid = _tmp8_;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				if (!_tmp9_) {
					i++;
				}
				_tmp9_ = FALSE;
				if (!(i < self->priv->_rows)) {
					break;
				}
				_tmp10_ = gnonogram_labelbox_get_label_text (self->_rowbox, i);
				_tmp11_ = _tmp10_;
				_g_free0 (row_clues[i]);
				row_clues[i] = _tmp11_;
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp12_;
			_tmp12_ = TRUE;
			while (TRUE) {
				gchar* _tmp13_ = NULL;
				gchar* _tmp14_;
				if (!_tmp12_) {
					i++;
				}
				_tmp12_ = FALSE;
				if (!(i < self->priv->_cols)) {
					break;
				}
				_tmp13_ = gnonogram_labelbox_get_label_text (self->_colbox, i);
				_tmp14_ = _tmp13_;
				_g_free0 (col_clues[i]);
				col_clues[i] = _tmp14_;
			}
		}
	}
	_tmp15_ = gnonogram_controller_solve_clues (self, row_clues, row_clues_length1, col_clues, col_clues_length1, startgrid, use_advanced);
	result = _tmp15_;
	_my2_dcell_array_unref0 (startgrid);
	col_clues = (_vala_array_free (col_clues, col_clues_length1, (GDestroyNotify) g_free), NULL);
	row_clues = (_vala_array_free (row_clues, row_clues_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void gnonogram_controller_set_solution_from_solver (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	if (self->priv->_have_solution) {
		gnonogram_model_use_solution (self->_model);
		gnonogram_controller_set_model_from_solver (self);
	}
}


static void gnonogram_controller_set_working_from_solver (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_model_use_working (self->_model);
	gnonogram_controller_set_model_from_solver (self);
}


static void gnonogram_controller_set_model_from_solver (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	{
		gint r;
		r = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					r++;
				}
				_tmp0_ = FALSE;
				if (!(r < self->priv->_rows)) {
					break;
				}
				{
					gint c;
					c = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							Cell _tmp2_ = {0};
							Cell _tmp3_ = {0};
							if (!_tmp1_) {
								c++;
							}
							_tmp1_ = FALSE;
							if (!(c <= self->priv->_cols)) {
								break;
							}
							_tmp3_ = (gnonogram_solver_get_cell (self->_solver, r, c, &_tmp2_), _tmp2_);
							gnonogram_model_set_data_from_cell (self->_model, &_tmp3_);
						}
					}
				}
			}
		}
	}
}


void gnonogram_controller_set_difficulty (Gnonogram_controller* self, gdouble d) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	self->priv->_grade = (gint) d;
}


void gnonogram_controller_random_game (Gnonogram_controller* self) {
	const gchar* _tmp0_ = NULL;
	gint passes;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_new_game (self);
	_tmp0_ = _ ("Thinking ....");
	gnonogram_view_set_name (self->_gnonogram_view, _tmp0_);
	gtk_widget_show_all (GTK_WIDGET (self->_gnonogram_view));
	passes = 0;
	if (self->priv->_difficult) {
		gint _tmp1_;
		gnonogram_controller_generate_difficult_game (self, self->priv->_grade);
		_tmp1_ = gnonogram_controller_solve_game (self, FALSE, TRUE);
		passes = _tmp1_;
	} else {
		gint count;
		gint grade;
		count = 0;
		grade = self->priv->_grade;
		while (TRUE) {
			gint _tmp2_;
			gboolean _tmp3_ = FALSE;
			if (!(count < 10)) {
				break;
			}
			_tmp2_ = gnonogram_controller_generate_simple_game (self, grade);
			passes = _tmp2_;
			if (passes > self->priv->_grade) {
				_tmp3_ = TRUE;
			} else {
				_tmp3_ = passes < 0;
			}
			if (_tmp3_) {
				break;
			}
			if (passes == 0) {
				grade--;
				if (self->priv->_grade < 1) {
					break;
				}
			}
			count++;
		}
	}
	self->priv->_have_solution = TRUE;
	if (passes >= 0) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp7_;
		gchar* name;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		if (passes > 15) {
			const gchar* _tmp5_ = NULL;
			_tmp5_ = _ ("Difficult random");
			_tmp4_ = _tmp5_;
		} else {
			const gchar* _tmp6_ = NULL;
			_tmp6_ = _ ("Simple random");
			_tmp4_ = _tmp6_;
		}
		_tmp7_ = g_strdup (_tmp4_);
		name = _tmp7_;
		gnonogram_view_set_name (self->_gnonogram_view, name);
		_tmp8_ = _ ("Computer");
		gnonogram_view_set_author (self->_gnonogram_view, _tmp8_);
		_tmp9_ = utils_get_todays_date_string ();
		_tmp10_ = _tmp9_;
		gnonogram_view_set_date (self->_gnonogram_view, _tmp10_);
		_g_free0 (_tmp10_);
		_tmp11_ = g_strdup_printf ("%i", passes);
		_tmp12_ = _tmp11_;
		gnonogram_view_set_score_label (self->_gnonogram_view, _tmp12_);
		_g_free0 (_tmp12_);
		self->priv->_have_solution = TRUE;
		gnonogram_model_use_working (self->_model);
		gnonogram_controller_start_solving (self);
		_g_free0 (name);
	} else {
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_;
		gchar* _tmp16_;
		const gchar* _tmp17_ = NULL;
		_tmp13_ = _ ("Error occurred in solver\n");
		utils_show_warning_dialog (_tmp13_);
		_tmp14_ = gnonogram_solver_get_error (self->_solver);
		_tmp15_ = _tmp14_;
		_tmp16_ = g_strconcat (_tmp15_, "\n", NULL);
		fprintf (stdout, "%s", _tmp16_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp15_);
		_tmp17_ = _ ("Error in solver");
		gnonogram_view_set_name (self->_gnonogram_view, _tmp17_);
		gnonogram_view_set_author (self->_gnonogram_view, "");
		gnonogram_view_set_date (self->_gnonogram_view, "");
		gnonogram_model_use_solution (self->_model);
		gnonogram_controller_reveal_solution (self);
	}
}


static gint gnonogram_controller_generate_simple_game (Gnonogram_controller* self, gint grade) {
	gint result = 0;
	gint tries;
	gint passes;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), 0);
	tries = 0;
	passes = 0;
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gint _tmp1_;
		if (passes == 0) {
			_tmp0_ = tries <= resource_MAXTRIES;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		tries++;
		_tmp1_ = gnonogram_controller_generate_game (self, grade);
		passes = _tmp1_;
	}
	result = passes;
	return result;
}


static gint gnonogram_controller_generate_difficult_game (Gnonogram_controller* self, gint grade) {
	gint result = 0;
	gint tries;
	gint passes;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), 0);
	tries = 0;
	passes = 1;
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gint _tmp1_;
		if (passes > 0) {
			_tmp0_ = tries <= resource_MAXTRIES;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		tries++;
		_tmp1_ = gnonogram_controller_generate_game (self, grade);
		passes = _tmp1_;
	}
	result = passes;
	return result;
}


static gint gnonogram_controller_generate_game (Gnonogram_controller* self, gint grade) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), 0);
	gnonogram_model_fill_random (self->_model, grade);
	gnonogram_controller_update_labels_from_model (self);
	_tmp0_ = gnonogram_controller_solve_game (self, FALSE, FALSE);
	result = _tmp0_;
	return result;
}


static void gnonogram_controller_update_labels_from_model (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	{
		gint r;
		r = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gchar* _tmp1_ = NULL;
				gchar* _tmp2_;
				if (!_tmp0_) {
					r++;
				}
				_tmp0_ = FALSE;
				if (!(r < self->priv->_rows)) {
					break;
				}
				_tmp1_ = gnonogram_model_get_label_text (self->_model, r, FALSE);
				_tmp2_ = _tmp1_;
				gnonogram_labelbox_update_label (self->_rowbox, r, _tmp2_);
				_g_free0 (_tmp2_);
			}
		}
	}
	{
		gint c;
		c = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gchar* _tmp4_ = NULL;
				gchar* _tmp5_;
				if (!_tmp3_) {
					c++;
				}
				_tmp3_ = FALSE;
				if (!(c < self->priv->_cols)) {
					break;
				}
				_tmp4_ = gnonogram_model_get_label_text (self->_model, c, TRUE);
				_tmp5_ = _tmp4_;
				gnonogram_labelbox_update_label (self->_colbox, c, _tmp5_);
				_g_free0 (_tmp5_);
			}
		}
	}
	gtk_widget_show_all (GTK_WIDGET (self->_rowbox));
	gtk_widget_show_all (GTK_WIDGET (self->_colbox));
}


void gnonogram_controller_quit_game (Gnonogram_controller* self) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_save_config (self);
	gtk_main_quit ();
}


static void gnonogram_controller_save_config (Gnonogram_controller* self) {
	Config* _tmp0_ = NULL;
	Config* config_instance;
	gdouble _tmp1_;
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	_tmp0_ = config_get_instance ();
	config_instance = _tmp0_;
	_tmp1_ = gnonogram_view_get_grade_spin_value (self->_gnonogram_view);
	config_set_difficulty (config_instance, _tmp1_);
	config_set_dimensions (config_instance, self->priv->_rows, self->priv->_cols);
	config_set_colors (config_instance);
	gnonogram_controller_save_position (self);
	_config_unref0 (config_instance);
}


static void gnonogram_controller_change_state (Gnonogram_controller* self, GameState gs) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	gnonogram_controller_initialize_cursor (self);
	gnonogram_controller_set__state (self, gs);
	if (gs == GAME_STATE_SETTING) {
		gnonogram_model_use_solution (self->_model);
	} else {
		gnonogram_model_use_working (self->_model);
	}
	gnonogram_view_state_has_changed (self->_gnonogram_view, gs);
}


static GameState gnonogram_controller_get__state (Gnonogram_controller* self) {
	GameState result;
	g_return_val_if_fail (IS_GNONOGRAM_CONTROLLER (self), 0);
	result = self->priv->__state;
	return result;
}


static void gnonogram_controller_set__state (Gnonogram_controller* self, GameState value) {
	g_return_if_fail (IS_GNONOGRAM_CONTROLLER (self));
	self->priv->__state = value;
}


static void value_gnonogram_controller_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_gnonogram_controller_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gnonogram_controller_unref (value->data[0].v_pointer);
	}
}


static void value_gnonogram_controller_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gnonogram_controller_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_gnonogram_controller_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_gnonogram_controller_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Gnonogram_controller* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gnonogram_controller_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_gnonogram_controller_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Gnonogram_controller** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gnonogram_controller_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_gnonogram_controller (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGnonogram_controller* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GNONOGRAM_CONTROLLER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_gnonogram_controller (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_CONTROLLER), NULL);
	return value->data[0].v_pointer;
}


void value_set_gnonogram_controller (GValue* value, gpointer v_object) {
	Gnonogram_controller* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_CONTROLLER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_CONTROLLER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gnonogram_controller_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_controller_unref (old);
	}
}


void value_take_gnonogram_controller (GValue* value, gpointer v_object) {
	Gnonogram_controller* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_CONTROLLER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_CONTROLLER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_controller_unref (old);
	}
}


static void gnonogram_controller_class_init (Gnonogram_controllerClass * klass) {
	gnonogram_controller_parent_class = g_type_class_peek_parent (klass);
	GNONOGRAM_CONTROLLER_CLASS (klass)->finalize = gnonogram_controller_finalize;
	g_type_class_add_private (klass, sizeof (Gnonogram_controllerPrivate));
}


static void gnonogram_controller_instance_init (Gnonogram_controller * self) {
	self->priv = GNONOGRAM_CONTROLLER_GET_PRIVATE (self);
	self->priv->_debug = FALSE;
	self->priv->_advanced = TRUE;
	self->priv->_difficult = FALSE;
	self->ref_count = 1;
}


static void gnonogram_controller_finalize (Gnonogram_controller* obj) {
	Gnonogram_controller * self;
	self = GNONOGRAM_CONTROLLER (obj);
	_g_object_unref0 (self->_gnonogram_view);
	_g_object_unref0 (self->_colbox);
	_g_object_unref0 (self->_rowbox);
	_g_object_unref0 (self->_cellgrid);
	_gnonogram_model_unref0 (self->_model);
	_gnonogram_solver_unref0 (self->_solver);
}


GType gnonogram_controller_get_type (void) {
	static volatile gsize gnonogram_controller_type_id__volatile = 0;
	if (g_once_init_enter (&gnonogram_controller_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_gnonogram_controller_init, value_gnonogram_controller_free_value, value_gnonogram_controller_copy_value, value_gnonogram_controller_peek_pointer, "p", value_gnonogram_controller_collect_value, "p", value_gnonogram_controller_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (Gnonogram_controllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnonogram_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Gnonogram_controller), 0, (GInstanceInitFunc) gnonogram_controller_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gnonogram_controller_type_id;
		gnonogram_controller_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Gnonogram_controller", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gnonogram_controller_type_id__volatile, gnonogram_controller_type_id);
	}
	return gnonogram_controller_type_id__volatile;
}


gpointer gnonogram_controller_ref (gpointer instance) {
	Gnonogram_controller* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gnonogram_controller_unref (gpointer instance) {
	Gnonogram_controller* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GNONOGRAM_CONTROLLER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




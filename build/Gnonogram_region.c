/* Gnonogram_region.c generated by valac 0.11.6, the Vala compiler
 * generated from Gnonogram_region.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 *
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GNONOGRAM_REGION (gnonogram_region_get_type ())
#define GNONOGRAM_REGION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_REGION, Gnonogram_region))
#define GNONOGRAM_REGION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_REGION, Gnonogram_regionClass))
#define IS_GNONOGRAM_REGION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_REGION))
#define IS_GNONOGRAM_REGION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_REGION))
#define GNONOGRAM_REGION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_REGION, Gnonogram_regionClass))

typedef struct _Gnonogram_region Gnonogram_region;
typedef struct _Gnonogram_regionClass Gnonogram_regionClass;
typedef struct _Gnonogram_regionPrivate Gnonogram_regionPrivate;

#define TYPE_MY2_DCELL_ARRAY (my2_dcell_array_get_type ())
#define MY2_DCELL_ARRAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MY2_DCELL_ARRAY, My2DCellArray))
#define MY2_DCELL_ARRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MY2_DCELL_ARRAY, My2DCellArrayClass))
#define IS_MY2_DCELL_ARRAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MY2_DCELL_ARRAY))
#define IS_MY2_DCELL_ARRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MY2_DCELL_ARRAY))
#define MY2_DCELL_ARRAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MY2_DCELL_ARRAY, My2DCellArrayClass))

typedef struct _My2DCellArray My2DCellArray;
typedef struct _My2DCellArrayClass My2DCellArrayClass;

#define TYPE_CELL_STATE (cell_state_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _my2_dcell_array_unref0(var) ((var == NULL) ? NULL : (var = (my2_dcell_array_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

#define TYPE_GNONOGRAM_PERMUTOR (gnonogram_permutor_get_type ())
#define GNONOGRAM_PERMUTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_PERMUTOR, Gnonogram_permutor))
#define GNONOGRAM_PERMUTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_PERMUTOR, Gnonogram_permutorClass))
#define IS_GNONOGRAM_PERMUTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_PERMUTOR))
#define IS_GNONOGRAM_PERMUTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_PERMUTOR))
#define GNONOGRAM_PERMUTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_PERMUTOR, Gnonogram_permutorClass))

typedef struct _Gnonogram_permutor Gnonogram_permutor;
typedef struct _Gnonogram_permutorClass Gnonogram_permutorClass;
#define _gnonogram_permutor_unref0(var) ((var == NULL) ? NULL : (var = (gnonogram_permutor_unref (var), NULL)))
typedef struct _ParamSpecGnonogram_region ParamSpecGnonogram_region;

struct _Gnonogram_region {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Gnonogram_regionPrivate * priv;
	gboolean _is_column;
	gboolean _in_error;
	gboolean _completed;
	gint _index;
	My2DCellArray* _grid;
	gchar* message;
};

struct _Gnonogram_regionClass {
	GTypeClass parent_class;
	void (*finalize) (Gnonogram_region *self);
};

typedef enum  {
	CELL_STATE_UNKNOWN,
	CELL_STATE_EMPTY,
	CELL_STATE_FILLED,
	CELL_STATE_ERROR,
	CELL_STATE_COMPLETED
} CellState;

struct _Gnonogram_regionPrivate {
	gboolean _completed_store;
	gboolean* _completed_blocks;
	gint _completed_blocks_length1;
	gint __completed_blocks_size_;
	gboolean* _completed_blocks_store;
	gint _completed_blocks_store_length1;
	gint __completed_blocks_store_size_;
	gboolean* _tags;
	gint _tags_length1;
	gint _tags_length2;
	gboolean* _tags_store;
	gint _tags_store_length1;
	gint _tags_store_length2;
	gint* _ranges;
	gint _ranges_length1;
	gint _ranges_length2;
	gint _ncells;
	gchar* _clue;
	gint _nblocks;
	gint _block_total;
	gint _block_extent;
	gint _unknown;
	gint _unknown_store;
	gint _filled;
	gint _filled_store;
	gint _empty;
	gint _empty_store;
	gint _can_be_empty_ptr;
	gint _is_finished_ptr;
	gint* _blocks;
	gint _blocks_length1;
	gint __blocks_size_;
	CellState* _status;
	gint _status_length1;
	gint __status_size_;
	CellState* _status_store;
	gint _status_store_length1;
	gint __status_store_size_;
	CellState* _temp_status;
	gint _temp_status_length1;
	gint __temp_status_size_;
	gboolean _debug;
};

struct _ParamSpecGnonogram_region {
	GParamSpec parent_instance;
};


static gpointer gnonogram_region_parent_class = NULL;
extern gint resource_MAXCOLSIZE;
extern gint resource_MAXROWSIZE;

gpointer gnonogram_region_ref (gpointer instance);
void gnonogram_region_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_region (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_region (GValue* value, gpointer v_object);
void value_take_gnonogram_region (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_region (const GValue* value);
GType gnonogram_region_get_type (void) G_GNUC_CONST;
gpointer my2_dcell_array_ref (gpointer instance);
void my2_dcell_array_unref (gpointer instance);
GParamSpec* param_spec_my2_dcell_array (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_my2_dcell_array (GValue* value, gpointer v_object);
void value_take_my2_dcell_array (GValue* value, gpointer v_object);
gpointer value_get_my2_dcell_array (const GValue* value);
GType my2_dcell_array_get_type (void) G_GNUC_CONST;
GType cell_state_get_type (void) G_GNUC_CONST;
#define GNONOGRAM_REGION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GNONOGRAM_REGION, Gnonogram_regionPrivate))
enum  {
	GNONOGRAM_REGION_DUMMY_PROPERTY
};
#define GNONOGRAM_REGION_MAXCYCLES 15
#define GNONOGRAM_REGION_FORWARDS 1
#define GNONOGRAM_REGION_BACKWARDS (-1)
Gnonogram_region* gnonogram_region_new (My2DCellArray* grid);
Gnonogram_region* gnonogram_region_construct (GType object_type, My2DCellArray* grid);
void gnonogram_region_initialize (Gnonogram_region* self, gint index, gboolean iscolumn, gint ncells, const gchar* clue);
gint* utils_block_array_from_clue (const gchar* s, int* result_length1);
void gnonogram_region_initial_state (Gnonogram_region* self);
static void gnonogram_region_get_status (Gnonogram_region* self);
static void gnonogram_region_initial_fix (Gnonogram_region* self);
static gboolean gnonogram_region_tags_to_status (Gnonogram_region* self);
static void gnonogram_region_put_status (Gnonogram_region* self, gboolean debug);
static gboolean gnonogram_region_set_range_owner (Gnonogram_region* self, gint owner, gint start, gint length, gboolean exclusive, gboolean can_be_empty);
gboolean gnonogram_region_solve (Gnonogram_region* self, gboolean debug);
static gboolean gnonogram_region_totals_changed (Gnonogram_region* self);
static gboolean gnonogram_region_full_fix (Gnonogram_region* self);
static gboolean gnonogram_region_capped_range_audit (Gnonogram_region* self);
static gboolean gnonogram_region_possibilities_audit (Gnonogram_region* self);
static gboolean gnonogram_region_only_possibility (Gnonogram_region* self);
static gboolean gnonogram_region_do_edge (Gnonogram_region* self, gint direction);
static gboolean gnonogram_region_filled_subregion_audit (Gnonogram_region* self);
static gboolean gnonogram_region_fill_gaps (Gnonogram_region* self);
static gboolean gnonogram_region_free_cell_audit (Gnonogram_region* self);
static gboolean gnonogram_region_fix_blocks_in_ranges (Gnonogram_region* self);
static gboolean gnonogram_region_skip_while_not_status (Gnonogram_region* self, CellState cs, gint* idx, gint limit, gint direction);
static gint gnonogram_region_count_next_state (Gnonogram_region* self, CellState cs, gint idx, gboolean forwards);
static void gnonogram_region_assign_and_cap_range (Gnonogram_region* self, gint start, gint length);
static gint gnonogram_region_find_largest_possible_in_cell (Gnonogram_region* self, gint cell);
static gint gnonogram_region_find_smallest_possible_in_cell (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_one_owner (Gnonogram_region* self, gint cell);
static void gnonogram_region_set_cell_empty (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_same_owner (Gnonogram_region* self, gint cell1, gint cell2, gint* owner);
static gint gnonogram_region_count_next_owner (Gnonogram_region* self, gint owner, gint idx);
static void gnonogram_region_remove_block_from_range (Gnonogram_region* self, gint block, gint start, gint length, gint direction);
static gboolean gnonogram_region_fix_block_in_range (Gnonogram_region* self, gint block, gint start, gint length);
static void gnonogram_region_set_block_complete_and_cap (Gnonogram_region* self, gint block, gint start, gint direction);
static void gnonogram_region_remove_block_from_cell_to_end (Gnonogram_region* self, gint block, gint start, gint direction);
static gint gnonogram_region_count_cell_state (Gnonogram_region* self, CellState cs);
static void gnonogram_region_set_cell_complete (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_find_edge (Gnonogram_region* self, gint* idx, gint* blocknum, gint limit, gint direction);
static gboolean gnonogram_region_set_cell_owner (Gnonogram_region* self, gint cell, gint owner, gboolean exclusive, gboolean can_be_empty);
static gint* gnonogram_region_blocks_available (Gnonogram_region* self, int* result_length1);
static gint gnonogram_region_count_available_ranges (Gnonogram_region* self, gboolean not_empty);
static gint gnonogram_region_count_capped_ranges (Gnonogram_region* self);
static void gnonogram_region_record_error (Gnonogram_region* self, const gchar* method, const gchar* errmessage, gboolean debug);
static gboolean gnonogram_region_check_nblocks (Gnonogram_region* self);
static gint gnonogram_region_count_owners_and_empty (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_invalid_data (Gnonogram_region* self, gint start, gint block, gint length);
static void _vala_array_add8 (gint** array, int* length, int* size, gint value);
static gboolean gnonogram_region_cell_filled (Gnonogram_region* self, gint cell);
void my2_dcell_array_get_array (My2DCellArray* self, gint idx, gboolean iscolumn, CellState** sa, int* sa_length1, gint start);
static void gnonogram_region_status_to_tags (Gnonogram_region* self);
void my2_dcell_array_set_array (My2DCellArray* self, gint idx, gboolean iscolumn, CellState* sa, int sa_length1, gint start);
void gnonogram_region_save_state (Gnonogram_region* self);
void gnonogram_region_restore_state (Gnonogram_region* self);
gint gnonogram_region_value_as_permute_region (Gnonogram_region* self);
gpointer gnonogram_permutor_ref (gpointer instance);
void gnonogram_permutor_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_permutor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_permutor (GValue* value, gpointer v_object);
void value_take_gnonogram_permutor (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_permutor (const GValue* value);
GType gnonogram_permutor_get_type (void) G_GNUC_CONST;
Gnonogram_permutor* gnonogram_region_get_permutor (Gnonogram_region* self, gint* start);
Gnonogram_permutor* gnonogram_permutor_new (gint size, const gchar* clue);
Gnonogram_permutor* gnonogram_permutor_construct (GType object_type, gint size, const gchar* clue);
gchar* gnonogram_region_to_string (Gnonogram_region* self);
static void gnonogram_region_finalize (Gnonogram_region* obj);


static gpointer _my2_dcell_array_ref0 (gpointer self) {
	return self ? my2_dcell_array_ref (self) : NULL;
}


Gnonogram_region* gnonogram_region_construct (GType object_type, My2DCellArray* grid) {
	Gnonogram_region* self = NULL;
	My2DCellArray* _tmp0_;
	My2DCellArray* _tmp1_;
	gint _tmp2_;
	gint maxlength;
	CellState* _tmp3_ = NULL;
	CellState* _tmp4_;
	CellState* _tmp5_ = NULL;
	CellState* _tmp6_;
	CellState* _tmp7_ = NULL;
	CellState* _tmp8_;
	gint maxblocks;
	gint _tmp9_;
	gint* _tmp10_ = NULL;
	gint* _tmp11_;
	gint* _tmp12_ = NULL;
	gint* _tmp13_;
	gboolean* _tmp14_ = NULL;
	gboolean* _tmp15_;
	gboolean* _tmp16_ = NULL;
	gboolean* _tmp17_;
	gboolean* _tmp18_ = NULL;
	gboolean* _tmp19_;
	gboolean* _tmp20_ = NULL;
	gboolean* _tmp21_;
	g_return_val_if_fail (IS_MY2_DCELL_ARRAY (grid), NULL);
	self = (Gnonogram_region*) g_type_create_instance (object_type);
	_tmp0_ = _my2_dcell_array_ref0 (grid);
	_tmp1_ = _tmp0_;
	_my2_dcell_array_unref0 (self->_grid);
	self->_grid = _tmp1_;
	_tmp2_ = MAX (resource_MAXCOLSIZE, resource_MAXROWSIZE);
	maxlength = _tmp2_;
	_tmp3_ = g_new0 (CellState, maxlength);
	_tmp4_ = _tmp3_;
	self->priv->_status = (g_free (self->priv->_status), NULL);
	self->priv->_status_length1 = maxlength;
	self->priv->__status_size_ = self->priv->_status_length1;
	self->priv->_status = _tmp4_;
	_tmp5_ = g_new0 (CellState, maxlength);
	_tmp6_ = _tmp5_;
	self->priv->_status_store = (g_free (self->priv->_status_store), NULL);
	self->priv->_status_store_length1 = maxlength;
	self->priv->__status_store_size_ = self->priv->_status_store_length1;
	self->priv->_status_store = _tmp6_;
	_tmp7_ = g_new0 (CellState, maxlength);
	_tmp8_ = _tmp7_;
	self->priv->_temp_status = (g_free (self->priv->_temp_status), NULL);
	self->priv->_temp_status_length1 = maxlength;
	self->priv->__temp_status_size_ = self->priv->_temp_status_length1;
	self->priv->_temp_status = _tmp8_;
	maxblocks = (maxlength / 2) + 2;
	_tmp10_ = g_new0 (gint, maxblocks * (_tmp9_ = 4 + maxblocks));
	_tmp11_ = _tmp10_;
	self->priv->_ranges = (g_free (self->priv->_ranges), NULL);
	self->priv->_ranges_length1 = maxblocks;
	self->priv->_ranges_length2 = _tmp9_;
	self->priv->_ranges = _tmp11_;
	_tmp12_ = g_new0 (gint, maxblocks);
	_tmp13_ = _tmp12_;
	self->priv->_blocks = (g_free (self->priv->_blocks), NULL);
	self->priv->_blocks_length1 = maxblocks;
	self->priv->__blocks_size_ = self->priv->_blocks_length1;
	self->priv->_blocks = _tmp13_;
	_tmp14_ = g_new0 (gboolean, maxblocks);
	_tmp15_ = _tmp14_;
	self->priv->_completed_blocks = (g_free (self->priv->_completed_blocks), NULL);
	self->priv->_completed_blocks_length1 = maxblocks;
	self->priv->__completed_blocks_size_ = self->priv->_completed_blocks_length1;
	self->priv->_completed_blocks = _tmp15_;
	_tmp16_ = g_new0 (gboolean, maxblocks);
	_tmp17_ = _tmp16_;
	self->priv->_completed_blocks_store = (g_free (self->priv->_completed_blocks_store), NULL);
	self->priv->_completed_blocks_store_length1 = maxblocks;
	self->priv->__completed_blocks_store_size_ = self->priv->_completed_blocks_store_length1;
	self->priv->_completed_blocks_store = _tmp17_;
	_tmp18_ = g_new0 (gboolean, maxlength * (maxblocks + 2));
	_tmp19_ = _tmp18_;
	self->priv->_tags = (g_free (self->priv->_tags), NULL);
	self->priv->_tags_length1 = maxlength;
	self->priv->_tags_length2 = maxblocks + 2;
	self->priv->_tags = _tmp19_;
	_tmp20_ = g_new0 (gboolean, maxlength * (maxblocks + 2));
	_tmp21_ = _tmp20_;
	self->priv->_tags_store = (g_free (self->priv->_tags_store), NULL);
	self->priv->_tags_store_length1 = maxlength;
	self->priv->_tags_store_length2 = maxblocks + 2;
	self->priv->_tags_store = _tmp21_;
	return self;
}


Gnonogram_region* gnonogram_region_new (My2DCellArray* grid) {
	return gnonogram_region_construct (TYPE_GNONOGRAM_REGION, grid);
}


void gnonogram_region_initialize (Gnonogram_region* self, gint index, gboolean iscolumn, gint ncells, const gchar* clue) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp2_;
	gint* _tmp3_ = NULL;
	gint* tmp_blocks;
	gint tmp_blocks_length1;
	gint _tmp_blocks_size_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	g_return_if_fail (clue != NULL);
	self->_index = index;
	self->_is_column = iscolumn;
	self->priv->_ncells = ncells;
	_tmp0_ = g_strdup (clue);
	_tmp1_ = _tmp0_;
	_g_free0 (self->priv->_clue);
	self->priv->_clue = _tmp1_;
	_tmp3_ = utils_block_array_from_clue (clue, &_tmp2_);
	tmp_blocks = _tmp3_;
	tmp_blocks_length1 = _tmp2_;
	_tmp_blocks_size_ = _tmp2_;
	self->priv->_nblocks = tmp_blocks_length1;
	self->priv->_can_be_empty_ptr = self->priv->_nblocks;
	self->priv->_is_finished_ptr = self->priv->_nblocks + 1;
	self->priv->_block_total = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					i++;
				}
				_tmp4_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				self->priv->_blocks[i] = tmp_blocks[i];
				self->priv->_block_total = self->priv->_block_total + tmp_blocks[i];
			}
		}
	}
	self->priv->_block_extent = (self->priv->_block_total + self->priv->_nblocks) - 1;
	gnonogram_region_initial_state (self);
	tmp_blocks = (g_free (tmp_blocks), NULL);
}


void gnonogram_region_initial_state (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				self->priv->_completed_blocks[i] = FALSE;
				self->priv->_completed_blocks_store[i] = FALSE;
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				{
					gint j;
					j = 0;
					{
						gboolean _tmp2_;
						_tmp2_ = TRUE;
						while (TRUE) {
							if (!_tmp2_) {
								j++;
							}
							_tmp2_ = FALSE;
							if (!(j < self->priv->_nblocks)) {
								break;
							}
							self->priv->_tags[(i * self->priv->_tags_length2) + j] = FALSE;
							self->priv->_tags_store[(i * self->priv->_tags_store_length2) + j] = FALSE;
						}
					}
				}
				self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = TRUE;
				self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = FALSE;
				self->priv->_status[i] = CELL_STATE_UNKNOWN;
				self->priv->_temp_status[i] = CELL_STATE_UNKNOWN;
			}
		}
	}
	self->_in_error = FALSE;
	self->_completed = self->priv->_ncells == 1;
	if (self->_completed) {
		return;
	}
	self->priv->_unknown = 99;
	self->priv->_filled = 99;
	self->priv->_empty = -1;
	gnonogram_region_get_status (self);
	if (self->priv->_blocks[0] == 0) {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < self->priv->_ncells)) {
						break;
					}
					{
						gint j;
						j = 0;
						{
							gboolean _tmp4_;
							_tmp4_ = TRUE;
							while (TRUE) {
								if (!_tmp4_) {
									j++;
								}
								_tmp4_ = FALSE;
								if (!(j < self->priv->_nblocks)) {
									break;
								}
								self->priv->_tags[(i * self->priv->_tags_length2) + j] = FALSE;
							}
						}
					}
					self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
					self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
					self->priv->_status[i] = CELL_STATE_EMPTY;
					self->priv->_temp_status[i] = CELL_STATE_EMPTY;
				}
			}
		}
		self->_completed = TRUE;
	} else {
		gnonogram_region_initial_fix (self);
	}
	gnonogram_region_tags_to_status (self);
	gnonogram_region_put_status (self, FALSE);
}


static void gnonogram_region_initial_fix (Gnonogram_region* self) {
	gint freedom;
	gint start;
	gint length;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	freedom = self->priv->_ncells - self->priv->_block_extent;
	start = 0;
	length = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				length = self->priv->_blocks[i] + freedom;
				{
					gint j;
					j = start;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							if (!_tmp1_) {
								j++;
							}
							_tmp1_ = FALSE;
							if (!(j < (start + length))) {
								break;
							}
							self->priv->_tags[(j * self->priv->_tags_length2) + i] = TRUE;
						}
					}
				}
				if (freedom < self->priv->_blocks[i]) {
					gnonogram_region_set_range_owner (self, i, start + freedom, self->priv->_blocks[i] - freedom, TRUE, FALSE);
				}
				start = (start + self->priv->_blocks[i]) + 1;
			}
		}
	}
	if (freedom == 0) {
		self->_completed = TRUE;
	}
}


gboolean gnonogram_region_solve (Gnonogram_region* self, gboolean debug) {
	gboolean result = FALSE;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gboolean made_changes;
	gboolean _tmp2_;
	gboolean still_changing;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gint count;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	_tmp0_ = g_strdup ("");
	_tmp1_ = _tmp0_;
	_g_free0 (self->message);
	self->message = _tmp1_;
	self->priv->_debug = debug;
	if (self->_completed) {
		result = FALSE;
		return result;
	}
	made_changes = FALSE;
	gnonogram_region_get_status (self);
	_tmp2_ = gnonogram_region_totals_changed (self);
	still_changing = _tmp2_;
	if (self->_completed) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = self->_in_error;
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = !still_changing;
	}
	if (_tmp3_) {
		result = FALSE;
		return result;
	}
	count = 0;
	while (TRUE) {
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_;
		gboolean _tmp7_;
		if (!self->_completed) {
			_tmp5_ = count < GNONOGRAM_REGION_MAXCYCLES;
		} else {
			_tmp5_ = FALSE;
		}
		if (!_tmp5_) {
			break;
		}
		count++;
		_tmp6_ = gnonogram_region_full_fix (self);
		still_changing = _tmp6_;
		if (self->_in_error) {
			break;
		}
		gnonogram_region_tags_to_status (self);
		_tmp7_ = gnonogram_region_totals_changed (self);
		if (_tmp7_) {
			if (self->_in_error) {
				break;
			} else {
				made_changes = TRUE;
			}
		} else {
			break;
		}
	}
	if (made_changes) {
		_tmp9_ = !self->_in_error;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		_tmp8_ = TRUE;
	} else {
		_tmp8_ = debug;
	}
	if (_tmp8_) {
		gnonogram_region_put_status (self, debug);
	}
	if (count == GNONOGRAM_REGION_MAXCYCLES) {
		fprintf (stdout, "Excessive looping in region %d\n", self->_index);
	}
	result = made_changes;
	return result;
}


static gboolean gnonogram_region_full_fix (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_ = FALSE;
	gboolean _tmp10_;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp14_;
	gboolean _tmp16_ = FALSE;
	gboolean _tmp17_ = FALSE;
	gboolean _tmp18_;
	gboolean _tmp20_ = FALSE;
	gboolean _tmp21_ = FALSE;
	gboolean _tmp22_;
	gboolean _tmp24_ = FALSE;
	gboolean _tmp25_ = FALSE;
	gboolean _tmp26_;
	gboolean _tmp28_ = FALSE;
	gboolean _tmp29_ = FALSE;
	gboolean _tmp30_;
	gboolean _tmp32_ = FALSE;
	gboolean _tmp33_ = FALSE;
	gboolean _tmp34_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_debug) {
		fprintf (stdout, "\n\nfull_fix\n");
	}
	_tmp2_ = gnonogram_region_capped_range_audit (self);
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = self->_in_error;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp3_;
		_tmp3_ = gnonogram_region_tags_to_status (self);
		_tmp0_ = _tmp3_;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	}
	_tmp6_ = gnonogram_region_possibilities_audit (self);
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		_tmp5_ = self->_in_error;
	}
	if (_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		gboolean _tmp7_;
		_tmp7_ = gnonogram_region_tags_to_status (self);
		_tmp4_ = _tmp7_;
	}
	if (_tmp4_) {
		result = TRUE;
		return result;
	}
	_tmp10_ = gnonogram_region_only_possibility (self);
	if (_tmp10_) {
		_tmp9_ = TRUE;
	} else {
		_tmp9_ = self->_in_error;
	}
	if (_tmp9_) {
		_tmp8_ = TRUE;
	} else {
		gboolean _tmp11_;
		_tmp11_ = gnonogram_region_tags_to_status (self);
		_tmp8_ = _tmp11_;
	}
	if (_tmp8_) {
		result = TRUE;
		return result;
	}
	_tmp14_ = gnonogram_region_do_edge (self, 1);
	if (_tmp14_) {
		_tmp13_ = TRUE;
	} else {
		_tmp13_ = self->_in_error;
	}
	if (_tmp13_) {
		_tmp12_ = TRUE;
	} else {
		gboolean _tmp15_;
		_tmp15_ = gnonogram_region_tags_to_status (self);
		_tmp12_ = _tmp15_;
	}
	if (_tmp12_) {
		result = TRUE;
		return result;
	}
	_tmp18_ = gnonogram_region_do_edge (self, -1);
	if (_tmp18_) {
		_tmp17_ = TRUE;
	} else {
		_tmp17_ = self->_in_error;
	}
	if (_tmp17_) {
		_tmp16_ = TRUE;
	} else {
		gboolean _tmp19_;
		_tmp19_ = gnonogram_region_tags_to_status (self);
		_tmp16_ = _tmp19_;
	}
	if (_tmp16_) {
		result = TRUE;
		return result;
	}
	_tmp22_ = gnonogram_region_filled_subregion_audit (self);
	if (_tmp22_) {
		_tmp21_ = TRUE;
	} else {
		_tmp21_ = self->_in_error;
	}
	if (_tmp21_) {
		_tmp20_ = TRUE;
	} else {
		gboolean _tmp23_;
		_tmp23_ = gnonogram_region_tags_to_status (self);
		_tmp20_ = _tmp23_;
	}
	if (_tmp20_) {
		result = TRUE;
		return result;
	}
	_tmp26_ = gnonogram_region_fill_gaps (self);
	if (_tmp26_) {
		_tmp25_ = TRUE;
	} else {
		_tmp25_ = self->_in_error;
	}
	if (_tmp25_) {
		_tmp24_ = TRUE;
	} else {
		gboolean _tmp27_;
		_tmp27_ = gnonogram_region_tags_to_status (self);
		_tmp24_ = _tmp27_;
	}
	if (_tmp24_) {
		result = TRUE;
		return result;
	}
	_tmp30_ = gnonogram_region_free_cell_audit (self);
	if (_tmp30_) {
		_tmp29_ = TRUE;
	} else {
		_tmp29_ = self->_in_error;
	}
	if (_tmp29_) {
		_tmp28_ = TRUE;
	} else {
		gboolean _tmp31_;
		_tmp31_ = gnonogram_region_tags_to_status (self);
		_tmp28_ = _tmp31_;
	}
	if (_tmp28_) {
		result = TRUE;
		return result;
	}
	_tmp34_ = gnonogram_region_fix_blocks_in_ranges (self);
	if (_tmp34_) {
		_tmp33_ = TRUE;
	} else {
		_tmp33_ = self->_in_error;
	}
	if (_tmp33_) {
		_tmp32_ = TRUE;
	} else {
		gboolean _tmp35_;
		_tmp35_ = gnonogram_region_tags_to_status (self);
		_tmp32_ = _tmp35_;
	}
	if (_tmp32_) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static gboolean gnonogram_region_filled_subregion_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gboolean start_capped = FALSE;
	gboolean end_capped = FALSE;
	gint idx;
	gint length = 0;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_debug) {
		fprintf (stdout, "Filled subregions audit\n");
	}
	changed = FALSE;
	idx = 0;
	while (TRUE) {
		gboolean _tmp0_;
		if (!(idx < self->priv->_ncells)) {
			break;
		}
		start_capped = FALSE;
		end_capped = FALSE;
		_tmp0_ = gnonogram_region_skip_while_not_status (self, CELL_STATE_FILLED, &idx, self->priv->_ncells, 1);
		if (_tmp0_) {
			gboolean _tmp1_ = FALSE;
			gint _tmp2_;
			gint lastcell;
			gboolean _tmp3_ = FALSE;
			gboolean _tmp4_ = FALSE;
			if (self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr]) {
				idx++;
				continue;
			}
			if (idx == 0) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = self->priv->_status[idx - 1] == CELL_STATE_EMPTY;
			}
			if (_tmp1_) {
				start_capped = TRUE;
			}
			_tmp2_ = gnonogram_region_count_next_state (self, CELL_STATE_FILLED, idx, TRUE);
			length = _tmp2_;
			lastcell = (idx + length) - 1;
			if (lastcell == (self->priv->_ncells - 1)) {
				_tmp3_ = TRUE;
			} else {
				_tmp3_ = self->priv->_status[lastcell + 1] == CELL_STATE_EMPTY;
			}
			if (_tmp3_) {
				end_capped = TRUE;
			}
			if (start_capped) {
				_tmp4_ = end_capped;
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				gnonogram_region_assign_and_cap_range (self, idx, length);
				changed = TRUE;
			} else {
				gint _tmp5_;
				gint largest;
				_tmp5_ = gnonogram_region_find_largest_possible_in_cell (self, idx);
				largest = _tmp5_;
				if (largest == length) {
					gnonogram_region_assign_and_cap_range (self, idx, length);
					changed = TRUE;
				} else {
					gint _tmp6_ = 0;
					gint start;
					gint _tmp7_ = 0;
					gint end;
					gboolean _tmp11_ = FALSE;
					if (idx == 0) {
						_tmp6_ = idx;
					} else {
						_tmp6_ = idx - 1;
					}
					start = _tmp6_;
					if ((idx + length) == self->priv->_ncells) {
						_tmp7_ = (idx + length) - 1;
					} else {
						_tmp7_ = idx + length;
					}
					end = _tmp7_;
					{
						gint i;
						i = start;
						{
							gboolean _tmp8_;
							_tmp8_ = TRUE;
							while (TRUE) {
								if (!_tmp8_) {
									i++;
								}
								_tmp8_ = FALSE;
								if (!(i <= end)) {
									break;
								}
								{
									gint bl;
									bl = 0;
									{
										gboolean _tmp9_;
										_tmp9_ = TRUE;
										while (TRUE) {
											gboolean _tmp10_ = FALSE;
											if (!_tmp9_) {
												bl++;
											}
											_tmp9_ = FALSE;
											if (!(bl < self->priv->_nblocks)) {
												break;
											}
											if (self->priv->_tags[(i * self->priv->_tags_length2) + bl]) {
												_tmp10_ = self->priv->_blocks[bl] < length;
											} else {
												_tmp10_ = FALSE;
											}
											if (_tmp10_) {
												self->priv->_tags[(i * self->priv->_tags_length2) + bl] = FALSE;
											}
										}
									}
								}
							}
						}
					}
					if (start_capped) {
						_tmp11_ = TRUE;
					} else {
						_tmp11_ = end_capped;
					}
					if (_tmp11_) {
						gint _tmp12_;
						gint smallest;
						_tmp12_ = gnonogram_region_find_smallest_possible_in_cell (self, idx);
						smallest = _tmp12_;
						if (smallest > length) {
							gint count;
							gint direction = 0;
							count = smallest - length;
							if (end_capped) {
								start = idx - 1;
								direction = GNONOGRAM_REGION_BACKWARDS;
							} else {
								start = idx + length;
								direction = GNONOGRAM_REGION_FORWARDS;
							}
							{
								gint i;
								i = 0;
								{
									gboolean _tmp13_;
									_tmp13_ = TRUE;
									while (TRUE) {
										if (!_tmp13_) {
											i++;
										}
										_tmp13_ = FALSE;
										if (!(i < count)) {
											break;
										}
										self->priv->_tags[(start * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
										start = start + direction;
									}
								}
							}
							changed = TRUE;
						}
					}
				}
			}
			idx = idx + length;
		} else {
			break;
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_fill_gaps (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	{
		gint idx;
		idx = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				if (!_tmp0_) {
					idx++;
				}
				_tmp0_ = FALSE;
				if (!(idx < (self->priv->_ncells - 2))) {
					break;
				}
				if (self->priv->_status[idx] != CELL_STATE_FILLED) {
					continue;
				}
				if (self->priv->_status[idx + 1] != CELL_STATE_UNKNOWN) {
					continue;
				}
				_tmp1_ = gnonogram_region_one_owner (self, idx);
				if (!_tmp1_) {
					gint _tmp2_;
					gint _tmp3_;
					gint blength;
					gboolean must_be_empty;
					if (self->priv->_status[idx + 2] != CELL_STATE_FILLED) {
						continue;
					}
					_tmp2_ = gnonogram_region_count_next_state (self, CELL_STATE_FILLED, idx + 2, TRUE);
					_tmp3_ = gnonogram_region_count_next_state (self, CELL_STATE_FILLED, idx, FALSE);
					blength = (_tmp2_ + _tmp3_) + 1;
					must_be_empty = TRUE;
					{
						gint bl;
						bl = 0;
						{
							gboolean _tmp4_;
							_tmp4_ = TRUE;
							while (TRUE) {
								gboolean _tmp5_ = FALSE;
								if (!_tmp4_) {
									bl++;
								}
								_tmp4_ = FALSE;
								if (!(bl < self->priv->_nblocks)) {
									break;
								}
								if (self->priv->_tags[(idx * self->priv->_tags_length2) + bl]) {
									_tmp5_ = self->priv->_blocks[bl] >= blength;
								} else {
									_tmp5_ = FALSE;
								}
								if (_tmp5_) {
									must_be_empty = FALSE;
									break;
								}
							}
						}
					}
					if (must_be_empty) {
						gnonogram_region_set_cell_empty (self, idx + 1);
						changed = TRUE;
					}
				} else {
					gint cell1;
					gint owner = 0;
					gint _tmp7_;
					gboolean _tmp8_;
					cell1 = idx;
					idx++;
					while (TRUE) {
						gboolean _tmp6_ = FALSE;
						if (idx < (self->priv->_ncells - 1)) {
							_tmp6_ = self->priv->_status[idx] == CELL_STATE_UNKNOWN;
						} else {
							_tmp6_ = FALSE;
						}
						if (!_tmp6_) {
							break;
						}
						idx++;
					}
					if (self->priv->_status[idx] != CELL_STATE_FILLED) {
						continue;
					}
					_tmp8_ = gnonogram_region_same_owner (self, cell1, idx, &_tmp7_);
					owner = _tmp7_;
					if (_tmp8_) {
						gboolean _tmp9_ = FALSE;
						gboolean _tmp10_;
						_tmp10_ = gnonogram_region_set_range_owner (self, owner, cell1, (idx - cell1) + 1, TRUE, FALSE);
						if (_tmp10_) {
							_tmp9_ = TRUE;
						} else {
							_tmp9_ = changed;
						}
						changed = _tmp9_;
					}
					idx--;
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_possibilities_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint start = 0;
	gint length = 0;
	gint count = 0;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_completed_blocks[i]) {
					continue;
				}
				start = 0;
				length = 0;
				count = 0;
				{
					gint idx;
					idx = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							gboolean _tmp2_ = FALSE;
							gint s;
							gint _tmp3_;
							gint l;
							if (!_tmp1_) {
								idx++;
							}
							_tmp1_ = FALSE;
							if (!(idx < self->priv->_ncells)) {
								break;
							}
							if (count > 1) {
								break;
							}
							if (!self->priv->_tags[(idx * self->priv->_tags_length2) + i]) {
								_tmp2_ = TRUE;
							} else {
								_tmp2_ = self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
							}
							if (_tmp2_) {
								continue;
							}
							s = idx;
							_tmp3_ = gnonogram_region_count_next_owner (self, i, idx);
							l = _tmp3_;
							if (l < self->priv->_blocks[i]) {
								gnonogram_region_remove_block_from_range (self, i, s, l, 1);
							} else {
								length = l;
								start = s;
								count++;
							}
							idx = idx + (l - 1);
						}
					}
				}
				if (count != 1) {
					continue;
				} else {
					gboolean _tmp4_ = FALSE;
					gboolean _tmp5_;
					_tmp5_ = gnonogram_region_fix_block_in_range (self, i, start, length);
					if (_tmp5_) {
						_tmp4_ = TRUE;
					} else {
						_tmp4_ = changed;
					}
					changed = _tmp4_;
				}
			}
		}
	}
	result = changed;
	return result;
}


static void gnonogram_region_assign_and_cap_range (Gnonogram_region* self, gint start, gint length) {
	gint count;
	gint* _tmp0_ = NULL;
	gint* max_blocks;
	gint max_blocks_length1;
	gint _max_blocks_size_;
	gint first;
	gint last;
	gint end;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	count = 0;
	_tmp0_ = g_new0 (gint, self->priv->_nblocks);
	max_blocks = _tmp0_;
	max_blocks_length1 = self->priv->_nblocks;
	_max_blocks_size_ = self->priv->_nblocks;
	first = self->priv->_nblocks;
	last = 0;
	end = (start + length) - 1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_ = FALSE;
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_completed_blocks[i]) {
					continue;
				}
				if (self->priv->_blocks[i] != length) {
					continue;
				}
				if (!self->priv->_tags[(start * self->priv->_tags_length2) + i]) {
					_tmp2_ = TRUE;
				} else {
					_tmp2_ = !self->priv->_tags[(end * self->priv->_tags_length2) + i];
				}
				if (_tmp2_) {
					continue;
				}
				max_blocks[count] = i;
				count++;
				if (i < first) {
					first = i;
				}
				if (i > last) {
					last = i;
				}
			}
		}
	}
	if (count == 0) {
		max_blocks = (g_free (max_blocks), NULL);
		return;
	}
	if (count == 1) {
		gnonogram_region_set_block_complete_and_cap (self, max_blocks[0], start, 1);
	} else {
		{
			gint i;
			i = last + 1;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					gnonogram_region_remove_block_from_cell_to_end (self, i, (start + length) - 1, -1);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < first)) {
						break;
					}
					gnonogram_region_remove_block_from_cell_to_end (self, i, start, 1);
				}
			}
		}
		{
			gint i;
			i = first + 1;
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					if (!_tmp5_) {
						i++;
					}
					_tmp5_ = FALSE;
					if (!(i < last)) {
						break;
					}
					if (self->priv->_blocks[i] == length) {
						continue;
					}
					gnonogram_region_remove_block_from_range (self, i, start, length, 1);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp6_;
				_tmp6_ = TRUE;
				while (TRUE) {
					if (!_tmp6_) {
						i++;
					}
					_tmp6_ = FALSE;
					if (!(i < count)) {
						break;
					}
					gnonogram_region_set_range_owner (self, max_blocks[i], start, length, FALSE, FALSE);
				}
			}
		}
		if (start > 0) {
			gnonogram_region_set_cell_empty (self, start - 1);
		}
		if ((start + length) < self->priv->_ncells) {
			gnonogram_region_set_cell_empty (self, start + length);
		}
	}
	max_blocks = (g_free (max_blocks), NULL);
}


static gboolean gnonogram_region_only_possibility (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint owner = 0;
	gint length = 0;
	gint start = 0;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr]) {
					continue;
				}
				if (self->priv->_status[i] == CELL_STATE_FILLED) {
					gboolean _tmp2_;
					_tmp2_ = gnonogram_region_one_owner (self, i);
					_tmp1_ = _tmp2_;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					{
						gboolean _tmp3_;
						owner = 0;
						_tmp3_ = TRUE;
						while (TRUE) {
							if (!_tmp3_) {
								owner++;
							}
							_tmp3_ = FALSE;
							if (!(owner < self->priv->_nblocks)) {
								break;
							}
							if (self->priv->_tags[(i * self->priv->_tags_length2) + owner]) {
								break;
							}
						}
					}
					length = self->priv->_blocks[owner];
					start = i - length;
					if (start >= 0) {
						gnonogram_region_remove_block_from_cell_to_end (self, owner, start, -1);
					}
					start = i + length;
					if (start < self->priv->_ncells) {
						gnonogram_region_remove_block_from_cell_to_end (self, owner, start, +1);
					}
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_free_cell_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	gint free_cells;
	gint _tmp1_;
	gint filled_cells;
	gint _tmp2_;
	gint completed_cells;
	gint to_locate;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	_tmp0_ = gnonogram_region_count_cell_state (self, CELL_STATE_UNKNOWN);
	free_cells = _tmp0_;
	if (free_cells == 0) {
		result = FALSE;
		return result;
	}
	_tmp1_ = gnonogram_region_count_cell_state (self, CELL_STATE_FILLED);
	filled_cells = _tmp1_;
	_tmp2_ = gnonogram_region_count_cell_state (self, CELL_STATE_COMPLETED);
	completed_cells = _tmp2_;
	to_locate = (self->priv->_block_total - filled_cells) - completed_cells;
	if (free_cells == to_locate) {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < self->priv->_ncells)) {
						break;
					}
					if (self->priv->_status[i] == CELL_STATE_UNKNOWN) {
						gnonogram_region_set_cell_complete (self, i);
					}
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					self->priv->_completed_blocks[i] = TRUE;
				}
			}
		}
		result = TRUE;
		return result;
	} else {
		if (to_locate == 0) {
			{
				gint i;
				i = 0;
				{
					gboolean _tmp5_;
					_tmp5_ = TRUE;
					while (TRUE) {
						if (!_tmp5_) {
							i++;
						}
						_tmp5_ = FALSE;
						if (!(i < self->priv->_ncells)) {
							break;
						}
						if (self->priv->_status[i] == CELL_STATE_UNKNOWN) {
							gnonogram_region_set_cell_empty (self, i);
						}
					}
				}
			}
			result = TRUE;
			return result;
		}
	}
	result = FALSE;
	return result;
}


static gboolean gnonogram_region_do_edge (Gnonogram_region* self, gint direction) {
	gboolean result = FALSE;
	gint idx = 0;
	gint blocknum = 0;
	gint limit = 0;
	gboolean changed;
	gboolean dir;
	gboolean _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	dir = direction == GNONOGRAM_REGION_FORWARDS;
	if (dir) {
		idx = 0;
		blocknum = 0;
		limit = self->priv->_ncells;
	} else {
		idx = self->priv->_ncells - 1;
		blocknum = self->priv->_nblocks - 1;
		limit = -1;
	}
	_tmp0_ = gnonogram_region_find_edge (self, &idx, &blocknum, limit, direction);
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	if (self->priv->_status[idx] == CELL_STATE_FILLED) {
		gnonogram_region_set_block_complete_and_cap (self, blocknum, idx, direction);
		changed = TRUE;
	} else {
		gint edge_start;
		gint fill_start;
		gint blength;
		gint _tmp1_ = 0;
		gint blocklimit;
		gboolean _tmp2_;
		edge_start = idx;
		fill_start = -1;
		blength = self->priv->_blocks[blocknum];
		if (dir) {
			_tmp1_ = idx + blength;
		} else {
			_tmp1_ = idx - blength;
		}
		blocklimit = _tmp1_;
		_tmp2_ = gnonogram_region_skip_while_not_status (self, CELL_STATE_FILLED, &idx, blocklimit, direction);
		if (_tmp2_) {
			fill_start = idx;
			while (TRUE) {
				if (!(idx != blocklimit)) {
					break;
				}
				if (self->priv->_status[idx] == CELL_STATE_UNKNOWN) {
					gnonogram_region_set_cell_owner (self, idx, blocknum, TRUE, FALSE);
					changed = TRUE;
				}
				if (dir) {
					idx++;
				} else {
					idx--;
				}
			}
			while (TRUE) {
				gboolean _tmp3_ = FALSE;
				if (idx != blocklimit) {
					_tmp3_ = self->priv->_status[idx] == CELL_STATE_FILLED;
				} else {
					_tmp3_ = FALSE;
				}
				if (!_tmp3_) {
					break;
				}
				gnonogram_region_set_cell_owner (self, idx, blocknum, TRUE, FALSE);
				gnonogram_region_set_cell_empty (self, edge_start);
				changed = TRUE;
				if (dir) {
					idx++;
					edge_start++;
				} else {
					idx--;
					edge_start--;
				}
			}
			if (fill_start > 0) {
				gint _tmp4_ = 0;
				gboolean _tmp5_ = FALSE;
				if (dir) {
					_tmp4_ = fill_start + blength;
				} else {
					_tmp4_ = fill_start - blength;
				}
				idx = _tmp4_;
				if (idx >= 0) {
					_tmp5_ = idx < self->priv->_ncells;
				} else {
					_tmp5_ = FALSE;
				}
				if (_tmp5_) {
					gnonogram_region_remove_block_from_cell_to_end (self, blocknum, idx, direction);
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_find_edge (Gnonogram_region* self, gint* idx, gint* blocknum, gint limit, gint direction) {
	gboolean result = FALSE;
	gboolean dir;
	gboolean found;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	dir = direction == GNONOGRAM_REGION_FORWARDS;
	found = FALSE;
	{
		gint i;
		i = *idx;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					if (dir) {
						gint _tmp2_;
						_tmp2_ = i;
						i = _tmp2_ + 1;
						_tmp1_ = _tmp2_;
					} else {
						gint _tmp3_;
						_tmp3_ = i;
						i = _tmp3_ - 1;
						_tmp1_ = _tmp3_;
					}
				}
				_tmp0_ = FALSE;
				if (dir) {
					_tmp4_ = i < limit;
				} else {
					_tmp4_ = i > limit;
				}
				if (!_tmp4_) {
					break;
				}
				if (self->priv->_status[i] == CELL_STATE_EMPTY) {
					continue;
				}
				if (self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr]) {
					gint _tmp5_ = 0;
					if (dir) {
						_tmp5_ = (i + self->priv->_blocks[*blocknum]) - 1;
					} else {
						_tmp5_ = (i - self->priv->_blocks[*blocknum]) + 1;
					}
					i = _tmp5_;
					if (dir) {
						(*blocknum)++;
					} else {
						(*blocknum)--;
					}
					continue;
				}
				*idx = i;
				found = TRUE;
				break;
			}
		}
	}
	result = found;
	return result;
}


static gboolean gnonogram_region_fix_blocks_in_ranges (Gnonogram_region* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	gint empty;
	gint _tmp1_;
	gint* _tmp2_ = NULL;
	gint* blocks;
	gint blocks_length1;
	gint _blocks_size_;
	gint bl;
	gint* _tmp3_ = NULL;
	gint* block_start;
	gint block_start_length1;
	gint block_start_length2;
	gint* _tmp4_ = NULL;
	gint* block_end;
	gint block_end_length1;
	gint block_end_length2;
	gint _tmp5_;
	gint nranges;
	gint rng;
	gint offset;
	gint length;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	_tmp0_ = gnonogram_region_count_cell_state (self, CELL_STATE_EMPTY);
	empty = _tmp0_;
	if (self->priv->_empty >= empty) {
		result = FALSE;
		return result;
	}
	_tmp2_ = gnonogram_region_blocks_available (self, &_tmp1_);
	blocks = _tmp2_;
	blocks_length1 = _tmp1_;
	_blocks_size_ = _tmp1_;
	bl = blocks_length1;
	_tmp3_ = g_new0 (gint, bl * 2);
	block_start = _tmp3_;
	block_start_length1 = bl;
	block_start_length2 = 2;
	_tmp4_ = g_new0 (gint, bl * 2);
	block_end = _tmp4_;
	block_end_length1 = bl;
	block_end_length2 = 2;
	_tmp5_ = gnonogram_region_count_available_ranges (self, FALSE);
	nranges = _tmp5_;
	if (nranges < 2) {
		result = FALSE;
		block_end = (g_free (block_end), NULL);
		block_start = (g_free (block_start), NULL);
		blocks = (g_free (blocks), NULL);
		return result;
	}
	rng = 0;
	offset = 0;
	length = 0;
	{
		gint b;
		b = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				if (!_tmp6_) {
					b++;
				}
				_tmp6_ = FALSE;
				if (!(b < bl)) {
					break;
				}
				length = self->priv->_blocks[blocks[b]];
				if (self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1] < (length + offset)) {
					rng++;
					offset = 0;
					while (TRUE) {
						gboolean _tmp7_ = FALSE;
						if (rng < nranges) {
							_tmp7_ = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1] < length;
						} else {
							_tmp7_ = FALSE;
						}
						if (!_tmp7_) {
							break;
						}
						rng++;
					}
					if (rng >= nranges) {
						result = FALSE;
						block_end = (g_free (block_end), NULL);
						block_start = (g_free (block_start), NULL);
						blocks = (g_free (blocks), NULL);
						return result;
					}
				}
				block_start[(b * block_start_length2) + 0] = rng;
				block_start[(b * block_start_length2) + 1] = offset;
				offset = offset + (length + 1);
			}
		}
	}
	rng = nranges - 1;
	offset = 0;
	{
		gint b;
		b = bl - 1;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				if (!_tmp8_) {
					b--;
				}
				_tmp8_ = FALSE;
				if (!(b >= 0)) {
					break;
				}
				length = self->priv->_blocks[blocks[b]];
				if (self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1] < (length + offset)) {
					rng--;
					offset = 0;
					while (TRUE) {
						gboolean _tmp9_ = FALSE;
						if (rng >= 0) {
							_tmp9_ = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1] < length;
						} else {
							_tmp9_ = FALSE;
						}
						if (!_tmp9_) {
							break;
						}
						rng--;
					}
					if (rng < 0) {
						result = FALSE;
						block_end = (g_free (block_end), NULL);
						block_start = (g_free (block_start), NULL);
						blocks = (g_free (blocks), NULL);
						return result;
					}
				}
				block_end[(b * block_end_length2) + 0] = rng;
				block_end[(b * block_end_length2) + 1] = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1] - offset;
				offset = offset + (length + 1);
			}
		}
	}
	{
		gint b;
		b = 0;
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				gint start;
				if (!_tmp10_) {
					b++;
				}
				_tmp10_ = FALSE;
				if (!(b < bl)) {
					break;
				}
				rng = block_start[(b * block_start_length2) + 0];
				offset = block_start[(b * block_start_length2) + 1];
				start = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 0];
				if (rng == block_end[(b * block_end_length2) + 0]) {
					length = block_end[(b * block_end_length2) + 1] - block_start[(b * block_start_length2) + 1];
					gnonogram_region_fix_block_in_range (self, blocks[b], start + offset, length);
				}
				if (offset > 1) {
					gnonogram_region_remove_block_from_range (self, blocks[b], start, offset - 1, 1);
				}
				{
					gint r;
					r = 0;
					{
						gboolean _tmp11_;
						_tmp11_ = TRUE;
						while (TRUE) {
							if (!_tmp11_) {
								r++;
							}
							_tmp11_ = FALSE;
							if (!(r < block_start[(b * block_start_length2) + 0])) {
								break;
							}
							gnonogram_region_remove_block_from_range (self, blocks[b], self->priv->_ranges[(r * self->priv->_ranges_length2) + 0], self->priv->_ranges[(r * self->priv->_ranges_length2) + 1], 1);
						}
					}
				}
				rng = block_end[(b * block_end_length2) + 0];
				start = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 0] + block_end[(b * block_end_length2) + 1];
				length = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1] - block_end[(b * block_end_length2) + 1];
				if (length > 0) {
					gnonogram_region_remove_block_from_range (self, blocks[b], start, length, 1);
				}
				{
					gint r;
					r = nranges - 1;
					{
						gboolean _tmp12_;
						_tmp12_ = TRUE;
						while (TRUE) {
							if (!_tmp12_) {
								r--;
							}
							_tmp12_ = FALSE;
							if (!(r > block_end[(b * block_end_length2) + 0])) {
								break;
							}
							gnonogram_region_remove_block_from_range (self, blocks[b], self->priv->_ranges[(r * self->priv->_ranges_length2) + 0], self->priv->_ranges[(r * self->priv->_ranges_length2) + 1], 1);
						}
					}
				}
			}
		}
	}
	result = TRUE;
	block_end = (g_free (block_end), NULL);
	block_start = (g_free (block_start), NULL);
	blocks = (g_free (blocks), NULL);
	return result;
}


static gboolean gnonogram_region_capped_range_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gint start;
	gint length;
	gint idx;
	gint _tmp0_;
	gint nranges;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	start = 0;
	length = 0;
	idx = 0;
	_tmp0_ = gnonogram_region_count_capped_ranges (self);
	nranges = _tmp0_;
	if (nranges == 0) {
		result = FALSE;
		return result;
	}
	{
		gint rng;
		rng = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					rng++;
				}
				_tmp1_ = FALSE;
				if (!(rng < nranges)) {
					break;
				}
				start = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 0];
				length = self->priv->_ranges[(rng * self->priv->_ranges_length2) + 1];
				{
					gboolean _tmp2_;
					idx = start;
					_tmp2_ = TRUE;
					while (TRUE) {
						gint count;
						if (!_tmp2_) {
							idx++;
						}
						_tmp2_ = FALSE;
						if (!(idx < (start + length))) {
							break;
						}
						count = 0;
						{
							gint b;
							b = 0;
							{
								gboolean _tmp3_;
								_tmp3_ = TRUE;
								while (TRUE) {
									if (!_tmp3_) {
										b++;
									}
									_tmp3_ = FALSE;
									if (!(b < self->priv->_nblocks)) {
										break;
									}
									if (self->priv->_tags[(idx * self->priv->_tags_length2) + b]) {
										count++;
										if (self->priv->_blocks[b] != length) {
											self->priv->_tags[(idx * self->priv->_tags_length2) + b] = FALSE;
											count--;
										}
									}
								}
							}
						}
						if (count == 0) {
							gnonogram_region_record_error (self, "capped range audit", "filled cell with no owners", FALSE);
							result = FALSE;
							return result;
						}
					}
				}
			}
		}
	}
	result = FALSE;
	return result;
}


static gboolean gnonogram_region_skip_while_not_status (Gnonogram_region* self, CellState cs, gint* idx, gint limit, gint direction) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (direction == GNONOGRAM_REGION_FORWARDS) {
		_tmp0_ = (*idx) >= limit;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	} else {
		gboolean _tmp1_ = FALSE;
		if (direction == GNONOGRAM_REGION_BACKWARDS) {
			_tmp1_ = (*idx) <= limit;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			result = FALSE;
			return result;
		}
	}
	{
		gint i;
		i = *idx;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					i = i + direction;
				}
				_tmp2_ = FALSE;
				if (!(i != limit)) {
					break;
				}
				if (self->priv->_status[i] == cs) {
					*idx = i;
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}


static gint gnonogram_region_count_next_state (Gnonogram_region* self, CellState cs, gint idx, gboolean forwards) {
	gint result = 0;
	gint count;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	if (forwards) {
		_tmp0_ = idx >= 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			if (idx < self->priv->_ncells) {
				_tmp1_ = self->priv->_status[idx] == cs;
			} else {
				_tmp1_ = FALSE;
			}
			if (!_tmp1_) {
				break;
			}
			count++;
			idx++;
		}
	} else {
		gboolean _tmp2_ = FALSE;
		if (!forwards) {
			_tmp2_ = idx < self->priv->_ncells;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			while (TRUE) {
				gboolean _tmp3_ = FALSE;
				if (idx >= 0) {
					_tmp3_ = self->priv->_status[idx] == cs;
				} else {
					_tmp3_ = FALSE;
				}
				if (!_tmp3_) {
					break;
				}
				count++;
				idx--;
			}
		} else {
			gchar* _tmp4_;
			gchar* _tmp5_;
			self->_in_error = TRUE;
			_tmp4_ = g_strdup ("count_next_state idx invalid\n");
			_tmp5_ = _tmp4_;
			_g_free0 (self->message);
			self->message = _tmp5_;
		}
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_next_owner (Gnonogram_region* self, gint owner, gint idx) {
	gint result = 0;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	if (idx >= 0) {
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			gboolean _tmp1_ = FALSE;
			if (idx < self->priv->_ncells) {
				_tmp1_ = self->priv->_tags[(idx * self->priv->_tags_length2) + owner];
			} else {
				_tmp1_ = FALSE;
			}
			if (_tmp1_) {
				_tmp0_ = !self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
			} else {
				_tmp0_ = FALSE;
			}
			if (!_tmp0_) {
				break;
			}
			count++;
			idx++;
		}
	} else {
		gchar* _tmp2_;
		gchar* _tmp3_;
		self->_in_error = TRUE;
		_tmp2_ = g_strdup ("count_next_owner idx negative\n");
		_tmp3_ = _tmp2_;
		_g_free0 (self->message);
		self->message = _tmp3_;
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_available_ranges (Gnonogram_region* self, gboolean not_empty) {
	gint result = 0;
	gint range;
	gint start;
	gint length;
	gint idx;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	range = 0;
	start = 0;
	length = 0;
	idx = 0;
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		if (idx < self->priv->_ncells) {
			_tmp0_ = self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		idx++;
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		if (!(idx < self->priv->_ncells)) {
			break;
		}
		length = 0;
		start = idx;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 0] = start;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 2] = 0;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 3] = 0;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			if (idx < self->priv->_ncells) {
				_tmp1_ = !self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
			} else {
				_tmp1_ = FALSE;
			}
			if (!_tmp1_) {
				break;
			}
			if (!self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
				self->priv->_ranges[(range * self->priv->_ranges_length2) + 2]++;
			} else {
				self->priv->_ranges[(range * self->priv->_ranges_length2) + 3]++;
			}
			idx++;
			length++;
		}
		if (not_empty) {
			_tmp2_ = self->priv->_ranges[(range * self->priv->_ranges_length2) + 2] == 0;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
		} else {
			self->priv->_ranges[(range * self->priv->_ranges_length2) + 1] = length;
			range++;
		}
		while (TRUE) {
			gboolean _tmp3_ = FALSE;
			if (idx < self->priv->_ncells) {
				_tmp3_ = self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
			} else {
				_tmp3_ = FALSE;
			}
			if (!_tmp3_) {
				break;
			}
			idx++;
		}
	}
	result = range;
	return result;
}


static gboolean gnonogram_region_check_nblocks (Gnonogram_region* self) {
	gboolean result = FALSE;
	gint count;
	gint idx;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	count = 0;
	idx = 0;
	while (TRUE) {
		if (!(idx < self->priv->_ncells)) {
			break;
		}
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			if (idx < self->priv->_ncells) {
				_tmp0_ = self->priv->_status[idx] == CELL_STATE_EMPTY;
			} else {
				_tmp0_ = FALSE;
			}
			if (!_tmp0_) {
				break;
			}
			idx++;
		}
		if (idx < self->priv->_ncells) {
			count++;
		} else {
			break;
		}
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			if (idx < self->priv->_ncells) {
				_tmp1_ = self->priv->_status[idx] != CELL_STATE_EMPTY;
			} else {
				_tmp1_ = FALSE;
			}
			if (!_tmp1_) {
				break;
			}
			idx++;
		}
	}
	if (count != self->priv->_nblocks) {
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		_tmp2_ = g_strdup_printf ("%i", count);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_strdup_printf ("%i", self->priv->_nblocks);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_strconcat ("Wrong number of blocks found ", _tmp3_, " should be ", _tmp5_, NULL);
		_tmp7_ = _tmp6_;
		gnonogram_region_record_error (self, "Check n_blocks", _tmp7_, FALSE);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp5_);
		_g_free0 (_tmp3_);
		result = FALSE;
		return result;
	} else {
		result = TRUE;
		return result;
	}
}


static gint gnonogram_region_count_capped_ranges (Gnonogram_region* self) {
	gint result = 0;
	gint range;
	gint start;
	gint length;
	gint idx;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	range = 0;
	start = 0;
	length = 0;
	idx = 0;
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		if (self->priv->_status[idx] != CELL_STATE_FILLED) {
			_tmp0_ = idx < self->priv->_ncells;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		idx++;
	}
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		if (!(idx < self->priv->_ncells)) {
			break;
		}
		length = 0;
		start = idx;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 0] = start;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 2] = 0;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 3] = 0;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			if (self->priv->_status[idx] == CELL_STATE_FILLED) {
				_tmp1_ = idx < self->priv->_ncells;
			} else {
				_tmp1_ = FALSE;
			}
			if (!_tmp1_) {
				break;
			}
			idx++;
			length++;
		}
		if (start == 0) {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = self->priv->_status[start - 1] == CELL_STATE_EMPTY;
		}
		if (_tmp3_) {
			gboolean _tmp4_ = FALSE;
			if (idx == self->priv->_ncells) {
				_tmp4_ = TRUE;
			} else {
				_tmp4_ = self->priv->_status[idx] == CELL_STATE_EMPTY;
			}
			_tmp2_ = _tmp4_;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			self->priv->_ranges[(range * self->priv->_ranges_length2) + 1] = length;
			range++;
		}
		while (TRUE) {
			gboolean _tmp5_ = FALSE;
			if (self->priv->_status[idx] != CELL_STATE_FILLED) {
				_tmp5_ = idx < self->priv->_ncells;
			} else {
				_tmp5_ = FALSE;
			}
			if (!_tmp5_) {
				break;
			}
			idx++;
		}
	}
	result = range;
	return result;
}


static gint gnonogram_region_count_owners_and_empty (Gnonogram_region* self, gint cell) {
	gint result = 0;
	gint count;
	gboolean _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	_tmp0_ = gnonogram_region_invalid_data (self, cell, 0, 1);
	if (_tmp0_) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		self->_in_error = TRUE;
		_tmp1_ = g_strdup ("count_owners_and_empty invalid data\n");
		_tmp2_ = _tmp1_;
		_g_free0 (self->message);
		self->message = _tmp2_;
	} else {
		{
			gint j;
			j = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						j++;
					}
					_tmp3_ = FALSE;
					if (!(j < self->priv->_nblocks)) {
						break;
					}
					if (self->priv->_tags[(cell * self->priv->_tags_length2) + j]) {
						count++;
					}
				}
			}
		}
		if (self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
			count++;
		}
	}
	if (count == 0) {
		gchar* _tmp4_;
		gchar* _tmp5_;
		self->_in_error = TRUE;
		_tmp4_ = g_strdup ("count owners and empty - count is zero\n");
		_tmp5_ = _tmp4_;
		_g_free0 (self->message);
		self->message = _tmp5_;
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_cell_state (Gnonogram_region* self, CellState cs) {
	gint result = 0;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_status[i] == cs) {
					count++;
				}
			}
		}
	}
	result = count;
	return result;
}


static void _vala_array_add8 (gint** array, int* length, int* size, gint value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gint, *array, *size);
	}
	(*array)[(*length)++] = value;
}


static gint* gnonogram_region_blocks_available (Gnonogram_region* self, int* result_length1) {
	gint* result = NULL;
	gint* _tmp0_ = NULL;
	gint* blocks;
	gint blocks_length1;
	gint _blocks_size_;
	gint* _tmp2_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), NULL);
	_tmp0_ = g_new0 (gint, 0);
	blocks = _tmp0_;
	blocks_length1 = 0;
	_blocks_size_ = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (!self->priv->_completed_blocks[i]) {
					_vala_array_add8 (&blocks, &blocks_length1, &_blocks_size_, i);
				}
			}
		}
	}
	_tmp2_ = blocks;
	*result_length1 = blocks_length1;
	result = _tmp2_;
	return result;
}


static gboolean gnonogram_region_same_owner (Gnonogram_region* self, gint cell1, gint cell2, gint* owner) {
	gint _owner = 0;
	gboolean result = FALSE;
	gint count;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	count = 0;
	_owner = 0;
	if (cell1 < 0) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = cell1 >= self->priv->_ncells;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = cell2 < 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = cell2 >= self->priv->_ncells;
	}
	if (_tmp0_) {
		gchar* _tmp3_;
		gchar* _tmp4_;
		self->_in_error = TRUE;
		_tmp3_ = g_strdup ("same_owner cell - out of range\n");
		_tmp4_ = _tmp3_;
		_g_free0 (self->message);
		self->message = _tmp4_;
	} else {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					gboolean _tmp6_ = FALSE;
					if (!_tmp5_) {
						i++;
					}
					_tmp5_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					if (self->priv->_tags[(cell1 * self->priv->_tags_length2) + i] != self->priv->_tags[(cell2 * self->priv->_tags_length2) + i]) {
						_tmp6_ = TRUE;
					} else {
						_tmp6_ = count > 1;
					}
					if (_tmp6_) {
						count = 0;
						break;
					} else {
						if (self->priv->_tags[(cell1 * self->priv->_tags_length2) + i]) {
							count++;
							_owner = i;
						}
					}
				}
			}
		}
	}
	result = count == 1;
	if (owner) {
		*owner = _owner;
	}
	return result;
}


static gboolean gnonogram_region_one_owner (Gnonogram_region* self, gint cell) {
	gboolean result = FALSE;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	count = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_tags[(cell * self->priv->_tags_length2) + i]) {
					count++;
				}
				if (count > 1) {
					break;
				}
			}
		}
	}
	result = count == 1;
	return result;
}


static gboolean gnonogram_region_fix_block_in_range (Gnonogram_region* self, gint block, gint start, gint length) {
	gboolean result = FALSE;
	gboolean changed;
	gboolean _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	_tmp0_ = gnonogram_region_invalid_data (self, start, block, length);
	if (_tmp0_) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		self->_in_error = TRUE;
		_tmp1_ = g_strdup ("fix block in range - invalid data\n");
		_tmp2_ = _tmp1_;
		_g_free0 (self->message);
		self->message = _tmp2_;
	} else {
		gint block_length;
		gint freedom;
		block_length = self->priv->_blocks[block];
		freedom = length - block_length;
		if (freedom < 0) {
			gnonogram_region_record_error (self, "Fix block in range", "block longer than range", FALSE);
			result = FALSE;
			return result;
		}
		if (freedom < block_length) {
			if (freedom == 0) {
				gnonogram_region_set_block_complete_and_cap (self, block, start, 1);
				changed = TRUE;
			} else {
				gnonogram_region_set_range_owner (self, block, start + freedom, block_length - freedom, TRUE, FALSE);
			}
		}
	}
	result = changed;
	return result;
}


static gint gnonogram_region_find_largest_possible_in_cell (Gnonogram_region* self, gint cell) {
	gint result = 0;
	gint max_size;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	max_size = -1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (!self->priv->_tags[(cell * self->priv->_tags_length2) + i]) {
					continue;
				}
				if (self->priv->_blocks[i] <= max_size) {
					continue;
				}
				max_size = self->priv->_blocks[i];
			}
		}
	}
	result = max_size;
	return result;
}


static gint gnonogram_region_find_smallest_possible_in_cell (Gnonogram_region* self, gint cell) {
	gint result = 0;
	gint min_size;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	min_size = 9999;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (!self->priv->_tags[(cell * self->priv->_tags_length2) + i]) {
					continue;
				}
				if (self->priv->_blocks[i] >= min_size) {
					continue;
				}
				min_size = self->priv->_blocks[i];
			}
		}
	}
	if (min_size == 9999) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		self->_in_error = TRUE;
		_tmp1_ = g_strdup ("No blocks possible in filled cell");
		_tmp2_ = _tmp1_;
		_g_free0 (self->message);
		self->message = _tmp2_;
		result = 0;
		return result;
	}
	result = min_size;
	return result;
}


static void gnonogram_region_remove_block_from_cell_to_end (Gnonogram_region* self, gint block, gint start, gint direction) {
	gint _tmp0_ = 0;
	gint length;
	gint _tmp1_ = 0;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (direction > 0) {
		_tmp0_ = self->priv->_ncells - start;
	} else {
		_tmp0_ = start + 1;
	}
	length = _tmp0_;
	if (direction > 0) {
		_tmp1_ = start;
	} else {
		_tmp1_ = 0;
	}
	start = _tmp1_;
	gnonogram_region_remove_block_from_range (self, block, start, length, 1);
}


static void gnonogram_region_remove_block_from_range (Gnonogram_region* self, gint block, gint start, gint length, gint direction) {
	gboolean _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (direction < 0) {
		start = (start - length) + 1;
	}
	_tmp0_ = gnonogram_region_invalid_data (self, start, block, length);
	if (_tmp0_) {
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		self->_in_error = TRUE;
		_tmp1_ = g_strdup_printf ("%i", start);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_strdup_printf ("%i", block);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strdup_printf ("%i", length);
		_tmp6_ = _tmp5_;
		_tmp7_ = g_strconcat ("remove block from range - invalid data- start ", _tmp2_, " block ", _tmp4_, " length ", _tmp6_, "\n", NULL);
		_tmp8_ = _tmp7_;
		_g_free0 (self->message);
		self->message = _tmp8_;
		_g_free0 (_tmp6_);
		_g_free0 (_tmp4_);
		_g_free0 (_tmp2_);
	} else {
		{
			gint i;
			i = start;
			{
				gboolean _tmp9_;
				_tmp9_ = TRUE;
				while (TRUE) {
					if (!_tmp9_) {
						i++;
					}
					_tmp9_ = FALSE;
					if (!(i < (start + length))) {
						break;
					}
					self->priv->_tags[(i * self->priv->_tags_length2) + block] = FALSE;
				}
			}
		}
	}
}


static void gnonogram_region_set_block_complete_and_cap (Gnonogram_region* self, gint block, gint start, gint direction) {
	gint length;
	gboolean _tmp0_;
	gboolean _tmp3_ = FALSE;
	gint l = 0;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	length = self->priv->_blocks[block];
	if (direction < 0) {
		start = (start - length) + 1;
	}
	_tmp0_ = gnonogram_region_invalid_data (self, start, block, length);
	if (_tmp0_) {
		gchar* _tmp1_;
		gchar* _tmp2_;
		self->_in_error = TRUE;
		_tmp1_ = g_strdup ("set_block_complete_and_cap - invalid data\n");
		_tmp2_ = _tmp1_;
		_g_free0 (self->message);
		self->message = _tmp2_;
		return;
	}
	if (self->priv->_completed_blocks[block] == TRUE) {
		_tmp3_ = self->priv->_tags[(start * self->priv->_tags_length2) + block] == FALSE;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gchar* _tmp4_;
		gchar* _tmp5_;
		self->_in_error = TRUE;
		_tmp4_ = g_strdup ("set_block_complete_and_cap - contradiction - completed but not filled\n");
		_tmp5_ = _tmp4_;
		_g_free0 (self->message);
		self->message = _tmp5_;
		return;
	}
	self->priv->_completed_blocks[block] = TRUE;
	gnonogram_region_set_range_owner (self, block, start, length, TRUE, FALSE);
	if (start > 0) {
		gnonogram_region_set_cell_empty (self, start - 1);
	}
	if ((start + length) < self->priv->_ncells) {
		gnonogram_region_set_cell_empty (self, start + length);
	}
	{
		gint cell;
		cell = start;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				if (!_tmp6_) {
					cell++;
				}
				_tmp6_ = FALSE;
				if (!(cell < (start + length))) {
					break;
				}
				gnonogram_region_set_cell_complete (self, cell);
			}
		}
	}
	if (block > 1) {
		l = 0;
		{
			gint bl;
			bl = block - 2;
			{
				gboolean _tmp7_;
				_tmp7_ = TRUE;
				while (TRUE) {
					if (!_tmp7_) {
						bl--;
					}
					_tmp7_ = FALSE;
					if (!(bl >= 0)) {
						break;
					}
					l = (l + self->priv->_blocks[bl + 1]) + 1;
					gnonogram_region_remove_block_from_range (self, bl, start - 2, l, -1);
				}
			}
		}
	}
	if (block < (self->priv->_nblocks - 2)) {
		l = 0;
		{
			gint bl;
			bl = block + 2;
			{
				gboolean _tmp8_;
				_tmp8_ = TRUE;
				while (TRUE) {
					if (!_tmp8_) {
						bl++;
					}
					_tmp8_ = FALSE;
					if (!(bl <= (self->priv->_nblocks - 1))) {
						break;
					}
					l = (l + self->priv->_blocks[bl - 1]) + 1;
					gnonogram_region_remove_block_from_range (self, bl, (start + length) + 1, l, 1);
				}
			}
		}
	}
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


static gboolean gnonogram_region_set_range_owner (Gnonogram_region* self, gint owner, gint start, gint length, gboolean exclusive, gboolean can_be_empty) {
	gboolean result = FALSE;
	gboolean changed;
	gboolean _tmp10_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_debug) {
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp0_ = g_strdup_printf ("%i", start);
		_tmp1_ = _tmp0_;
		_tmp2_ = g_strdup_printf ("%i", length);
		_tmp3_ = _tmp2_;
		_tmp4_ = bool_to_string (exclusive);
		_tmp5_ = _tmp4_;
		_tmp6_ = bool_to_string (can_be_empty);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat ("set range owner start=", _tmp1_, " length=", _tmp3_, " exclusive ", _tmp5_, ", can be empty ", _tmp7_, "\n", NULL);
		_tmp9_ = _tmp8_;
		fprintf (stdout, "%s", _tmp9_);
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp5_);
		_g_free0 (_tmp3_);
		_g_free0 (_tmp1_);
	}
	changed = FALSE;
	_tmp10_ = gnonogram_region_invalid_data (self, start, owner, length);
	if (_tmp10_) {
		gchar* _tmp11_;
		gchar* _tmp12_;
		self->_in_error = TRUE;
		_tmp11_ = g_strdup ("set_range_owner - invalid data\n");
		_tmp12_ = _tmp11_;
		_g_free0 (self->message);
		self->message = _tmp12_;
		result = FALSE;
		return result;
	} else {
		gint block_length;
		block_length = self->priv->_blocks[owner];
		{
			gint cell;
			cell = start;
			{
				gboolean _tmp13_;
				_tmp13_ = TRUE;
				while (TRUE) {
					gboolean _tmp14_ = FALSE;
					gboolean _tmp15_;
					if (!_tmp13_) {
						cell++;
					}
					_tmp13_ = FALSE;
					if (!(cell < (start + length))) {
						break;
					}
					_tmp15_ = gnonogram_region_set_cell_owner (self, cell, owner, exclusive, can_be_empty);
					if (_tmp15_) {
						_tmp14_ = TRUE;
					} else {
						_tmp14_ = changed;
					}
					changed = _tmp14_;
				}
			}
		}
		if (exclusive) {
			gboolean _tmp16_ = FALSE;
			gint _tmp19_;
			gint bstart;
			gint _tmp20_;
			gint bend;
			gint earliest_end;
			gint latest_start;
			if (block_length < length) {
				_tmp16_ = !can_be_empty;
			} else {
				_tmp16_ = FALSE;
			}
			if (_tmp16_) {
				gchar* _tmp17_;
				gchar* _tmp18_;
				self->_in_error = TRUE;
				_tmp17_ = g_strdup ("set_range_owner - contradiction - range too big for owner\n");
				_tmp18_ = _tmp17_;
				_g_free0 (self->message);
				self->message = _tmp18_;
				result = FALSE;
				return result;
			}
			_tmp19_ = MIN (start - 1, (start + length) - block_length);
			bstart = _tmp19_;
			if (bstart >= 0) {
				gnonogram_region_remove_block_from_cell_to_end (self, owner, bstart - 1, -1);
			}
			_tmp20_ = MAX (start + length, start + block_length);
			bend = _tmp20_;
			if (bend < self->priv->_ncells) {
				gnonogram_region_remove_block_from_cell_to_end (self, owner, bend, 1);
			}
			earliest_end = start + length;
			{
				gint bl;
				bl = self->priv->_nblocks - 1;
				{
					gboolean _tmp21_;
					_tmp21_ = TRUE;
					while (TRUE) {
						if (!_tmp21_) {
							bl--;
						}
						_tmp21_ = FALSE;
						if (!(bl > owner)) {
							break;
						}
						gnonogram_region_remove_block_from_cell_to_end (self, bl, earliest_end, -1);
					}
				}
			}
			latest_start = start - 1;
			{
				gint bl;
				bl = 0;
				{
					gboolean _tmp22_;
					_tmp22_ = TRUE;
					while (TRUE) {
						if (!_tmp22_) {
							bl++;
						}
						_tmp22_ = FALSE;
						if (!(bl < owner)) {
							break;
						}
						gnonogram_region_remove_block_from_cell_to_end (self, bl, latest_start, 1);
					}
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_set_cell_owner (Gnonogram_region* self, gint cell, gint owner, gboolean exclusive, gboolean can_be_empty) {
	gboolean result = FALSE;
	gboolean changed;
	gboolean _tmp10_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_debug) {
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp0_ = g_strdup_printf ("%i", cell);
		_tmp1_ = _tmp0_;
		_tmp2_ = g_strdup_printf ("%i", owner);
		_tmp3_ = _tmp2_;
		_tmp4_ = bool_to_string (exclusive);
		_tmp5_ = _tmp4_;
		_tmp6_ = bool_to_string (can_be_empty);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat ("set cell owner cell=", _tmp1_, " owner=", _tmp3_, " exclusive=", _tmp5_, ", can be empty ", _tmp7_, "\n", NULL);
		_tmp9_ = _tmp8_;
		fprintf (stdout, "%s", _tmp9_);
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		_g_free0 (_tmp5_);
		_g_free0 (_tmp3_);
		_g_free0 (_tmp1_);
	}
	changed = FALSE;
	_tmp10_ = gnonogram_region_invalid_data (self, cell, owner, 1);
	if (_tmp10_) {
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		gchar* _tmp13_ = NULL;
		gchar* _tmp14_;
		self->_in_error = TRUE;
		_tmp11_ = g_strdup_printf ("%i", cell);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_strconcat ("set_cell_owner - cell ", _tmp12_, " invalid data\n", NULL);
		_tmp14_ = _tmp13_;
		_g_free0 (self->message);
		self->message = _tmp14_;
		_g_free0 (_tmp12_);
	} else {
		if (self->priv->_status[cell] == CELL_STATE_EMPTY) {
		} else {
			gboolean _tmp15_ = FALSE;
			if (self->priv->_status[cell] == CELL_STATE_COMPLETED) {
				_tmp15_ = self->priv->_tags[(cell * self->priv->_tags_length2) + owner] == FALSE;
			} else {
				_tmp15_ = FALSE;
			}
			if (_tmp15_) {
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_;
				gchar* _tmp18_ = NULL;
				gchar* _tmp19_;
				_tmp16_ = g_strdup_printf ("%i", cell);
				_tmp17_ = _tmp16_;
				_tmp18_ = g_strconcat ("contradiction cell ", _tmp17_, " filled but cannot be owner", NULL);
				_tmp19_ = _tmp18_;
				gnonogram_region_record_error (self, "set_cell_owner", _tmp19_, FALSE);
				_g_free0 (_tmp19_);
				_g_free0 (_tmp17_);
			} else {
				if (exclusive) {
					{
						gint i;
						i = 0;
						{
							gboolean _tmp20_;
							_tmp20_ = TRUE;
							while (TRUE) {
								if (!_tmp20_) {
									i++;
								}
								_tmp20_ = FALSE;
								if (!(i < self->priv->_nblocks)) {
									break;
								}
								self->priv->_tags[(cell * self->priv->_tags_length2) + i] = FALSE;
							}
						}
					}
				}
				if (!can_be_empty) {
					self->priv->_status[cell] = CELL_STATE_FILLED;
					changed = TRUE;
					self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
				}
				self->priv->_tags[(cell * self->priv->_tags_length2) + owner] = TRUE;
			}
		}
	}
	result = changed;
	return result;
}


static void gnonogram_region_set_cell_empty (Gnonogram_region* self, gint cell) {
	gboolean _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	_tmp0_ = gnonogram_region_invalid_data (self, cell, 0, 1);
	if (_tmp0_) {
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp1_ = g_strdup_printf ("%i", cell);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_strconcat ("cell ", _tmp2_, " invalid data", NULL);
		_tmp4_ = _tmp3_;
		gnonogram_region_record_error (self, "set_cell_empty", _tmp4_, FALSE);
		_g_free0 (_tmp4_);
		_g_free0 (_tmp2_);
	} else {
		if (self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] == FALSE) {
			gchar* _tmp5_ = NULL;
			gchar* _tmp6_;
			gchar* _tmp7_ = NULL;
			gchar* _tmp8_;
			_tmp5_ = g_strdup_printf ("%i", cell);
			_tmp6_ = _tmp5_;
			_tmp7_ = g_strconcat ("cell ", _tmp6_, " cannot be empty", NULL);
			_tmp8_ = _tmp7_;
			gnonogram_region_record_error (self, "set_cell_empty", _tmp8_, FALSE);
			_g_free0 (_tmp8_);
			_g_free0 (_tmp6_);
		} else {
			gboolean _tmp9_;
			_tmp9_ = gnonogram_region_cell_filled (self, cell);
			if (_tmp9_) {
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_;
				_tmp10_ = g_strdup_printf ("%i", cell);
				_tmp11_ = _tmp10_;
				_tmp12_ = g_strconcat ("cell ", _tmp11_, " is filled", NULL);
				_tmp13_ = _tmp12_;
				gnonogram_region_record_error (self, "set_cell_empty", _tmp13_, FALSE);
				_g_free0 (_tmp13_);
				_g_free0 (_tmp11_);
			} else {
				{
					gint i;
					i = 0;
					{
						gboolean _tmp14_;
						_tmp14_ = TRUE;
						while (TRUE) {
							if (!_tmp14_) {
								i++;
							}
							_tmp14_ = FALSE;
							if (!(i < self->priv->_nblocks)) {
								break;
							}
							self->priv->_tags[(cell * self->priv->_tags_length2) + i] = FALSE;
						}
					}
				}
				self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = TRUE;
				self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
				self->priv->_status[cell] = CELL_STATE_EMPTY;
			}
		}
	}
}


static void gnonogram_region_set_cell_complete (Gnonogram_region* self, gint cell) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (self->priv->_status[cell] == CELL_STATE_EMPTY) {
		gchar* _tmp0_ = NULL;
		gchar* _tmp1_;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		_tmp0_ = g_strdup_printf ("%i", cell);
		_tmp1_ = _tmp0_;
		_tmp2_ = g_strconcat ("cell ", _tmp1_, " already set empty", NULL);
		_tmp3_ = _tmp2_;
		gnonogram_region_record_error (self, "set_cell_complete", _tmp3_, FALSE);
		_g_free0 (_tmp3_);
		_g_free0 (_tmp1_);
	}
	self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
	self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
	self->priv->_status[cell] = CELL_STATE_COMPLETED;
}


static gboolean gnonogram_region_invalid_data (Gnonogram_region* self, gint start, gint block, gint length) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (start < 0) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = start >= self->priv->_ncells;
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = length < 0;
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = (start + length) > self->priv->_ncells;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = block < 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = block >= self->priv->_nblocks;
	}
	result = _tmp0_;
	return result;
}


static gboolean gnonogram_region_cell_filled (Gnonogram_region* self, gint cell) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_status[cell] == CELL_STATE_FILLED) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = self->priv->_status[cell] == CELL_STATE_COMPLETED;
	}
	result = _tmp0_;
	return result;
}


static gboolean gnonogram_region_totals_changed (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint _tmp0_;
	gint unknown;
	gint _tmp1_;
	gint filled;
	gint _tmp2_;
	gint completed;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	_tmp0_ = gnonogram_region_count_cell_state (self, CELL_STATE_UNKNOWN);
	unknown = _tmp0_;
	_tmp1_ = gnonogram_region_count_cell_state (self, CELL_STATE_FILLED);
	filled = _tmp1_;
	_tmp2_ = gnonogram_region_count_cell_state (self, CELL_STATE_COMPLETED);
	completed = _tmp2_;
	if (self->priv->_unknown != unknown) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = self->priv->_filled != filled;
	}
	if (_tmp3_) {
		changed = TRUE;
		self->priv->_unknown = unknown;
		self->priv->_filled = filled;
		if ((filled + completed) > self->priv->_block_total) {
			gnonogram_region_record_error (self, "totals changed", "too many filled cells", FALSE);
		} else {
			if (unknown == 0) {
				self->_completed = TRUE;
				if ((filled + completed) < self->priv->_block_total) {
					gchar* _tmp4_ = NULL;
					gchar* _tmp5_;
					gchar* _tmp6_ = NULL;
					gchar* _tmp7_;
					_tmp4_ = g_strdup_printf ("%i", self->priv->_filled);
					_tmp5_ = _tmp4_;
					_tmp6_ = g_strconcat ("too few filled cells - ", _tmp5_, NULL);
					_tmp7_ = _tmp6_;
					gnonogram_region_record_error (self, "totals changed", _tmp7_, FALSE);
					_g_free0 (_tmp7_);
					_g_free0 (_tmp5_);
				} else {
					gnonogram_region_check_nblocks (self);
				}
			}
		}
	}
	result = changed;
	return result;
}


static void gnonogram_region_get_status (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	my2_dcell_array_get_array (self->_grid, self->_index, self->_is_column, &self->priv->_temp_status, &self->priv->_temp_status_length1, 0);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				switch (self->priv->_temp_status[i]) {
					case CELL_STATE_UNKNOWN:
					{
						self->priv->_status[i] = CELL_STATE_UNKNOWN;
						break;
					}
					case CELL_STATE_EMPTY:
					{
						if (!self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
							gchar* _tmp1_ = NULL;
							gchar* _tmp2_;
							gchar* _tmp3_ = NULL;
							gchar* _tmp4_;
							_tmp1_ = g_strdup_printf ("%i", i);
							_tmp2_ = _tmp1_;
							_tmp3_ = g_strconcat ("cell ", _tmp2_, " cannot be empty", NULL);
							_tmp4_ = _tmp3_;
							gnonogram_region_record_error (self, "get_status", _tmp4_, FALSE);
							_g_free0 (_tmp4_);
							_g_free0 (_tmp2_);
						} else {
							self->priv->_status[i] = CELL_STATE_EMPTY;
						}
						break;
					}
					case CELL_STATE_FILLED:
					{
						if (self->priv->_status[i] == CELL_STATE_EMPTY) {
							gchar* _tmp5_ = NULL;
							gchar* _tmp6_;
							gchar* _tmp7_ = NULL;
							gchar* _tmp8_;
							_tmp5_ = g_strdup_printf ("%i", i);
							_tmp6_ = _tmp5_;
							_tmp7_ = g_strconcat ("cell ", _tmp6_, " cannot be filled", NULL);
							_tmp8_ = _tmp7_;
							gnonogram_region_record_error (self, "get_status", _tmp8_, FALSE);
							_g_free0 (_tmp8_);
							_g_free0 (_tmp6_);
						} else {
							if (self->priv->_status[i] != CELL_STATE_COMPLETED) {
								self->priv->_status[i] = CELL_STATE_FILLED;
							}
						}
						break;
					}
					default:
					{
						break;
					}
				}
				gnonogram_region_status_to_tags (self);
			}
		}
	}
}


static void gnonogram_region_put_status (Gnonogram_region* self, gboolean debug) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (debug) {
		gnonogram_region_record_error (self, "DEBUG", "", TRUE);
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				CellState _tmp1_ = 0;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_status[i] == CELL_STATE_COMPLETED) {
					_tmp1_ = CELL_STATE_FILLED;
				} else {
					_tmp1_ = self->priv->_status[i];
				}
				self->priv->_temp_status[i] = _tmp1_;
			}
		}
	}
	my2_dcell_array_set_array (self->_grid, self->_index, self->_is_column, self->priv->_temp_status, self->priv->_temp_status_length1, 0);
}


static void gnonogram_region_status_to_tags (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				switch (self->priv->_status[i]) {
					case CELL_STATE_COMPLETED:
					{
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
						break;
					}
					case CELL_STATE_FILLED:
					{
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
						break;
					}
					case CELL_STATE_EMPTY:
					{
						{
							gint j;
							j = 0;
							{
								gboolean _tmp1_;
								_tmp1_ = TRUE;
								while (TRUE) {
									if (!_tmp1_) {
										j++;
									}
									_tmp1_ = FALSE;
									if (!(j < self->priv->_nblocks)) {
										break;
									}
									self->priv->_tags[(i * self->priv->_tags_length2) + j] = FALSE;
								}
							}
						}
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = TRUE;
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
						break;
					}
					default:
					{
						break;
					}
				}
			}
		}
	}
}


static gboolean gnonogram_region_tags_to_status (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp1_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_status[i] != CELL_STATE_UNKNOWN) {
					continue;
				}
				if (!self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
					self->priv->_status[i] = CELL_STATE_FILLED;
					changed = TRUE;
					continue;
				}
				_tmp1_ = gnonogram_region_count_owners_and_empty (self, i);
				if (_tmp1_ > 1) {
					continue;
				}
				changed = TRUE;
				if (self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
					self->priv->_status[i] = CELL_STATE_EMPTY;
					self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
				} else {
					self->priv->_status[i] = CELL_STATE_FILLED;
				}
			}
		}
	}
	result = changed;
	return result;
}


static void gnonogram_region_record_error (Gnonogram_region* self, const gchar* method, const gchar* errmessage, gboolean debug) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	g_return_if_fail (method != NULL);
	g_return_if_fail (errmessage != NULL);
	if (debug) {
		GString* _tmp0_ = NULL;
		GString* sb;
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_;
		gchar* _tmp23_;
		_tmp0_ = g_string_new ("");
		sb = _tmp0_;
		g_string_append (sb, ":  ");
		if (self->_is_column) {
			_tmp1_ = "column";
		} else {
			_tmp1_ = "row";
		}
		g_string_append (sb, _tmp1_);
		_tmp2_ = g_strdup_printf ("%i", self->_index);
		_tmp3_ = _tmp2_;
		g_string_append (sb, _tmp3_);
		_g_free0 (_tmp3_);
		g_string_append (sb, " in method ");
		g_string_append (sb, method);
		g_string_append (sb, "\n");
		g_string_append (sb, errmessage);
		g_string_append (sb, "\nClue - ");
		{
			gint bl;
			bl = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					gchar* _tmp5_ = NULL;
					gchar* _tmp6_;
					gchar* _tmp7_;
					if (!_tmp4_) {
						bl++;
					}
					_tmp4_ = FALSE;
					if (!(bl < self->priv->_nblocks)) {
						break;
					}
					_tmp5_ = g_strdup_printf ("%i", self->priv->_blocks[bl]);
					_tmp6_ = _tmp5_;
					_tmp7_ = g_strconcat (_tmp6_, ",", NULL);
					g_string_append (sb, _tmp7_);
					_g_free0 (_tmp7_);
					_g_free0 (_tmp6_);
				}
			}
		}
		g_string_append (sb, "\n status before:\n");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp8_;
				_tmp8_ = TRUE;
				while (TRUE) {
					gchar* _tmp9_ = NULL;
					gchar* _tmp10_;
					if (!_tmp8_) {
						i++;
					}
					_tmp8_ = FALSE;
					if (!(i < self->priv->_ncells)) {
						break;
					}
					_tmp9_ = g_strdup_printf ("%i", (gint) self->priv->_temp_status[i]);
					_tmp10_ = _tmp9_;
					g_string_append (sb, _tmp10_);
					_g_free0 (_tmp10_);
				}
			}
		}
		g_string_append (sb, "\n status now:\n");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					gchar* _tmp12_ = NULL;
					gchar* _tmp13_;
					if (!_tmp11_) {
						i++;
					}
					_tmp11_ = FALSE;
					if (!(i < self->priv->_ncells)) {
						break;
					}
					_tmp12_ = g_strdup_printf ("%i", (gint) self->priv->_status[i]);
					_tmp13_ = _tmp12_;
					g_string_append (sb, _tmp13_);
					_g_free0 (_tmp13_);
				}
			}
		}
		g_string_append (sb, "Tags:\n");
		{
			gint i;
			i = 0;
			{
				gboolean _tmp14_;
				_tmp14_ = TRUE;
				while (TRUE) {
					gchar* _tmp15_ = NULL;
					gchar* _tmp16_;
					gchar* _tmp17_ = NULL;
					gchar* _tmp18_;
					if (!_tmp14_) {
						i++;
					}
					_tmp14_ = FALSE;
					if (!(i < self->priv->_ncells)) {
						break;
					}
					_tmp15_ = g_strdup_printf ("%i", i);
					_tmp16_ = _tmp15_;
					_tmp17_ = g_strconcat ("Cell ", _tmp16_, " ", NULL);
					_tmp18_ = _tmp17_;
					g_string_append (sb, _tmp18_);
					_g_free0 (_tmp18_);
					_g_free0 (_tmp16_);
					{
						gint j;
						j = 0;
						{
							gboolean _tmp19_;
							_tmp19_ = TRUE;
							while (TRUE) {
								const gchar* _tmp20_ = NULL;
								if (!_tmp19_) {
									j++;
								}
								_tmp19_ = FALSE;
								if (!(j < self->priv->_nblocks)) {
									break;
								}
								if (self->priv->_tags[(i * self->priv->_tags_length2) + j]) {
									_tmp20_ = "t";
								} else {
									_tmp20_ = "f";
								}
								g_string_append (sb, _tmp20_);
							}
						}
					}
					g_string_append (sb, " : ");
					{
						gint j;
						j = self->priv->_can_be_empty_ptr;
						{
							gboolean _tmp21_;
							_tmp21_ = TRUE;
							while (TRUE) {
								const gchar* _tmp22_ = NULL;
								if (!_tmp21_) {
									j++;
								}
								_tmp21_ = FALSE;
								if (!(j < (self->priv->_can_be_empty_ptr + 2))) {
									break;
								}
								if (self->priv->_tags[(i * self->priv->_tags_length2) + j]) {
									_tmp22_ = "t";
								} else {
									_tmp22_ = "f";
								}
								g_string_append (sb, _tmp22_);
							}
						}
					}
					g_string_append (sb, "\n");
				}
			}
		}
		_tmp23_ = g_strconcat (self->message, sb->str, NULL);
		_g_free0 (self->message);
		self->message = _tmp23_;
		_g_string_free0 (sb);
	} else {
		gchar* _tmp24_;
		gchar* _tmp25_;
		gchar* _tmp26_;
		_tmp24_ = g_strconcat (method, ": ", NULL);
		_tmp25_ = g_strconcat (_tmp24_, errmessage, NULL);
		_tmp26_ = g_strconcat (_tmp25_, "\n", NULL);
		_g_free0 (self->message);
		self->message = _tmp26_;
		_g_free0 (_tmp25_);
		_g_free0 (_tmp24_);
		self->_in_error = TRUE;
	}
}


void gnonogram_region_save_state (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				self->priv->_status_store[i] = self->priv->_status[i];
				{
					gint j;
					j = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							if (!_tmp1_) {
								j++;
							}
							_tmp1_ = FALSE;
							if (!(j < (self->priv->_nblocks + 2))) {
								break;
							}
							self->priv->_tags_store[(i * self->priv->_tags_store_length2) + j] = self->priv->_tags[(i * self->priv->_tags_length2) + j];
						}
					}
				}
			}
		}
	}
	{
		gint j;
		j = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					j++;
				}
				_tmp2_ = FALSE;
				if (!(j < self->priv->_nblocks)) {
					break;
				}
				self->priv->_completed_blocks_store[j] = self->priv->_completed_blocks[j];
			}
		}
	}
	self->priv->_completed_store = self->_completed;
	self->priv->_filled_store = self->priv->_filled;
	self->priv->_unknown_store = self->priv->_unknown;
	self->priv->_empty_store = self->priv->_empty;
}


void gnonogram_region_restore_state (Gnonogram_region* self) {
	gchar* _tmp3_;
	gchar* _tmp4_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				self->priv->_status[i] = self->priv->_status_store[i];
				{
					gint j;
					j = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							if (!_tmp1_) {
								j++;
							}
							_tmp1_ = FALSE;
							if (!(j < (self->priv->_nblocks + 2))) {
								break;
							}
							self->priv->_tags[(i * self->priv->_tags_length2) + j] = self->priv->_tags_store[(i * self->priv->_tags_store_length2) + j];
						}
					}
				}
			}
		}
	}
	{
		gint j;
		j = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					j++;
				}
				_tmp2_ = FALSE;
				if (!(j < self->priv->_nblocks)) {
					break;
				}
				self->priv->_completed_blocks[j] = self->priv->_completed_blocks_store[j];
			}
		}
	}
	self->_completed = self->priv->_completed_store;
	self->priv->_filled = self->priv->_filled_store;
	self->priv->_unknown = self->priv->_unknown_store;
	self->priv->_empty = self->priv->_empty_store;
	self->_in_error = FALSE;
	_tmp3_ = g_strdup ("");
	_tmp4_ = _tmp3_;
	_g_free0 (self->message);
	self->message = _tmp4_;
}


gint gnonogram_region_value_as_permute_region (Gnonogram_region* self) {
	gint result = 0;
	gint _tmp0_;
	gint navailable_ranges;
	gint block_extent;
	gint count;
	gint largest;
	gint pvalue;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	if (self->_completed) {
		result = 0;
		return result;
	}
	_tmp0_ = gnonogram_region_count_available_ranges (self, FALSE);
	navailable_ranges = _tmp0_;
	if (navailable_ranges != 1) {
		result = 0;
		return result;
	}
	block_extent = 0;
	count = 0;
	largest = 0;
	{
		gint b;
		b = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					b++;
				}
				_tmp1_ = FALSE;
				if (!(b < self->priv->_nblocks)) {
					break;
				}
				if (!self->priv->_completed_blocks[b]) {
					gint _tmp2_;
					block_extent = block_extent + self->priv->_blocks[b];
					count++;
					_tmp2_ = MAX (largest, self->priv->_blocks[b]);
					largest = _tmp2_;
				}
			}
		}
	}
	pvalue = (largest - 1) * block_extent;
	if (count == 1) {
		pvalue = pvalue * 2;
	}
	result = pvalue;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


Gnonogram_permutor* gnonogram_region_get_permutor (Gnonogram_region* self, gint* start) {
	gint _start = 0;
	Gnonogram_permutor* result = NULL;
	gchar* _tmp0_;
	gchar* clue;
	gint _tmp1_;
	gint* _tmp2_ = NULL;
	gint* ablocks;
	gint ablocks_length1;
	gint _ablocks_size_;
	gint _tmp8_;
	Gnonogram_permutor* _tmp9_ = NULL;
	Gnonogram_permutor* p;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_;
	const gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), NULL);
	_tmp0_ = g_strdup ("");
	clue = _tmp0_;
	_tmp2_ = gnonogram_region_blocks_available (self, &_tmp1_);
	ablocks = _tmp2_;
	ablocks_length1 = _tmp1_;
	_ablocks_size_ = _tmp1_;
	{
		gint b;
		b = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gchar* _tmp4_ = NULL;
				gchar* _tmp5_;
				gchar* _tmp6_;
				gchar* _tmp7_;
				if (!_tmp3_) {
					b++;
				}
				_tmp3_ = FALSE;
				if (!(b < ablocks_length1)) {
					break;
				}
				_tmp4_ = g_strdup_printf ("%i", self->priv->_blocks[ablocks[b]]);
				_tmp5_ = _tmp4_;
				_tmp6_ = g_strconcat (clue, _tmp5_, NULL);
				_tmp7_ = g_strconcat (_tmp6_, ",", NULL);
				_g_free0 (clue);
				clue = _tmp7_;
				_g_free0 (_tmp6_);
				_g_free0 (_tmp5_);
			}
		}
	}
	_tmp8_ = gnonogram_region_count_available_ranges (self, FALSE);
	if (_tmp8_ != 1) {
		fprintf (stdout, "ERROR in get permutator - more than one range\n");
		result = NULL;
		ablocks = (g_free (ablocks), NULL);
		_g_free0 (clue);
		if (start) {
			*start = _start;
		}
		return result;
	}
	_start = self->priv->_ranges[(0 * self->priv->_ranges_length2) + 0];
	_tmp9_ = gnonogram_permutor_new (self->priv->_ranges[(0 * self->priv->_ranges_length2) + 1], clue);
	p = _tmp9_;
	_tmp10_ = gnonogram_region_to_string (self);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strdup_printf ("%i", _start);
	_tmp13_ = _tmp12_;
	_tmp14_ = g_strdup_printf ("%i", self->priv->_ranges[(0 * self->priv->_ranges_length2) + 1]);
	_tmp15_ = _tmp14_;
	_tmp16_ = string_to_string (clue);
	_tmp17_ = g_strconcat ("Permutator from ", _tmp11_, " start ", _tmp13_, " length ", _tmp15_, " blocks used ", _tmp16_, "\n", NULL);
	_tmp18_ = _tmp17_;
	fprintf (stdout, "%s", _tmp18_);
	_g_free0 (_tmp18_);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp13_);
	_g_free0 (_tmp11_);
	result = p;
	ablocks = (g_free (ablocks), NULL);
	_g_free0 (clue);
	if (start) {
		*start = _start;
	}
	return result;
}


gchar* gnonogram_region_to_string (Gnonogram_region* self) {
	gchar* result = NULL;
	gchar* colrow = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), NULL);
	if (self->_is_column) {
		gchar* _tmp0_;
		gchar* _tmp1_;
		_tmp0_ = g_strdup ("Column");
		_tmp1_ = _tmp0_;
		_g_free0 (colrow);
		colrow = _tmp1_;
	} else {
		gchar* _tmp2_;
		gchar* _tmp3_;
		_tmp2_ = g_strdup ("Row");
		_tmp3_ = _tmp2_;
		_g_free0 (colrow);
		colrow = _tmp3_;
	}
	_tmp4_ = string_to_string (colrow);
	_tmp5_ = g_strdup_printf ("%i", self->_index);
	_tmp6_ = _tmp5_;
	_tmp7_ = string_to_string (self->priv->_clue);
	_tmp8_ = g_strconcat (_tmp4_, " ", _tmp6_, " (", _tmp7_, ")", NULL);
	result = (_tmp9_ = _tmp8_, _g_free0 (_tmp6_), _tmp9_);
	_g_free0 (colrow);
	return result;
}


static void value_gnonogram_region_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_gnonogram_region_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gnonogram_region_unref (value->data[0].v_pointer);
	}
}


static void value_gnonogram_region_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gnonogram_region_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_gnonogram_region_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_gnonogram_region_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Gnonogram_region* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gnonogram_region_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_gnonogram_region_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Gnonogram_region** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gnonogram_region_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_gnonogram_region (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGnonogram_region* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GNONOGRAM_REGION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_gnonogram_region (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_REGION), NULL);
	return value->data[0].v_pointer;
}


void value_set_gnonogram_region (GValue* value, gpointer v_object) {
	Gnonogram_region* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_REGION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_REGION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gnonogram_region_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_region_unref (old);
	}
}


void value_take_gnonogram_region (GValue* value, gpointer v_object) {
	Gnonogram_region* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_REGION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_REGION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_region_unref (old);
	}
}


static void gnonogram_region_class_init (Gnonogram_regionClass * klass) {
	gnonogram_region_parent_class = g_type_class_peek_parent (klass);
	GNONOGRAM_REGION_CLASS (klass)->finalize = gnonogram_region_finalize;
	g_type_class_add_private (klass, sizeof (Gnonogram_regionPrivate));
}


static void gnonogram_region_instance_init (Gnonogram_region * self) {
	self->priv = GNONOGRAM_REGION_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gnonogram_region_finalize (Gnonogram_region* obj) {
	Gnonogram_region * self;
	self = GNONOGRAM_REGION (obj);
	self->priv->_completed_blocks = (g_free (self->priv->_completed_blocks), NULL);
	self->priv->_completed_blocks_store = (g_free (self->priv->_completed_blocks_store), NULL);
	self->priv->_tags = (g_free (self->priv->_tags), NULL);
	self->priv->_tags_store = (g_free (self->priv->_tags_store), NULL);
	self->priv->_ranges = (g_free (self->priv->_ranges), NULL);
	_g_free0 (self->priv->_clue);
	self->priv->_blocks = (g_free (self->priv->_blocks), NULL);
	_my2_dcell_array_unref0 (self->_grid);
	self->priv->_status = (g_free (self->priv->_status), NULL);
	self->priv->_status_store = (g_free (self->priv->_status_store), NULL);
	self->priv->_temp_status = (g_free (self->priv->_temp_status), NULL);
	_g_free0 (self->message);
}


GType gnonogram_region_get_type (void) {
	static volatile gsize gnonogram_region_type_id__volatile = 0;
	if (g_once_init_enter (&gnonogram_region_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_gnonogram_region_init, value_gnonogram_region_free_value, value_gnonogram_region_copy_value, value_gnonogram_region_peek_pointer, "p", value_gnonogram_region_collect_value, "p", value_gnonogram_region_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (Gnonogram_regionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnonogram_region_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Gnonogram_region), 0, (GInstanceInitFunc) gnonogram_region_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gnonogram_region_type_id;
		gnonogram_region_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Gnonogram_region", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gnonogram_region_type_id__volatile, gnonogram_region_type_id);
	}
	return gnonogram_region_type_id__volatile;
}


gpointer gnonogram_region_ref (gpointer instance) {
	Gnonogram_region* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gnonogram_region_unref (gpointer instance) {
	Gnonogram_region* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GNONOGRAM_REGION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}




/* Gnonogram_region.c generated by valac 0.11.6, the Vala compiler
 * generated from Gnonogram_region.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 * 
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GNONOGRAM_REGION (gnonogram_region_get_type ())
#define GNONOGRAM_REGION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_REGION, Gnonogram_region))
#define GNONOGRAM_REGION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_REGION, Gnonogram_regionClass))
#define IS_GNONOGRAM_REGION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_REGION))
#define IS_GNONOGRAM_REGION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_REGION))
#define GNONOGRAM_REGION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_REGION, Gnonogram_regionClass))

typedef struct _Gnonogram_region Gnonogram_region;
typedef struct _Gnonogram_regionClass Gnonogram_regionClass;
typedef struct _Gnonogram_regionPrivate Gnonogram_regionPrivate;

#define TYPE_MY2_DCELL_ARRAY (my2_dcell_array_get_type ())
#define MY2_DCELL_ARRAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MY2_DCELL_ARRAY, My2DCellArray))
#define MY2_DCELL_ARRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MY2_DCELL_ARRAY, My2DCellArrayClass))
#define IS_MY2_DCELL_ARRAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MY2_DCELL_ARRAY))
#define IS_MY2_DCELL_ARRAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MY2_DCELL_ARRAY))
#define MY2_DCELL_ARRAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MY2_DCELL_ARRAY, My2DCellArrayClass))

typedef struct _My2DCellArray My2DCellArray;
typedef struct _My2DCellArrayClass My2DCellArrayClass;

#define TYPE_CELL_STATE (cell_state_get_type ())
#define _my2_dcell_array_unref0(var) ((var == NULL) ? NULL : (var = (my2_dcell_array_unref (var), NULL)))
typedef struct _ParamSpecGnonogram_region ParamSpecGnonogram_region;

struct _Gnonogram_region {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Gnonogram_regionPrivate * priv;
	gboolean _in_error;
	gboolean _completed;
};

struct _Gnonogram_regionClass {
	GTypeClass parent_class;
	void (*finalize) (Gnonogram_region *self);
};

typedef enum  {
	CELL_STATE_UNKNOWN,
	CELL_STATE_EMPTY,
	CELL_STATE_FILLED,
	CELL_STATE_ERROR,
	CELL_STATE_COMPLETED
} CellState;

struct _Gnonogram_regionPrivate {
	gboolean _is_column;
	gboolean* _completed_blocks;
	gint _completed_blocks_length1;
	gint __completed_blocks_size_;
	gboolean* _tags;
	gint _tags_length1;
	gint _tags_length2;
	gint* _ranges;
	gint _ranges_length1;
	gint _ranges_length2;
	gint _ncells;
	gint _nblocks;
	gint _block_total;
	gint _block_extent;
	gint _index;
	gint _cycles;
	gint _pass;
	gint _unknown;
	gint _filled;
	gint _can_be_empty_ptr;
	gint _is_finished_ptr;
	gint* _blocks;
	gint _blocks_length1;
	gint __blocks_size_;
	My2DCellArray* _grid;
	CellState* _status;
	gint _status_length1;
	gint __status_size_;
	CellState* _temp_status;
	gint _temp_status_length1;
	gint __temp_status_size_;
	gboolean _debug;
};

struct _ParamSpecGnonogram_region {
	GParamSpec parent_instance;
};


static gpointer gnonogram_region_parent_class = NULL;
extern gint resource_MAXCOLSIZE;

gpointer gnonogram_region_ref (gpointer instance);
void gnonogram_region_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_region (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_region (GValue* value, gpointer v_object);
void value_take_gnonogram_region (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_region (const GValue* value);
GType gnonogram_region_get_type (void) G_GNUC_CONST;
gpointer my2_dcell_array_ref (gpointer instance);
void my2_dcell_array_unref (gpointer instance);
GParamSpec* param_spec_my2_dcell_array (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_my2_dcell_array (GValue* value, gpointer v_object);
void value_take_my2_dcell_array (GValue* value, gpointer v_object);
gpointer value_get_my2_dcell_array (const GValue* value);
GType my2_dcell_array_get_type (void) G_GNUC_CONST;
GType cell_state_get_type (void) G_GNUC_CONST;
#define GNONOGRAM_REGION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GNONOGRAM_REGION, Gnonogram_regionPrivate))
enum  {
	GNONOGRAM_REGION_DUMMY_PROPERTY
};
Gnonogram_region* gnonogram_region_new (My2DCellArray* grid);
Gnonogram_region* gnonogram_region_construct (GType object_type, My2DCellArray* grid);
void gnonogram_region_initialize (Gnonogram_region* self, gint index, gboolean iscolumn, gint ncells, const gchar* blocks);
gint* utils_block_array_from_clue (const gchar* s, int* result_length1);
gboolean gnonogram_region_solve (Gnonogram_region* self, gint pass);
static void gnonogram_region_get_status (Gnonogram_region* self);
static gboolean gnonogram_region_totals_changed (Gnonogram_region* self);
static void gnonogram_region_initial_fix (Gnonogram_region* self);
static void gnonogram_region_full_fix (Gnonogram_region* self);
static void gnonogram_region_tags_to_status (Gnonogram_region* self);
static gint gnonogram_region_count_cell_state (Gnonogram_region* self, CellState cs);
static void gnonogram_region_put_status (Gnonogram_region* self);
static void gnonogram_region_status_to_tags (Gnonogram_region* self);
static gboolean gnonogram_region_do_edge (Gnonogram_region* self, gint direction);
static gboolean gnonogram_region_fill_gaps (Gnonogram_region* self);
static gboolean gnonogram_region_possibilities_audit (Gnonogram_region* self);
static gboolean gnonogram_region_filled_subregion_audit (Gnonogram_region* self);
static gboolean gnonogram_region_free_cell_audit (Gnonogram_region* self);
static gboolean gnonogram_region_only_possibility (Gnonogram_region* self);
static gboolean gnonogram_region_available_range_audit (Gnonogram_region* self);
static gboolean gnonogram_region_one_owner (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_same_owner (Gnonogram_region* self, gint cell1, gint cell2, gint* owner);
static void gnonogram_region_set_range_owner (Gnonogram_region* self, gint owner, gint start, gint length, gboolean exclusive);
static gint gnonogram_region_count_next_owner (Gnonogram_region* self, gint owner, gint idx);
static void gnonogram_region_remove_block_from_range (Gnonogram_region* self, gint block, gint start, gint length, gint direction);
static gboolean gnonogram_region_fix_block_in_range (Gnonogram_region* self, gint block, gint start, gint length, gboolean exclusive);
static gboolean gnonogram_region_skip_while_not_status (Gnonogram_region* self, CellState cs, gint* idx, gint limit, gint direction);
static gint gnonogram_region_count_next_state (Gnonogram_region* self, CellState cs, gint idx);
static gint gnonogram_region_find_largest_possible_in_cell (Gnonogram_region* self, gint cell);
static void gnonogram_region_assign_and_cap_range (Gnonogram_region* self, gint start, gint length);
static void gnonogram_region_set_block_complete_and_cap (Gnonogram_region* self, gint block, gint start, gint direction);
static void gnonogram_region_remove_block_from_cell_to_end (Gnonogram_region* self, gint block, gint start, gint direction);
static void gnonogram_region_set_cell_empty (Gnonogram_region* self, gint cell);
static void gnonogram_region_set_cell_complete (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_find_edge (Gnonogram_region* self, gint* idx, gint* blocknum, gint limit, gint direction);
static void gnonogram_region_set_cell_owner (Gnonogram_region* self, gint cell, gint owner, gboolean exclusive);
static gint gnonogram_region_count_available_ranges (Gnonogram_region* self);
static gint gnonogram_region_blocks_available (Gnonogram_region* self);
static gint gnonogram_region_count_owners_and_empty (Gnonogram_region* self, gint cell);
static gboolean gnonogram_region_invalid_data (Gnonogram_region* self, gint start, gint block, gint length);
static gboolean gnonogram_region_cell_filled (Gnonogram_region* self, gint cell);
void my2_dcell_array_get_array (My2DCellArray* self, gint idx, gboolean iscolumn, CellState** sa, int* sa_length1, gint start);
void my2_dcell_array_set_array (My2DCellArray* self, gint idx, gboolean iscolumn, CellState* sa, int sa_length1, gint start);
static void gnonogram_region_finalize (Gnonogram_region* obj);


static gpointer _my2_dcell_array_ref0 (gpointer self) {
	return self ? my2_dcell_array_ref (self) : NULL;
}


Gnonogram_region* gnonogram_region_construct (GType object_type, My2DCellArray* grid) {
	Gnonogram_region* self = NULL;
	My2DCellArray* _tmp0_;
	My2DCellArray* _tmp1_;
	CellState* _tmp2_ = NULL;
	CellState* _tmp3_;
	CellState* _tmp4_ = NULL;
	CellState* _tmp5_;
	gint maxblocks;
	gint* _tmp6_ = NULL;
	gint* _tmp7_;
	gint* _tmp8_ = NULL;
	gint* _tmp9_;
	gboolean* _tmp10_ = NULL;
	gboolean* _tmp11_;
	gboolean* _tmp12_ = NULL;
	gboolean* _tmp13_;
	g_return_val_if_fail (IS_MY2_DCELL_ARRAY (grid), NULL);
	self = (Gnonogram_region*) g_type_create_instance (object_type);
	_tmp0_ = _my2_dcell_array_ref0 (grid);
	_tmp1_ = _tmp0_;
	_my2_dcell_array_unref0 (self->priv->_grid);
	self->priv->_grid = _tmp1_;
	self->priv->_debug = FALSE;
	_tmp2_ = g_new0 (CellState, resource_MAXCOLSIZE);
	_tmp3_ = _tmp2_;
	self->priv->_status = (g_free (self->priv->_status), NULL);
	self->priv->_status_length1 = resource_MAXCOLSIZE;
	self->priv->__status_size_ = self->priv->_status_length1;
	self->priv->_status = _tmp3_;
	_tmp4_ = g_new0 (CellState, resource_MAXCOLSIZE);
	_tmp5_ = _tmp4_;
	self->priv->_temp_status = (g_free (self->priv->_temp_status), NULL);
	self->priv->_temp_status_length1 = resource_MAXCOLSIZE;
	self->priv->__temp_status_size_ = self->priv->_temp_status_length1;
	self->priv->_temp_status = _tmp5_;
	maxblocks = (resource_MAXCOLSIZE / 2) + 1;
	_tmp6_ = g_new0 (gint, maxblocks * 4);
	_tmp7_ = _tmp6_;
	self->priv->_ranges = (g_free (self->priv->_ranges), NULL);
	self->priv->_ranges_length1 = maxblocks;
	self->priv->_ranges_length2 = 4;
	self->priv->_ranges = _tmp7_;
	_tmp8_ = g_new0 (gint, maxblocks);
	_tmp9_ = _tmp8_;
	self->priv->_blocks = (g_free (self->priv->_blocks), NULL);
	self->priv->_blocks_length1 = maxblocks;
	self->priv->__blocks_size_ = self->priv->_blocks_length1;
	self->priv->_blocks = _tmp9_;
	_tmp10_ = g_new0 (gboolean, maxblocks);
	_tmp11_ = _tmp10_;
	self->priv->_completed_blocks = (g_free (self->priv->_completed_blocks), NULL);
	self->priv->_completed_blocks_length1 = maxblocks;
	self->priv->__completed_blocks_size_ = self->priv->_completed_blocks_length1;
	self->priv->_completed_blocks = _tmp11_;
	_tmp12_ = g_new0 (gboolean, resource_MAXCOLSIZE * (maxblocks + 2));
	_tmp13_ = _tmp12_;
	self->priv->_tags = (g_free (self->priv->_tags), NULL);
	self->priv->_tags_length1 = resource_MAXCOLSIZE;
	self->priv->_tags_length2 = maxblocks + 2;
	self->priv->_tags = _tmp13_;
	self->priv->_can_be_empty_ptr = maxblocks;
	self->priv->_is_finished_ptr = maxblocks + 1;
	return self;
}


Gnonogram_region* gnonogram_region_new (My2DCellArray* grid) {
	return gnonogram_region_construct (TYPE_GNONOGRAM_REGION, grid);
}


void gnonogram_region_initialize (Gnonogram_region* self, gint index, gboolean iscolumn, gint ncells, const gchar* blocks) {
	gint _tmp0_;
	gint* _tmp1_ = NULL;
	gint* _tmp2_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	g_return_if_fail (blocks != NULL);
	self->priv->_index = index;
	self->priv->_is_column = iscolumn;
	self->priv->_ncells = ncells;
	self->_completed = FALSE;
	self->_in_error = FALSE;
	self->priv->_block_total = 0;
	self->priv->_block_extent = 0;
	self->priv->_cycles = 0;
	self->priv->_pass = 0;
	self->priv->_unknown = 99;
	self->priv->_filled = 99;
	_tmp1_ = utils_block_array_from_clue (blocks, &_tmp0_);
	_tmp2_ = _tmp1_;
	self->priv->_blocks = (g_free (self->priv->_blocks), NULL);
	self->priv->_blocks_length1 = _tmp0_;
	self->priv->__blocks_size_ = self->priv->_blocks_length1;
	self->priv->_blocks = _tmp2_;
	self->priv->_nblocks = self->priv->_blocks_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				if (!_tmp3_) {
					i++;
				}
				_tmp3_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				self->priv->_block_total = self->priv->_block_total + self->priv->_blocks[i];
				self->priv->_completed_blocks[i] = FALSE;
			}
		}
	}
	self->priv->_block_extent = (self->priv->_block_total + self->priv->_nblocks) - 1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				if (!_tmp4_) {
					i++;
				}
				_tmp4_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				{
					gint j;
					j = 0;
					{
						gboolean _tmp5_;
						_tmp5_ = TRUE;
						while (TRUE) {
							if (!_tmp5_) {
								j++;
							}
							_tmp5_ = FALSE;
							if (!(j < self->priv->_nblocks)) {
								break;
							}
							self->priv->_tags[(i * self->priv->_tags_length2) + j] = FALSE;
						}
					}
				}
				self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = TRUE;
				self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = FALSE;
			}
		}
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				if (!_tmp6_) {
					i++;
				}
				_tmp6_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				self->priv->_status[i] = CELL_STATE_UNKNOWN;
				self->priv->_temp_status[i] = CELL_STATE_UNKNOWN;
			}
		}
	}
}


gboolean gnonogram_region_solve (Gnonogram_region* self, gint pass) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean made_changes;
	gboolean still_changing;
	gboolean _tmp1_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->_completed) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = self->priv->_ncells == 1;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	self->priv->_pass = pass;
	made_changes = FALSE;
	still_changing = FALSE;
	gnonogram_region_get_status (self);
	_tmp1_ = gnonogram_region_totals_changed (self);
	still_changing = _tmp1_;
	while (TRUE) {
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_;
		if (still_changing) {
			_tmp2_ = !self->_completed;
		} else {
			_tmp2_ = FALSE;
		}
		if (!_tmp2_) {
			break;
		}
		self->priv->_cycles++;
		if (self->priv->_cycles == 1) {
			gnonogram_region_initial_fix (self);
		} else {
			gnonogram_region_full_fix (self);
			gnonogram_region_tags_to_status (self);
		}
		if (self->_in_error) {
			break;
		}
		_tmp3_ = gnonogram_region_totals_changed (self);
		still_changing = _tmp3_;
		if (still_changing) {
			gint _tmp4_;
			made_changes = TRUE;
			_tmp4_ = gnonogram_region_count_cell_state (self, CELL_STATE_UNKNOWN);
			self->_completed = _tmp4_ == 0;
		}
	}
	if (made_changes) {
		gnonogram_region_put_status (self);
	}
	result = made_changes;
	return result;
}


static void gnonogram_region_initial_fix (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (self->priv->_blocks[0] == 0) {
		self->priv->_completed_blocks[0] = TRUE;
		self->_completed = TRUE;
	} else {
		gint freedom;
		gint start;
		gint length;
		freedom = self->priv->_ncells - self->priv->_block_extent;
		if (freedom == 0) {
			self->_completed = TRUE;
		}
		start = 0;
		length = 0;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					if (!_tmp0_) {
						i++;
					}
					_tmp0_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					length = self->priv->_blocks[i] + freedom;
					{
						gint j;
						j = start;
						{
							gboolean _tmp1_;
							_tmp1_ = TRUE;
							while (TRUE) {
								if (!_tmp1_) {
									j++;
								}
								_tmp1_ = FALSE;
								if (!(j < (start + length))) {
									break;
								}
								self->priv->_tags[(j * self->priv->_tags_length2) + i] = TRUE;
							}
						}
					}
					start = (start + self->priv->_blocks[i]) + 1;
				}
			}
		}
	}
	gnonogram_region_tags_to_status (self);
}


static void gnonogram_region_full_fix (Gnonogram_region* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp15_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	gnonogram_region_status_to_tags (self);
	_tmp1_ = gnonogram_region_do_edge (self, 1);
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = self->_in_error;
	}
	if (_tmp0_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp3_ = gnonogram_region_do_edge (self, -1);
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = self->_in_error;
	}
	if (_tmp2_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp5_ = gnonogram_region_fill_gaps (self);
	if (_tmp5_) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = self->_in_error;
	}
	if (_tmp4_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp7_ = gnonogram_region_possibilities_audit (self);
	if (_tmp7_) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = self->_in_error;
	}
	if (_tmp6_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp9_ = gnonogram_region_filled_subregion_audit (self);
	if (_tmp9_) {
		_tmp8_ = TRUE;
	} else {
		_tmp8_ = self->_in_error;
	}
	if (_tmp8_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp11_ = gnonogram_region_free_cell_audit (self);
	if (_tmp11_) {
		_tmp10_ = TRUE;
	} else {
		_tmp10_ = self->_in_error;
	}
	if (_tmp10_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp13_ = gnonogram_region_only_possibility (self);
	if (_tmp13_) {
		_tmp12_ = TRUE;
	} else {
		_tmp12_ = self->_in_error;
	}
	if (_tmp12_) {
		return;
	}
	gnonogram_region_tags_to_status (self);
	_tmp15_ = gnonogram_region_available_range_audit (self);
	if (_tmp15_) {
		_tmp14_ = TRUE;
	} else {
		_tmp14_ = self->_in_error;
	}
	if (_tmp14_) {
		return;
	}
}


static gboolean gnonogram_region_fill_gaps (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	{
		gint idx;
		idx = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint cell1;
				gint owner = 0;
				gint _tmp3_;
				gboolean _tmp4_;
				if (!_tmp0_) {
					idx++;
				}
				_tmp0_ = FALSE;
				if (!(idx < (self->priv->_ncells - 1))) {
					break;
				}
				if (self->priv->_status[idx] != CELL_STATE_FILLED) {
					continue;
				}
				if (self->priv->_status[idx + 1] != CELL_STATE_UNKNOWN) {
					continue;
				}
				_tmp1_ = gnonogram_region_one_owner (self, idx);
				if (!_tmp1_) {
					continue;
				}
				idx++;
				cell1 = idx - 1;
				while (TRUE) {
					gboolean _tmp2_ = FALSE;
					if (idx < (self->priv->_ncells - 1)) {
						_tmp2_ = self->priv->_status[idx] == CELL_STATE_UNKNOWN;
					} else {
						_tmp2_ = FALSE;
					}
					if (!_tmp2_) {
						break;
					}
					idx++;
				}
				if (self->priv->_status[idx] != CELL_STATE_FILLED) {
					continue;
				}
				_tmp4_ = gnonogram_region_same_owner (self, cell1, idx, &_tmp3_);
				owner = _tmp3_;
				if (_tmp4_) {
					gnonogram_region_set_range_owner (self, owner, cell1, (idx - cell1) + 1, TRUE);
					changed = TRUE;
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_possibilities_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint start;
	gint length = 0;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	start = 0;
	count = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_completed_blocks[i]) {
					continue;
				}
				length = 0;
				count = 0;
				{
					gint idx;
					idx = 0;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							gboolean _tmp2_ = FALSE;
							gint _tmp3_;
							gint l;
							gint s;
							if (!_tmp1_) {
								idx++;
							}
							_tmp1_ = FALSE;
							if (!(idx < self->priv->_ncells)) {
								break;
							}
							if (count > 1) {
								break;
							}
							if (!self->priv->_tags[(idx * self->priv->_tags_length2) + i]) {
								_tmp2_ = TRUE;
							} else {
								_tmp2_ = self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
							}
							if (_tmp2_) {
								continue;
							}
							_tmp3_ = gnonogram_region_count_next_owner (self, i, idx);
							l = _tmp3_;
							s = idx;
							if (l < self->priv->_blocks[i]) {
								gnonogram_region_remove_block_from_range (self, i, s, l, 1);
							} else {
								length = l;
								start = s;
								count++;
							}
							idx = idx + l;
						}
					}
				}
				if (count != 1) {
					continue;
				} else {
					gboolean _tmp4_ = FALSE;
					gboolean _tmp5_;
					_tmp5_ = gnonogram_region_fix_block_in_range (self, i, start, length, TRUE);
					if (_tmp5_) {
						_tmp4_ = TRUE;
					} else {
						_tmp4_ = changed;
					}
					changed = _tmp4_;
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_filled_subregion_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint idx;
	gint length = 0;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	idx = 0;
	while (TRUE) {
		gboolean _tmp0_;
		if (!(idx < self->priv->_ncells)) {
			break;
		}
		_tmp0_ = gnonogram_region_skip_while_not_status (self, CELL_STATE_FILLED, &idx, self->priv->_ncells, 1);
		if (_tmp0_) {
			gint _tmp1_;
			gint _tmp2_;
			gint largest;
			if (self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr]) {
				continue;
			}
			_tmp1_ = gnonogram_region_count_next_state (self, CELL_STATE_FILLED, idx);
			length = _tmp1_;
			_tmp2_ = gnonogram_region_find_largest_possible_in_cell (self, idx);
			largest = _tmp2_;
			if (largest == length) {
				gnonogram_region_assign_and_cap_range (self, idx, length);
				changed = TRUE;
			} else {
				{
					gint i;
					i = idx - 1;
					{
						gboolean _tmp3_;
						_tmp3_ = TRUE;
						while (TRUE) {
							gboolean _tmp4_ = FALSE;
							if (!_tmp3_) {
								i++;
							}
							_tmp3_ = FALSE;
							if (!(i <= (idx + length))) {
								break;
							}
							if (i < 0) {
								_tmp4_ = TRUE;
							} else {
								_tmp4_ = i > (self->priv->_ncells - 1);
							}
							if (_tmp4_) {
								continue;
							}
							{
								gint bl;
								bl = 0;
								{
									gboolean _tmp5_;
									_tmp5_ = TRUE;
									while (TRUE) {
										gboolean _tmp6_ = FALSE;
										if (!_tmp5_) {
											bl++;
										}
										_tmp5_ = FALSE;
										if (!(bl < self->priv->_nblocks)) {
											break;
										}
										if (self->priv->_tags[(i * self->priv->_tags_length2) + bl]) {
											_tmp6_ = self->priv->_blocks[bl] < length;
										} else {
											_tmp6_ = FALSE;
										}
										if (_tmp6_) {
											self->priv->_tags[(i * self->priv->_tags_length2) + bl] = FALSE;
										}
									}
								}
							}
						}
					}
				}
			}
			idx = idx + length;
		} else {
			break;
		}
	}
	result = changed;
	return result;
}


static void gnonogram_region_assign_and_cap_range (Gnonogram_region* self, gint start, gint length) {
	gint count;
	gint* _tmp0_ = NULL;
	gint* max_blocks;
	gint max_blocks_length1;
	gint _max_blocks_size_;
	gint first;
	gint last;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	count = 0;
	_tmp0_ = g_new0 (gint, self->priv->_nblocks);
	max_blocks = _tmp0_;
	max_blocks_length1 = self->priv->_nblocks;
	_max_blocks_size_ = self->priv->_nblocks;
	first = self->priv->_nblocks;
	last = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_completed_blocks[i]) {
					continue;
				}
				if (self->priv->_blocks[i] != length) {
					continue;
				}
				if (!self->priv->_tags[(start * self->priv->_tags_length2) + i]) {
					continue;
				}
				max_blocks[count] = i;
				count++;
				if (i < first) {
					first = i;
				}
				if (i > last) {
					last = i;
				}
			}
		}
	}
	if (count == 1) {
		gnonogram_region_set_block_complete_and_cap (self, max_blocks[0], start, 1);
	} else {
		{
			gint i;
			i = last;
			{
				gboolean _tmp2_;
				_tmp2_ = TRUE;
				while (TRUE) {
					if (!_tmp2_) {
						i++;
					}
					_tmp2_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					gnonogram_region_remove_block_from_cell_to_end (self, i, (start + length) - 1, -1);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i <= first)) {
						break;
					}
					gnonogram_region_remove_block_from_cell_to_end (self, i, start, 1);
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < count)) {
						break;
					}
					gnonogram_region_set_range_owner (self, max_blocks[i], start, length, FALSE);
				}
			}
		}
		{
			gint i;
			i = first + 1;
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					if (!_tmp5_) {
						i++;
					}
					_tmp5_ = FALSE;
					if (!(i < last)) {
						break;
					}
					if (self->priv->_blocks[i] == length) {
						continue;
					}
					gnonogram_region_remove_block_from_range (self, i, start, length, 1);
				}
			}
		}
		if (start > 0) {
			gnonogram_region_set_cell_empty (self, start - 1);
		}
		if ((start + length) < self->priv->_ncells) {
			gnonogram_region_set_cell_empty (self, start + length);
		}
	}
	max_blocks = (g_free (max_blocks), NULL);
}


static gboolean gnonogram_region_only_possibility (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint owner = 0;
	gint length = 0;
	gint start = 0;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr]) {
					continue;
				}
				if (self->priv->_status[i] == CELL_STATE_FILLED) {
					gboolean _tmp2_;
					_tmp2_ = gnonogram_region_one_owner (self, i);
					_tmp1_ = _tmp2_;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					owner = 0;
					{
						gboolean _tmp3_;
						owner = 0;
						_tmp3_ = TRUE;
						while (TRUE) {
							if (!_tmp3_) {
								owner++;
							}
							_tmp3_ = FALSE;
							if (!(owner < self->priv->_nblocks)) {
								break;
							}
							if (self->priv->_tags[(i * self->priv->_tags_length2) + owner]) {
								break;
							}
						}
					}
					length = self->priv->_blocks[owner];
					start = i - length;
					if (start >= 0) {
						gnonogram_region_remove_block_from_cell_to_end (self, owner, start, -1);
					}
					start = i + length;
					if (start < self->priv->_ncells) {
						gnonogram_region_remove_block_from_cell_to_end (self, owner, start, +1);
					}
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_free_cell_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint _tmp0_;
	gint free_cells;
	gint _tmp1_;
	gint filled_cells;
	gint _tmp2_;
	gint completed_cells;
	gint to_locate;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	_tmp0_ = gnonogram_region_count_cell_state (self, CELL_STATE_UNKNOWN);
	free_cells = _tmp0_;
	if (free_cells == 0) {
		result = FALSE;
		return result;
	}
	_tmp1_ = gnonogram_region_count_cell_state (self, CELL_STATE_FILLED);
	filled_cells = _tmp1_;
	_tmp2_ = gnonogram_region_count_cell_state (self, CELL_STATE_COMPLETED);
	completed_cells = _tmp2_;
	to_locate = (self->priv->_block_total - filled_cells) - completed_cells;
	if (free_cells == to_locate) {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < self->priv->_ncells)) {
						break;
					}
					if (self->priv->_status[i] == CELL_STATE_UNKNOWN) {
						gnonogram_region_set_cell_complete (self, i);
					}
				}
			}
		}
		{
			gint i;
			i = 0;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					if (!_tmp4_) {
						i++;
					}
					_tmp4_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					self->priv->_completed_blocks[i] = TRUE;
				}
			}
		}
		changed = TRUE;
	} else {
		if (to_locate == 0) {
			{
				gint i;
				i = 0;
				{
					gboolean _tmp5_;
					_tmp5_ = TRUE;
					while (TRUE) {
						if (!_tmp5_) {
							i++;
						}
						_tmp5_ = FALSE;
						if (!(i < self->priv->_ncells)) {
							break;
						}
						if (self->priv->_status[i] == CELL_STATE_UNKNOWN) {
							gnonogram_region_set_cell_empty (self, i);
						}
					}
				}
			}
			changed = TRUE;
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_do_edge (Gnonogram_region* self, gint direction) {
	gboolean result = FALSE;
	gint idx = 0;
	gint blocknum = 0;
	gint blength = 0;
	gint limit = 0;
	gboolean changed;
	gboolean dir;
	gboolean _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	dir = direction > 0;
	if (dir) {
		idx = 0;
		blocknum = 0;
		limit = self->priv->_ncells;
	} else {
		idx = self->priv->_ncells - 1;
		blocknum = self->priv->_nblocks - 1;
		limit = -1;
	}
	_tmp0_ = gnonogram_region_find_edge (self, &idx, &blocknum, limit, direction);
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	blength = self->priv->_blocks[blocknum];
	if (self->priv->_status[idx] == CELL_STATE_FILLED) {
		gnonogram_region_set_block_complete_and_cap (self, blocknum, idx, direction);
		changed = TRUE;
	} else {
		gint edge_start;
		gint fill_start;
		gint _tmp1_ = 0;
		gint blocklimit;
		gboolean _tmp2_;
		edge_start = idx;
		fill_start = -1;
		if (dir) {
			_tmp1_ = idx + blength;
		} else {
			_tmp1_ = idx - blength;
		}
		blocklimit = _tmp1_;
		_tmp2_ = gnonogram_region_skip_while_not_status (self, CELL_STATE_FILLED, &idx, blocklimit, direction);
		if (_tmp2_) {
			fill_start = idx;
			while (TRUE) {
				if (!(idx != blocklimit)) {
					break;
				}
				if (self->priv->_status[idx] == CELL_STATE_UNKNOWN) {
					gnonogram_region_set_cell_owner (self, idx, blocknum, TRUE);
					changed = TRUE;
				}
				if (dir) {
					idx++;
				} else {
					idx--;
				}
			}
			while (TRUE) {
				gboolean _tmp3_ = FALSE;
				if (idx != blocklimit) {
					_tmp3_ = self->priv->_status[idx] == CELL_STATE_FILLED;
				} else {
					_tmp3_ = FALSE;
				}
				if (!_tmp3_) {
					break;
				}
				gnonogram_region_set_cell_owner (self, idx, blocknum, TRUE);
				gnonogram_region_set_cell_empty (self, edge_start);
				changed = TRUE;
				if (dir) {
					idx++;
					edge_start++;
				} else {
					idx--;
					edge_start--;
				}
			}
			if (fill_start > 0) {
				gint _tmp4_ = 0;
				gboolean _tmp5_ = FALSE;
				if (dir) {
					_tmp4_ = fill_start + blength;
				} else {
					_tmp4_ = fill_start - blength;
				}
				idx = _tmp4_;
				if (idx >= 0) {
					_tmp5_ = idx < self->priv->_ncells;
				} else {
					_tmp5_ = FALSE;
				}
				if (_tmp5_) {
					gnonogram_region_remove_block_from_cell_to_end (self, blocknum, idx, direction);
				}
			}
		}
	}
	result = changed;
	return result;
}


static gboolean gnonogram_region_find_edge (Gnonogram_region* self, gint* idx, gint* blocknum, gint limit, gint direction) {
	gboolean result = FALSE;
	gboolean dir;
	gboolean found;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	dir = direction > 0;
	found = FALSE;
	{
		gint i;
		i = *idx;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					if (dir) {
						gint _tmp2_;
						_tmp2_ = i;
						i = _tmp2_ + 1;
						_tmp1_ = _tmp2_;
					} else {
						gint _tmp3_;
						_tmp3_ = i;
						i = _tmp3_ - 1;
						_tmp1_ = _tmp3_;
					}
				}
				_tmp0_ = FALSE;
				if (dir) {
					_tmp4_ = i < limit;
				} else {
					_tmp4_ = i > limit;
				}
				if (!_tmp4_) {
					break;
				}
				if (self->priv->_status[i] == CELL_STATE_EMPTY) {
					continue;
				}
				if (self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr]) {
					gint _tmp5_ = 0;
					if (dir) {
						_tmp5_ = (i + self->priv->_blocks[*blocknum]) - 1;
					} else {
						_tmp5_ = (i - self->priv->_blocks[*blocknum]) + 1;
					}
					i = _tmp5_;
					if (dir) {
						(*blocknum)++;
					} else {
						(*blocknum)--;
					}
					continue;
				}
				*idx = i;
				found = TRUE;
				break;
			}
		}
	}
	result = found;
	return result;
}


static gboolean gnonogram_region_available_range_audit (Gnonogram_region* self) {
	gboolean result = FALSE;
	gint start = 0;
	gint length = 0;
	gint filled = 0;
	gint unknown = 0;
	gint ranges = 0;
	gint nblocks = 0;
	gboolean changed;
	gint _tmp0_;
	gint _tmp2_;
	gboolean _tmp3_ = FALSE;
	gint* _tmp4_ = NULL;
	gint* blocks;
	gint blocks_length1;
	gint _blocks_size_;
	gint bl;
	gboolean unique;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	_tmp0_ = gnonogram_region_count_available_ranges (self);
	ranges = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < ranges)) {
					break;
				}
				start = self->priv->_ranges[(i * self->priv->_ranges_length2) + 0];
				length = self->priv->_ranges[(i * self->priv->_ranges_length2) + 1];
				filled = self->priv->_ranges[(i * self->priv->_ranges_length2) + 2];
				unknown = self->priv->_ranges[(i * self->priv->_ranges_length2) + 3];
			}
		}
	}
	_tmp2_ = gnonogram_region_blocks_available (self);
	nblocks = _tmp2_;
	if (nblocks != ranges) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = nblocks < 2;
	}
	if (_tmp3_) {
		result = FALSE;
		return result;
	}
	_tmp4_ = g_new0 (gint, nblocks);
	blocks = _tmp4_;
	blocks_length1 = nblocks;
	_blocks_size_ = nblocks;
	bl = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				if (!_tmp5_) {
					i++;
				}
				_tmp5_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (!self->priv->_completed_blocks[i]) {
					blocks[bl] = i;
					bl++;
				}
			}
		}
	}
	unique = TRUE;
	{
		gint r;
		r = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_ = FALSE;
				gboolean _tmp8_ = FALSE;
				if (!_tmp6_) {
					r++;
				}
				_tmp6_ = FALSE;
				if (!(r < ranges)) {
					break;
				}
				if (r < (ranges - 1)) {
					_tmp8_ = self->priv->_ranges[(r * self->priv->_ranges_length2) + 1] >= ((self->priv->_blocks[blocks[r]] + self->priv->_blocks[blocks[r + 1]]) + 1);
				} else {
					_tmp8_ = FALSE;
				}
				if (_tmp8_) {
					_tmp7_ = TRUE;
				} else {
					gboolean _tmp9_ = FALSE;
					if (r > 0) {
						_tmp9_ = self->priv->_ranges[(r * self->priv->_ranges_length2) + 1] >= ((self->priv->_blocks[blocks[r]] + self->priv->_blocks[blocks[r - 1]]) + 1);
					} else {
						_tmp9_ = FALSE;
					}
					_tmp7_ = _tmp9_;
				}
				if (_tmp7_) {
					unique = FALSE;
					break;
				}
			}
		}
	}
	if (unique) {
		{
			gint r;
			r = 0;
			{
				gboolean _tmp10_;
				_tmp10_ = TRUE;
				while (TRUE) {
					if (!_tmp10_) {
						r++;
					}
					_tmp10_ = FALSE;
					if (!(r < ranges)) {
						break;
					}
					gnonogram_region_fix_block_in_range (self, blocks[r], self->priv->_ranges[(r * self->priv->_ranges_length2) + 0], self->priv->_ranges[(r * self->priv->_ranges_length2) + 1], TRUE);
					changed = TRUE;
				}
			}
		}
	}
	result = changed;
	blocks = (g_free (blocks), NULL);
	return result;
}


static gboolean gnonogram_region_skip_while_not_status (Gnonogram_region* self, CellState cs, gint* idx, gint limit, gint direction) {
	gboolean result = FALSE;
	gboolean dir;
	gboolean found;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	dir = direction > 0;
	found = FALSE;
	{
		gint i;
		i = *idx;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					if (dir) {
						gint _tmp2_;
						_tmp2_ = i;
						i = _tmp2_ + 1;
						_tmp1_ = _tmp2_;
					} else {
						gint _tmp3_;
						_tmp3_ = i;
						i = _tmp3_ - 1;
						_tmp1_ = _tmp3_;
					}
				}
				_tmp0_ = FALSE;
				if (dir) {
					_tmp4_ = i < limit;
				} else {
					_tmp4_ = i > limit;
				}
				if (!_tmp4_) {
					break;
				}
				if (self->priv->_status[i] == cs) {
					*idx = i;
					found = TRUE;
					break;
				}
			}
		}
	}
	result = found;
	return result;
}


static gint gnonogram_region_count_next_state (Gnonogram_region* self, CellState cs, gint idx) {
	gint result = 0;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	if (idx >= 0) {
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			if (self->priv->_status[idx] == cs) {
				_tmp0_ = idx < self->priv->_ncells;
			} else {
				_tmp0_ = FALSE;
			}
			if (!_tmp0_) {
				break;
			}
			count++;
			idx++;
		}
	} else {
		self->_in_error = TRUE;
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_next_owner (Gnonogram_region* self, gint owner, gint idx) {
	gint result = 0;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	if (idx >= 0) {
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			gboolean _tmp1_ = FALSE;
			if (self->priv->_tags[(idx * self->priv->_tags_length2) + owner]) {
				_tmp1_ = !self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_is_finished_ptr];
			} else {
				_tmp1_ = FALSE;
			}
			if (_tmp1_) {
				_tmp0_ = idx < self->priv->_ncells;
			} else {
				_tmp0_ = FALSE;
			}
			if (!_tmp0_) {
				break;
			}
			count++;
			idx++;
		}
	} else {
		self->_in_error = TRUE;
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_owners_and_empty (Gnonogram_region* self, gint cell) {
	gint result = 0;
	gint count;
	gboolean _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	_tmp0_ = gnonogram_region_invalid_data (self, cell, 0, 1);
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		{
			gint j;
			j = 0;
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					if (!_tmp1_) {
						j++;
					}
					_tmp1_ = FALSE;
					if (!(j < self->priv->_nblocks)) {
						break;
					}
					if (self->priv->_tags[(cell * self->priv->_tags_length2) + j]) {
						count++;
					}
				}
			}
		}
		if (self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
			count++;
		}
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_cell_state (Gnonogram_region* self, CellState cs) {
	gint result = 0;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	count = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_status[i] == cs) {
					count++;
				}
			}
		}
	}
	result = count;
	return result;
}


static gint gnonogram_region_count_available_ranges (Gnonogram_region* self) {
	gint result = 0;
	gint range;
	gint start;
	gint length;
	gint idx;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	range = 0;
	start = 0;
	length = 0;
	idx = 0;
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		if (!(idx < self->priv->_ncells)) {
			break;
		}
		length = 0;
		start = idx;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 0] = start;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 2] = 0;
		self->priv->_ranges[(range * self->priv->_ranges_length2) + 3] = 0;
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			if (self->priv->_status[idx] != CELL_STATE_EMPTY) {
				_tmp0_ = idx < self->priv->_ncells;
			} else {
				_tmp0_ = FALSE;
			}
			if (!_tmp0_) {
				break;
			}
			if (!self->priv->_tags[(idx * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
				self->priv->_ranges[(range * self->priv->_ranges_length2) + 2]++;
			} else {
				self->priv->_ranges[(range * self->priv->_ranges_length2) + 3]++;
			}
			idx++;
			length++;
		}
		if (length > 0) {
			_tmp1_ = self->priv->_ranges[(range * self->priv->_ranges_length2) + 3] != 0;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			self->priv->_ranges[(range * self->priv->_ranges_length2) + 1] = length;
			range++;
		}
		while (TRUE) {
			gboolean _tmp2_ = FALSE;
			if (self->priv->_status[idx] == CELL_STATE_EMPTY) {
				_tmp2_ = idx < self->priv->_ncells;
			} else {
				_tmp2_ = FALSE;
			}
			if (!_tmp2_) {
				break;
			}
			idx++;
		}
	}
	result = range;
	return result;
}


static gint gnonogram_region_blocks_available (Gnonogram_region* self) {
	gint result = 0;
	gint available;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	available = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (!self->priv->_completed_blocks[i]) {
					available++;
				}
			}
		}
	}
	result = available;
	return result;
}


static gboolean gnonogram_region_same_owner (Gnonogram_region* self, gint cell1, gint cell2, gint* owner) {
	gint _owner = 0;
	gboolean result = FALSE;
	gint count;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	count = 0;
	_owner = 0;
	if (cell1 < 0) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = cell1 >= self->priv->_ncells;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = cell2 < 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = cell2 >= self->priv->_ncells;
	}
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					gboolean _tmp4_ = FALSE;
					if (!_tmp3_) {
						i++;
					}
					_tmp3_ = FALSE;
					if (!(i < self->priv->_nblocks)) {
						break;
					}
					if (self->priv->_tags[(cell1 * self->priv->_tags_length2) + i] != self->priv->_tags[(cell2 * self->priv->_tags_length2) + i]) {
						_tmp4_ = TRUE;
					} else {
						_tmp4_ = count > 1;
					}
					if (_tmp4_) {
						count = 0;
						break;
					} else {
						if (self->priv->_tags[(cell1 * self->priv->_tags_length2) + i]) {
							count++;
							_owner = i;
						}
					}
				}
			}
		}
	}
	result = count == 1;
	if (owner) {
		*owner = _owner;
	}
	return result;
}


static gboolean gnonogram_region_one_owner (Gnonogram_region* self, gint cell) {
	gboolean result = FALSE;
	gint count;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	count = 0;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_tags[(cell * self->priv->_tags_length2) + i]) {
					count++;
				}
				if (count > 1) {
					break;
				}
			}
		}
	}
	result = count == 1;
	return result;
}


static gboolean gnonogram_region_fix_block_in_range (Gnonogram_region* self, gint block, gint start, gint length, gboolean exclusive) {
	gboolean result = FALSE;
	gboolean changed;
	gboolean _tmp0_;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	changed = FALSE;
	_tmp0_ = gnonogram_region_invalid_data (self, start, block, length);
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		gint block_length;
		gint freedom;
		block_length = self->priv->_blocks[block];
		freedom = length - block_length;
		if (freedom < block_length) {
			if (freedom == 0) {
				gnonogram_region_set_block_complete_and_cap (self, block, start, 1);
				changed = TRUE;
			} else {
				gnonogram_region_set_range_owner (self, block, start + freedom, block_length - freedom, exclusive);
			}
		}
	}
	result = changed;
	return result;
}


static gint gnonogram_region_find_largest_possible_in_cell (Gnonogram_region* self, gint cell) {
	gint result = 0;
	gint max_size;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), 0);
	max_size = -1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_nblocks)) {
					break;
				}
				if (self->priv->_completed_blocks[i]) {
					continue;
				}
				if (!self->priv->_tags[(cell * self->priv->_tags_length2) + i]) {
					continue;
				}
				if (self->priv->_blocks[i] <= max_size) {
					continue;
				}
				max_size = self->priv->_blocks[i];
			}
		}
	}
	result = max_size;
	return result;
}


static void gnonogram_region_remove_block_from_cell_to_end (Gnonogram_region* self, gint block, gint start, gint direction) {
	gint _tmp0_ = 0;
	gint length;
	gint _tmp1_ = 0;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (direction > 0) {
		_tmp0_ = self->priv->_ncells - start;
	} else {
		_tmp0_ = start + 1;
	}
	length = _tmp0_;
	if (direction > 0) {
		_tmp1_ = start;
	} else {
		_tmp1_ = 0;
	}
	start = _tmp1_;
	gnonogram_region_remove_block_from_range (self, block, start, length, 1);
}


static void gnonogram_region_remove_block_from_range (Gnonogram_region* self, gint block, gint start, gint length, gint direction) {
	gboolean _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (direction < 0) {
		start = (start - length) + 1;
	}
	_tmp0_ = gnonogram_region_invalid_data (self, start, block, length);
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		{
			gint i;
			i = start;
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					if (!_tmp1_) {
						i++;
					}
					_tmp1_ = FALSE;
					if (!(i < (start + length))) {
						break;
					}
					self->priv->_tags[(i * self->priv->_tags_length2) + block] = FALSE;
				}
			}
		}
	}
}


static void gnonogram_region_set_block_complete_and_cap (Gnonogram_region* self, gint block, gint start, gint direction) {
	gint length;
	gboolean _tmp0_;
	gboolean _tmp1_ = FALSE;
	gint l = 0;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	length = self->priv->_blocks[block];
	if (direction < 0) {
		start = (start - length) + 1;
	}
	_tmp0_ = gnonogram_region_invalid_data (self, start, block, length);
	if (_tmp0_) {
		self->_in_error = TRUE;
		return;
	}
	if (self->priv->_completed_blocks[block] == TRUE) {
		_tmp1_ = self->priv->_tags[(start * self->priv->_tags_length2) + block] == FALSE;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		self->_in_error = TRUE;
		return;
	}
	self->priv->_completed_blocks[block] = TRUE;
	gnonogram_region_set_range_owner (self, block, start, length, TRUE);
	if (start > 0) {
		gnonogram_region_set_cell_empty (self, start - 1);
	}
	if ((start + length) < self->priv->_ncells) {
		gnonogram_region_set_cell_empty (self, start + length);
	}
	{
		gint cell;
		cell = start;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				if (!_tmp2_) {
					cell++;
				}
				_tmp2_ = FALSE;
				if (!(cell < (start + length))) {
					break;
				}
				gnonogram_region_set_cell_complete (self, cell);
			}
		}
	}
	if (block > 1) {
		l = 0;
		{
			gint bl;
			bl = block - 2;
			{
				gboolean _tmp3_;
				_tmp3_ = TRUE;
				while (TRUE) {
					if (!_tmp3_) {
						bl--;
					}
					_tmp3_ = FALSE;
					if (!(bl >= 0)) {
						break;
					}
					l = (l + self->priv->_blocks[bl + 1]) + 1;
					gnonogram_region_remove_block_from_range (self, bl, start - 2, l, -1);
				}
			}
		}
	}
	if (block < (self->priv->_nblocks - 2)) {
		l = 0;
		{
			gint bl;
			bl = block + 2;
			{
				gboolean _tmp4_;
				_tmp4_ = TRUE;
				while (TRUE) {
					if (!_tmp4_) {
						bl++;
					}
					_tmp4_ = FALSE;
					if (!(bl <= (self->priv->_nblocks - 1))) {
						break;
					}
					l = (l + self->priv->_blocks[bl - 1]) + 1;
					gnonogram_region_remove_block_from_range (self, bl, (start + length) + 1, l, 1);
				}
			}
		}
	}
}


static void gnonogram_region_set_range_owner (Gnonogram_region* self, gint owner, gint start, gint length, gboolean exclusive) {
	gboolean _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	_tmp0_ = gnonogram_region_invalid_data (self, start, owner, length);
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		gint block_length;
		block_length = self->priv->_blocks[owner];
		{
			gint cell;
			cell = start;
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					if (!_tmp1_) {
						cell++;
					}
					_tmp1_ = FALSE;
					if (!(cell < (start + length))) {
						break;
					}
					gnonogram_region_set_cell_owner (self, cell, owner, exclusive);
				}
			}
		}
		if (!exclusive) {
			return;
		}
		if (block_length < length) {
			self->_in_error = TRUE;
			return;
		}
		if ((((start + length) - block_length) - 1) >= 0) {
			{
				gint bl;
				bl = self->priv->_nblocks - 1;
				{
					gboolean _tmp2_;
					_tmp2_ = TRUE;
					while (TRUE) {
						if (!_tmp2_) {
							bl--;
						}
						_tmp2_ = FALSE;
						if (!(bl >= owner)) {
							break;
						}
						gnonogram_region_remove_block_from_cell_to_end (self, bl, ((start + length) - block_length) - 1, -1);
					}
				}
			}
		}
		if ((start + block_length) < self->priv->_ncells) {
			{
				gint bl;
				bl = 0;
				{
					gboolean _tmp3_;
					_tmp3_ = TRUE;
					while (TRUE) {
						if (!_tmp3_) {
							bl++;
						}
						_tmp3_ = FALSE;
						if (!(bl <= owner)) {
							break;
						}
						gnonogram_region_remove_block_from_cell_to_end (self, bl, start + block_length, 1);
					}
				}
			}
		}
	}
}


static void gnonogram_region_set_cell_owner (Gnonogram_region* self, gint cell, gint owner, gboolean exclusive) {
	gboolean _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	_tmp0_ = gnonogram_region_invalid_data (self, cell, owner, 1);
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		if (self->priv->_status[cell] == CELL_STATE_EMPTY) {
		} else {
			gboolean _tmp1_ = FALSE;
			if (self->priv->_status[cell] == CELL_STATE_COMPLETED) {
				_tmp1_ = self->priv->_tags[(cell * self->priv->_tags_length2) + owner] == FALSE;
			} else {
				_tmp1_ = FALSE;
			}
			if (_tmp1_) {
				self->_in_error = TRUE;
			} else {
				if (exclusive) {
					self->priv->_status[cell] = CELL_STATE_FILLED;
					self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
					{
						gint i;
						i = 0;
						{
							gboolean _tmp2_;
							_tmp2_ = TRUE;
							while (TRUE) {
								if (!_tmp2_) {
									i++;
								}
								_tmp2_ = FALSE;
								if (!(i < self->priv->_nblocks)) {
									break;
								}
								self->priv->_tags[(cell * self->priv->_tags_length2) + i] = FALSE;
							}
						}
					}
				}
				self->priv->_tags[(cell * self->priv->_tags_length2) + owner] = TRUE;
			}
		}
	}
}


static void gnonogram_region_set_cell_empty (Gnonogram_region* self, gint cell) {
	gboolean _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	_tmp0_ = gnonogram_region_invalid_data (self, cell, 0, 1);
	if (_tmp0_) {
		self->_in_error = TRUE;
	} else {
		if (self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] == FALSE) {
			self->_in_error = TRUE;
		} else {
			gboolean _tmp1_;
			_tmp1_ = gnonogram_region_cell_filled (self, cell);
			if (_tmp1_) {
				self->_in_error = TRUE;
			} else {
				{
					gint i;
					i = 0;
					{
						gboolean _tmp2_;
						_tmp2_ = TRUE;
						while (TRUE) {
							if (!_tmp2_) {
								i++;
							}
							_tmp2_ = FALSE;
							if (!(i < self->priv->_nblocks)) {
								break;
							}
							self->priv->_tags[(cell * self->priv->_tags_length2) + i] = FALSE;
						}
					}
				}
				self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = TRUE;
				self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
				self->priv->_status[cell] = CELL_STATE_EMPTY;
			}
		}
	}
}


static void gnonogram_region_set_cell_complete (Gnonogram_region* self, gint cell) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	if (self->priv->_status[cell] == CELL_STATE_EMPTY) {
		self->_in_error = TRUE;
	}
	self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
	self->priv->_tags[(cell * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
	self->priv->_status[cell] = CELL_STATE_COMPLETED;
}


static gboolean gnonogram_region_invalid_data (Gnonogram_region* self, gint start, gint block, gint length) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (start < 0) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = start >= self->priv->_ncells;
	}
	if (_tmp4_) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = length < 1;
	}
	if (_tmp3_) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = (start + length) > self->priv->_ncells;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = block < 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = block > self->priv->_nblocks;
	}
	result = _tmp0_;
	return result;
}


static gboolean gnonogram_region_cell_filled (Gnonogram_region* self, gint cell) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_status[cell] == CELL_STATE_FILLED) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = self->priv->_status[cell] == CELL_STATE_COMPLETED;
	}
	result = _tmp0_;
	return result;
}


static gboolean gnonogram_region_totals_changed (Gnonogram_region* self) {
	gboolean result = FALSE;
	gboolean changed;
	gint _tmp0_;
	gint unknown;
	gint _tmp1_;
	gint filled;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_REGION (self), FALSE);
	if (self->priv->_cycles == 0) {
		result = TRUE;
		return result;
	}
	changed = FALSE;
	_tmp0_ = gnonogram_region_count_cell_state (self, CELL_STATE_UNKNOWN);
	unknown = _tmp0_;
	_tmp1_ = gnonogram_region_count_cell_state (self, CELL_STATE_FILLED);
	filled = _tmp1_;
	if (self->priv->_unknown != unknown) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = self->priv->_filled != filled;
	}
	if (_tmp2_) {
		changed = TRUE;
		self->priv->_unknown = unknown;
		self->priv->_filled = filled;
		if (self->priv->_filled > self->priv->_block_total) {
			self->_in_error = TRUE;
		}
	}
	result = changed;
	return result;
}


static void gnonogram_region_get_status (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	my2_dcell_array_get_array (self->priv->_grid, self->priv->_index, self->priv->_is_column, &self->priv->_temp_status, &self->priv->_temp_status_length1, 0);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				switch (self->priv->_temp_status[i]) {
					case CELL_STATE_UNKNOWN:
					{
						break;
					}
					case CELL_STATE_EMPTY:
					{
						gboolean _tmp1_;
						_tmp1_ = gnonogram_region_cell_filled (self, i);
						if (_tmp1_) {
							self->_in_error = TRUE;
						} else {
							self->priv->_status[i] = CELL_STATE_EMPTY;
						}
						break;
					}
					case CELL_STATE_FILLED:
					{
						if (self->priv->_status[i] != CELL_STATE_COMPLETED) {
							self->priv->_status[i] = CELL_STATE_FILLED;
						}
						break;
					}
					default:
					{
						break;
					}
				}
			}
		}
	}
}


static void gnonogram_region_put_status (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				CellState _tmp1_ = 0;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_status[i] == CELL_STATE_COMPLETED) {
					_tmp1_ = CELL_STATE_FILLED;
				} else {
					_tmp1_ = self->priv->_status[i];
				}
				self->priv->_temp_status[i] = _tmp1_;
			}
		}
	}
	my2_dcell_array_set_array (self->priv->_grid, self->priv->_index, self->priv->_is_column, self->priv->_temp_status, self->priv->_temp_status_length1, 0);
}


static void gnonogram_region_status_to_tags (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				switch (self->priv->_status[i]) {
					case CELL_STATE_COMPLETED:
					{
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
						break;
					}
					case CELL_STATE_FILLED:
					{
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = FALSE;
						break;
					}
					case CELL_STATE_EMPTY:
					{
						{
							gint j;
							j = 0;
							{
								gboolean _tmp1_;
								_tmp1_ = TRUE;
								while (TRUE) {
									if (!_tmp1_) {
										j++;
									}
									_tmp1_ = FALSE;
									if (!(j < self->priv->_nblocks)) {
										break;
									}
									self->priv->_tags[(i * self->priv->_tags_length2) + j] = FALSE;
								}
							}
						}
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr] = TRUE;
						self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_is_finished_ptr] = TRUE;
						break;
					}
					default:
					{
						break;
					}
				}
			}
		}
	}
}


static void gnonogram_region_tags_to_status (Gnonogram_region* self) {
	g_return_if_fail (IS_GNONOGRAM_REGION (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_ncells)) {
					break;
				}
				if (self->priv->_status[i] != CELL_STATE_UNKNOWN) {
					_tmp1_ = TRUE;
				} else {
					gint _tmp2_;
					_tmp2_ = gnonogram_region_count_owners_and_empty (self, i);
					_tmp1_ = _tmp2_ > 1;
				}
				if (_tmp1_) {
					continue;
				}
				if (self->priv->_tags[(i * self->priv->_tags_length2) + self->priv->_can_be_empty_ptr]) {
					self->priv->_status[i] = CELL_STATE_EMPTY;
				} else {
					self->priv->_status[i] = CELL_STATE_FILLED;
				}
			}
		}
	}
}


static void value_gnonogram_region_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_gnonogram_region_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gnonogram_region_unref (value->data[0].v_pointer);
	}
}


static void value_gnonogram_region_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gnonogram_region_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_gnonogram_region_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_gnonogram_region_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Gnonogram_region* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gnonogram_region_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_gnonogram_region_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Gnonogram_region** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gnonogram_region_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_gnonogram_region (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGnonogram_region* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GNONOGRAM_REGION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_gnonogram_region (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_REGION), NULL);
	return value->data[0].v_pointer;
}


void value_set_gnonogram_region (GValue* value, gpointer v_object) {
	Gnonogram_region* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_REGION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_REGION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gnonogram_region_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_region_unref (old);
	}
}


void value_take_gnonogram_region (GValue* value, gpointer v_object) {
	Gnonogram_region* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_REGION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_REGION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_region_unref (old);
	}
}


static void gnonogram_region_class_init (Gnonogram_regionClass * klass) {
	gnonogram_region_parent_class = g_type_class_peek_parent (klass);
	GNONOGRAM_REGION_CLASS (klass)->finalize = gnonogram_region_finalize;
	g_type_class_add_private (klass, sizeof (Gnonogram_regionPrivate));
}


static void gnonogram_region_instance_init (Gnonogram_region * self) {
	self->priv = GNONOGRAM_REGION_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gnonogram_region_finalize (Gnonogram_region* obj) {
	Gnonogram_region * self;
	self = GNONOGRAM_REGION (obj);
	self->priv->_completed_blocks = (g_free (self->priv->_completed_blocks), NULL);
	self->priv->_tags = (g_free (self->priv->_tags), NULL);
	self->priv->_ranges = (g_free (self->priv->_ranges), NULL);
	self->priv->_blocks = (g_free (self->priv->_blocks), NULL);
	_my2_dcell_array_unref0 (self->priv->_grid);
	self->priv->_status = (g_free (self->priv->_status), NULL);
	self->priv->_temp_status = (g_free (self->priv->_temp_status), NULL);
}


GType gnonogram_region_get_type (void) {
	static volatile gsize gnonogram_region_type_id__volatile = 0;
	if (g_once_init_enter (&gnonogram_region_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_gnonogram_region_init, value_gnonogram_region_free_value, value_gnonogram_region_copy_value, value_gnonogram_region_peek_pointer, "p", value_gnonogram_region_collect_value, "p", value_gnonogram_region_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (Gnonogram_regionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnonogram_region_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Gnonogram_region), 0, (GInstanceInitFunc) gnonogram_region_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gnonogram_region_type_id;
		gnonogram_region_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Gnonogram_region", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gnonogram_region_type_id__volatile, gnonogram_region_type_id);
	}
	return gnonogram_region_type_id__volatile;
}


gpointer gnonogram_region_ref (gpointer instance) {
	Gnonogram_region* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gnonogram_region_unref (gpointer instance) {
	Gnonogram_region* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GNONOGRAM_REGION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}




/* Gnonogram_filereader.c generated by valac 0.11.6, the Vala compiler
 * generated from Gnonogram_filereader.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 * 
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <gobject/gvaluecollector.h>


#define TYPE_GNONOGRAM_FILEREADER (gnonogram_filereader_get_type ())
#define GNONOGRAM_FILEREADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereader))
#define GNONOGRAM_FILEREADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereaderClass))
#define IS_GNONOGRAM_FILEREADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_FILEREADER))
#define IS_GNONOGRAM_FILEREADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_FILEREADER))
#define GNONOGRAM_FILEREADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereaderClass))

typedef struct _Gnonogram_filereader Gnonogram_filereader;
typedef struct _Gnonogram_filereaderClass Gnonogram_filereaderClass;
typedef struct _Gnonogram_filereaderPrivate Gnonogram_filereaderPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_GNONOGRAM_FILETYPE (gnonogram_filetype_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_CELL_STATE (cell_state_get_type ())
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _ParamSpecGnonogram_filereader ParamSpecGnonogram_filereader;

struct _Gnonogram_filereader {
	GTypeInstance parent_instance;
	volatile int ref_count;
	Gnonogram_filereaderPrivate * priv;
	gchar* filename;
	gint rows;
	gint cols;
	gchar** row_clues;
	gint row_clues_length1;
	gchar** col_clues;
	gint col_clues_length1;
	gchar* state;
	gchar* name;
	gchar* author;
	gchar* date;
	gchar* score;
	gboolean in_error;
	gboolean has_dimensions;
	gboolean has_row_clues;
	gboolean has_col_clues;
	gboolean has_solution;
	gboolean has_working;
	gboolean has_state;
	gchar** solution;
	gint solution_length1;
	gchar** working;
	gint working_length1;
};

struct _Gnonogram_filereaderClass {
	GTypeClass parent_class;
	void (*finalize) (Gnonogram_filereader *self);
};

struct _Gnonogram_filereaderPrivate {
	GDataInputStream* stream;
	gboolean is_game;
	gboolean is_picto_game;
	gchar** headings;
	gint headings_length1;
	gint _headings_size_;
	gchar** bodies;
	gint bodies_length1;
	gint _bodies_size_;
	gchar** picto_grid_data;
	gint picto_grid_data_length1;
	gint _picto_grid_data_size_;
};

typedef enum  {
	GNONOGRAM_FILETYPE_GAME,
	GNONOGRAM_FILETYPE_POSITION
} Gnonogram_FileType;

typedef enum  {
	CELL_STATE_UNKNOWN,
	CELL_STATE_EMPTY,
	CELL_STATE_FILLED,
	CELL_STATE_ERROR,
	CELL_STATE_COMPLETED
} CellState;

struct _ParamSpecGnonogram_filereader {
	GParamSpec parent_instance;
};


static gpointer gnonogram_filereader_parent_class = NULL;
extern gchar* resource_game_dir;

gpointer gnonogram_filereader_ref (gpointer instance);
void gnonogram_filereader_unref (gpointer instance);
GParamSpec* param_spec_gnonogram_filereader (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_gnonogram_filereader (GValue* value, gpointer v_object);
void value_take_gnonogram_filereader (GValue* value, gpointer v_object);
gpointer value_get_gnonogram_filereader (const GValue* value);
GType gnonogram_filereader_get_type (void) G_GNUC_CONST;
#define GNONOGRAM_FILEREADER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GNONOGRAM_FILEREADER, Gnonogram_filereaderPrivate))
enum  {
	GNONOGRAM_FILEREADER_DUMMY_PROPERTY
};
GType gnonogram_filetype_get_type (void) G_GNUC_CONST;
Gnonogram_filereader* gnonogram_filereader_new (Gnonogram_FileType type);
Gnonogram_filereader* gnonogram_filereader_construct (GType object_type, Gnonogram_FileType type);
void gnonogram_filereader_ask_filename (Gnonogram_filereader* self);
#define RESOURCE_POSITIONFILENAME "currentposition"
gchar* utils_get_filename (GtkFileChooserAction action, const gchar* dialogname, gchar** filternames, int filternames_length1, gchar** filters, int filters_length1, const gchar* start_path);
#define RESOURCE_GAMEFILEEXTENSION ".gno"
gboolean gnonogram_filereader_open_datainputstream (Gnonogram_filereader* self);
GDataInputStream* utils_open_datainputstream (const gchar* filename);
gboolean gnonogram_filereader_parse_game_file (Gnonogram_filereader* self);
static gboolean gnonogram_filereader_parse_picto_game_file (Gnonogram_filereader* self);
static gboolean gnonogram_filereader_parse_gnonogram_game_file (Gnonogram_filereader* self);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value);
void utils_show_warning_dialog (const gchar* msg);
static gboolean gnonogram_filereader_parse_gnonogram_headings_and_bodies (Gnonogram_filereader* self);
static void _vala_array_add3 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value);
static void _vala_array_add6 (gchar*** array, int* length, int* size, gchar* value);
static gboolean gnonogram_filereader_get_game_description (Gnonogram_filereader* self, const gchar* body);
static gboolean gnonogram_filereader_get_picto_dimensions (Gnonogram_filereader* self, const gchar* body, gboolean is_column);
static gboolean gnonogram_filereader_parse_picto_grid_data (Gnonogram_filereader* self);
static gboolean gnonogram_filereader_get_gnonogram_dimensions (Gnonogram_filereader* self, const gchar* body);
static gboolean gnonogram_filereader_get_gnonogram_clues (Gnonogram_filereader* self, const gchar* body, gboolean is_column);
static gboolean gnonogram_filereader_get_gnonogram_cellstate_array (Gnonogram_filereader* self, const gchar* body, gboolean is_solution);
static gboolean gnonogram_filereader_get_gnonogram_state (Gnonogram_filereader* self, const gchar* body);
gchar** utils_remove_blank_lines (gchar** sa, int sa_length1, int* result_length1);
static gchar* gnonogram_filereader_parse_gnonogram_clue (Gnonogram_filereader* self, const gchar* line);
static void _vala_array_add7 (gchar*** array, int* length, int* size, gchar* value);
static gchar** _vala_array_dup1 (gchar** self, int length);
static gchar** _vala_array_dup2 (gchar** self, int length);
GType cell_state_get_type (void) G_GNUC_CONST;
CellState* utils_cellstate_array_from_string (const gchar* s, int* result_length1);
static gchar** _vala_array_dup3 (gchar** self, int length);
static gchar** _vala_array_dup4 (gchar** self, int length);
gchar* utils_gnonogram_string_from_hex_string (const gchar* s, gint pad_to_length);
gchar* utils_convert_html (const gchar* html);
#define RESOURCE_BLOCKSEPARATOR ","
static void gnonogram_filereader_finalize (Gnonogram_filereader* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


Gnonogram_filereader* gnonogram_filereader_construct (GType object_type, Gnonogram_FileType type) {
	Gnonogram_filereader* self = NULL;
	self = (Gnonogram_filereader*) g_type_create_instance (object_type);
	if (type == GNONOGRAM_FILETYPE_GAME) {
		gboolean _tmp0_;
		gnonogram_filereader_ask_filename (self);
		_tmp0_ = g_str_has_suffix (self->filename, ".pattern");
		if (_tmp0_) {
			self->priv->is_picto_game = TRUE;
		} else {
			self->priv->is_picto_game = FALSE;
		}
		self->priv->is_game = TRUE;
	} else {
		gchar* _tmp1_;
		gchar* _tmp2_;
		_tmp1_ = g_strconcat (resource_game_dir, "/", NULL);
		_tmp2_ = g_strconcat (_tmp1_, RESOURCE_POSITIONFILENAME, NULL);
		_g_free0 (self->filename);
		self->filename = _tmp2_;
		_g_free0 (_tmp1_);
		self->priv->is_game = FALSE;
	}
	return self;
}


Gnonogram_filereader* gnonogram_filereader_new (Gnonogram_FileType type) {
	return gnonogram_filereader_construct (TYPE_GNONOGRAM_FILEREADER, type);
}


void gnonogram_filereader_ask_filename (Gnonogram_filereader* self) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_;
	gint _tmp6__length1;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar** _tmp9_ = NULL;
	gchar** _tmp10_;
	gint _tmp10__length1;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_;
	g_return_if_fail (IS_GNONOGRAM_FILEREADER (self));
	_tmp0_ = _ ("Choose a game");
	_tmp1_ = _ ("Gnonogram games");
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = _ ("Picto games");
	_tmp4_ = g_strdup (_tmp3_);
	_tmp5_ = g_new0 (gchar*, 2 + 1);
	_tmp5_[0] = _tmp2_;
	_tmp5_[1] = _tmp4_;
	_tmp6_ = _tmp5_;
	_tmp6__length1 = 2;
	_tmp7_ = g_strdup ("*" RESOURCE_GAMEFILEEXTENSION);
	_tmp8_ = g_strdup ("*.pattern");
	_tmp9_ = g_new0 (gchar*, 2 + 1);
	_tmp9_[0] = _tmp7_;
	_tmp9_[1] = _tmp8_;
	_tmp10_ = _tmp9_;
	_tmp10__length1 = 2;
	_tmp11_ = utils_get_filename (GTK_FILE_CHOOSER_ACTION_OPEN, _tmp0_, _tmp6_, 2, _tmp10_, 2, resource_game_dir);
	_tmp12_ = _tmp11_;
	_g_free0 (self->filename);
	self->filename = _tmp12_;
	_tmp10_ = (_vala_array_free (_tmp10_, _tmp10__length1, (GDestroyNotify) g_free), NULL);
	_tmp6_ = (_vala_array_free (_tmp6_, _tmp6__length1, (GDestroyNotify) g_free), NULL);
}


gboolean gnonogram_filereader_open_datainputstream (Gnonogram_filereader* self) {
	gboolean result = FALSE;
	GDataInputStream* _tmp0_ = NULL;
	GDataInputStream* _tmp1_;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	_tmp0_ = utils_open_datainputstream (self->filename);
	_tmp1_ = _tmp0_;
	_g_object_unref0 (self->priv->stream);
	self->priv->stream = _tmp1_;
	if (self->priv->stream == NULL) {
		result = FALSE;
		return result;
	} else {
		result = TRUE;
		return result;
	}
}


gboolean gnonogram_filereader_parse_game_file (Gnonogram_filereader* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (self->priv->is_picto_game) {
		gboolean _tmp0_;
		_tmp0_ = gnonogram_filereader_parse_picto_game_file (self);
		result = _tmp0_;
		return result;
	} else {
		gboolean _tmp1_;
		_tmp1_ = gnonogram_filereader_parse_gnonogram_game_file (self);
		result = _tmp1_;
		return result;
	}
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add2 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean gnonogram_filereader_parse_gnonogram_game_file (Gnonogram_filereader* self) {
	gboolean result = FALSE;
	gsize headerlength = 0UL;
	gsize bodylength = 0UL;
	gsize _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gboolean _tmp10_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	_tmp1_ = g_data_input_stream_read_until (self->priv->stream, "[", &_tmp0_, NULL, &_inner_error_);
	headerlength = _tmp0_;
	_tmp2_ = _tmp1_;
	_g_free0 (_tmp2_);
	if (_inner_error_ != NULL) {
		goto __catch4_g_error;
	}
	while (TRUE) {
		gsize _tmp3_;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gsize _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		gboolean _tmp9_ = FALSE;
		_tmp4_ = g_data_input_stream_read_until (self->priv->stream, "]", &_tmp3_, NULL, &_inner_error_);
		headerlength = _tmp3_;
		_tmp5_ = _tmp4_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		_vala_array_add1 (&self->priv->headings, &self->priv->headings_length1, &self->priv->_headings_size_, _tmp5_);
		_tmp7_ = g_data_input_stream_read_until (self->priv->stream, "[", &_tmp6_, NULL, &_inner_error_);
		bodylength = _tmp6_;
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		_vala_array_add2 (&self->priv->bodies, &self->priv->bodies_length1, &self->priv->_bodies_size_, _tmp8_);
		if (headerlength == 0) {
			_tmp9_ = TRUE;
		} else {
			_tmp9_ = bodylength == 0;
		}
		if (_tmp9_) {
			break;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		utils_show_warning_dialog (e->message);
		result = FALSE;
		_g_error_free0 (e);
		return result;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp10_ = gnonogram_filereader_parse_gnonogram_headings_and_bodies (self);
	result = _tmp10_;
	return result;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}


static void _vala_array_add3 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add4 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add5 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar* string_chomp (const gchar* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _result_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strchomp (_result_);
	result = _result_;
	return result;
}


static void _vala_array_add6 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean gnonogram_filereader_parse_picto_game_file (Gnonogram_filereader* self) {
	gboolean result = FALSE;
	gchar* line = NULL;
	gsize length = 0UL;
	gsize _tmp14_;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_;
	gchar* _tmp17_;
	gboolean _tmp27_ = FALSE;
	gboolean _tmp28_ = FALSE;
	gboolean _tmp29_ = FALSE;
	gchar* _tmp30_;
	gchar* _tmp31_;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gboolean _tmp34_;
	gboolean _tmp35_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gsize _tmp1_;
				gchar* _tmp2_ = NULL;
				gchar* _tmp3_;
				gchar* _tmp4_;
				gchar** _tmp5_;
				gchar** _tmp6_ = NULL;
				gchar** s;
				gint s_length1;
				gint _s_size_;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_;
				gboolean _tmp10_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < 5)) {
					break;
				}
				_tmp2_ = g_data_input_stream_read_line (self->priv->stream, &_tmp1_, NULL, &_inner_error_);
				length = _tmp1_;
				_tmp3_ = _tmp2_;
				if (_inner_error_ != NULL) {
					goto __catch5_g_error;
				}
				_tmp4_ = _tmp3_;
				_g_free0 (line);
				line = _tmp4_;
				_tmp6_ = _tmp5_ = g_strsplit (line, ":", 0);
				s = _tmp6_;
				s_length1 = _vala_array_length (_tmp5_);
				_s_size_ = _vala_array_length (_tmp5_);
				_tmp7_ = string_strip (s[0]);
				_vala_array_add3 (&self->priv->headings, &self->priv->headings_length1, &self->priv->_headings_size_, _tmp7_);
				_tmp8_ = string_strip (s[1]);
				_tmp9_ = _tmp8_;
				if ((_tmp10_ = g_strcmp0 (_tmp9_, "") == 0, _g_free0 (_tmp9_), _tmp10_)) {
					const gchar* _tmp11_ = NULL;
					gchar* _tmp12_;
					_tmp11_ = _ ("Unknown");
					_tmp12_ = g_strdup (_tmp11_);
					_vala_array_add4 (&self->priv->bodies, &self->priv->bodies_length1, &self->priv->_bodies_size_, _tmp12_);
				} else {
					gchar* _tmp13_ = NULL;
					_tmp13_ = string_strip (s[1]);
					_vala_array_add5 (&self->priv->bodies, &self->priv->bodies_length1, &self->priv->_bodies_size_, _tmp13_);
				}
				s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
			}
		}
	}
	_tmp15_ = g_data_input_stream_read_line (self->priv->stream, &_tmp14_, NULL, &_inner_error_);
	length = _tmp14_;
	_tmp16_ = _tmp15_;
	if (_inner_error_ != NULL) {
		goto __catch5_g_error;
	}
	_tmp17_ = _tmp16_;
	_g_free0 (line);
	line = _tmp17_;
	while (TRUE) {
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_;
		gchar* _tmp20_ = NULL;
		gchar* _tmp21_;
		gsize _tmp23_;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_;
		gchar* _tmp26_;
		if (!(line != NULL)) {
			break;
		}
		_tmp18_ = string_chomp (line);
		_tmp19_ = _tmp18_;
		_tmp20_ = string_strip (_tmp19_);
		_tmp21_ = _tmp20_;
		_g_free0 (line);
		line = _tmp21_;
		_g_free0 (_tmp19_);
		if (line != NULL) {
			gchar* _tmp22_;
			_tmp22_ = g_strdup (line);
			_vala_array_add6 (&self->priv->picto_grid_data, &self->priv->picto_grid_data_length1, &self->priv->_picto_grid_data_size_, _tmp22_);
		}
		_tmp24_ = g_data_input_stream_read_line (self->priv->stream, &_tmp23_, NULL, &_inner_error_);
		length = _tmp23_;
		_tmp25_ = _tmp24_;
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
		_tmp26_ = _tmp25_;
		_g_free0 (line);
		line = _tmp26_;
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		utils_show_warning_dialog (e->message);
		result = FALSE;
		_g_error_free0 (e);
		_g_free0 (line);
		return result;
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_free0 (line);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp30_ = g_strconcat (self->priv->bodies[0], "\n", NULL);
	_tmp31_ = g_strconcat (_tmp30_, self->priv->bodies[1], NULL);
	_tmp32_ = g_strconcat (_tmp31_, "\n", NULL);
	_tmp33_ = g_strconcat (_tmp32_, self->priv->bodies[2], NULL);
	_tmp34_ = gnonogram_filereader_get_game_description (self, _tmp33_);
	if ((_tmp35_ = _tmp34_, _g_free0 (_tmp33_), _g_free0 (_tmp32_), _g_free0 (_tmp31_), _g_free0 (_tmp30_), _tmp35_)) {
		gboolean _tmp36_;
		_tmp36_ = gnonogram_filereader_get_picto_dimensions (self, self->priv->bodies[3], TRUE);
		_tmp29_ = _tmp36_;
	} else {
		_tmp29_ = FALSE;
	}
	if (_tmp29_) {
		gboolean _tmp37_;
		_tmp37_ = gnonogram_filereader_get_picto_dimensions (self, self->priv->bodies[4], FALSE);
		_tmp28_ = _tmp37_;
	} else {
		_tmp28_ = FALSE;
	}
	if (_tmp28_) {
		gboolean _tmp38_;
		_tmp38_ = gnonogram_filereader_parse_picto_grid_data (self);
		_tmp27_ = _tmp38_;
	} else {
		_tmp27_ = FALSE;
	}
	result = _tmp27_;
	_g_free0 (line);
	return result;
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	gint _tmp0_;
	glong string_length;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	string_length = (glong) _tmp0_;
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp1_ = start <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	if (end >= 0) {
		_tmp2_ = end <= string_length;
	} else {
		_tmp2_ = FALSE;
	}
	g_return_val_if_fail (_tmp2_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + start, (gsize) (end - start));
	result = _tmp3_;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static gboolean gnonogram_filereader_parse_gnonogram_headings_and_bodies (Gnonogram_filereader* self) {
	gboolean result = FALSE;
	gint n;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	n = self->priv->headings_length1;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gchar* _tmp1_;
				gchar* heading;
				gint _tmp2_;
				gchar* _tmp5_ = NULL;
				gchar* _tmp6_;
				GQuark _tmp7_;
				static GQuark _tmp7__label0 = 0;
				static GQuark _tmp7__label1 = 0;
				static GQuark _tmp7__label2 = 0;
				static GQuark _tmp7__label3 = 0;
				static GQuark _tmp7__label4 = 0;
				static GQuark _tmp7__label5 = 0;
				static GQuark _tmp7__label6 = 0;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < n)) {
					break;
				}
				_tmp1_ = g_strdup (self->priv->headings[i]);
				heading = _tmp1_;
				if (heading == NULL) {
					_g_free0 (heading);
					continue;
				}
				_tmp2_ = strlen (heading);
				if (_tmp2_ > 3) {
					gchar* _tmp3_ = NULL;
					gchar* _tmp4_;
					_tmp3_ = string_slice (heading, (glong) 0, (glong) 3);
					_tmp4_ = _tmp3_;
					_g_free0 (heading);
					heading = _tmp4_;
				}
				_tmp5_ = g_utf8_strup (heading, (gssize) (-1));
				_tmp6_ = _tmp5_;
				_tmp7_ = (NULL == _tmp6_) ? 0 : g_quark_from_string (_tmp6_);
				g_free (_tmp6_);
				if (_tmp7_ == ((0 != _tmp7__label0) ? _tmp7__label0 : (_tmp7__label0 = g_quark_from_static_string ("DIM")))) {
					switch (0) {
						default:
						{
							gboolean _tmp8_;
							_tmp8_ = gnonogram_filereader_get_gnonogram_dimensions (self, self->priv->bodies[i]);
							self->in_error = !_tmp8_;
							break;
						}
					}
				} else if (_tmp7_ == ((0 != _tmp7__label1) ? _tmp7__label1 : (_tmp7__label1 = g_quark_from_static_string ("ROW")))) {
					switch (0) {
						default:
						{
							gboolean _tmp9_;
							_tmp9_ = gnonogram_filereader_get_gnonogram_clues (self, self->priv->bodies[i], FALSE);
							self->in_error = !_tmp9_;
							break;
						}
					}
				} else if (_tmp7_ == ((0 != _tmp7__label2) ? _tmp7__label2 : (_tmp7__label2 = g_quark_from_static_string ("COL")))) {
					switch (0) {
						default:
						{
							gboolean _tmp10_;
							_tmp10_ = gnonogram_filereader_get_gnonogram_clues (self, self->priv->bodies[i], TRUE);
							self->in_error = !_tmp10_;
							break;
						}
					}
				} else if (_tmp7_ == ((0 != _tmp7__label3) ? _tmp7__label3 : (_tmp7__label3 = g_quark_from_static_string ("SOL")))) {
					switch (0) {
						default:
						{
							gboolean _tmp11_;
							_tmp11_ = gnonogram_filereader_get_gnonogram_cellstate_array (self, self->priv->bodies[i], TRUE);
							self->in_error = !_tmp11_;
							break;
						}
					}
				} else if (_tmp7_ == ((0 != _tmp7__label4) ? _tmp7__label4 : (_tmp7__label4 = g_quark_from_static_string ("WOR")))) {
					switch (0) {
						default:
						{
							gboolean _tmp12_;
							_tmp12_ = gnonogram_filereader_get_gnonogram_cellstate_array (self, self->priv->bodies[i], FALSE);
							self->in_error = !_tmp12_;
							break;
						}
					}
				} else if (_tmp7_ == ((0 != _tmp7__label5) ? _tmp7__label5 : (_tmp7__label5 = g_quark_from_static_string ("STA")))) {
					switch (0) {
						default:
						{
							gboolean _tmp13_;
							_tmp13_ = gnonogram_filereader_get_gnonogram_state (self, self->priv->bodies[i]);
							self->in_error = !_tmp13_;
							break;
						}
					}
				} else if (_tmp7_ == ((0 != _tmp7__label6) ? _tmp7__label6 : (_tmp7__label6 = g_quark_from_static_string ("DES")))) {
					switch (0) {
						default:
						{
							gboolean _tmp14_;
							_tmp14_ = gnonogram_filereader_get_game_description (self, self->priv->bodies[i]);
							self->in_error = !_tmp14_;
							break;
						}
					}
				} else {
					switch (0) {
						default:
						{
							const gchar* _tmp15_ = NULL;
							gchar* _tmp16_ = NULL;
							gchar* _tmp17_;
							_tmp15_ = string_to_string (heading);
							_tmp16_ = g_strconcat ("Unrecognised heading ", _tmp15_, " ", NULL);
							_tmp17_ = _tmp16_;
							utils_show_warning_dialog (_tmp17_);
							_g_free0 (_tmp17_);
							self->in_error = TRUE;
							break;
						}
					}
				}
				if (self->in_error) {
					result = FALSE;
					_g_free0 (heading);
					return result;
				}
				_g_free0 (heading);
			}
		}
	}
	result = TRUE;
	return result;
}


static gboolean gnonogram_filereader_get_gnonogram_dimensions (Gnonogram_filereader* self, const gchar* body) {
	gboolean result = FALSE;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gchar** s;
	gint s_length1;
	gint _s_size_;
	gint _tmp6_;
	gint _tmp7_;
	gboolean _tmp8_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (body == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = _tmp0_ = g_strsplit (body, "\n", 0);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _vala_array_length (_tmp0_);
	_tmp4_ = utils_remove_blank_lines (_tmp2_, _vala_array_length (_tmp0_), &_tmp3_);
	s = (_tmp5_ = _tmp4_, _tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL), _tmp5_);
	s_length1 = _tmp3_;
	_s_size_ = _tmp3_;
	if (s_length1 != 2) {
		utils_show_warning_dialog ("Wrong number of dimensions");
		result = FALSE;
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp6_ = atoi (s[0]);
	self->rows = _tmp6_;
	_tmp7_ = atoi (s[1]);
	self->cols = _tmp7_;
	self->has_dimensions = TRUE;
	if (self->rows > 0) {
		_tmp8_ = self->cols > 0;
	} else {
		_tmp8_ = FALSE;
	}
	result = _tmp8_;
	s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean gnonogram_filereader_get_picto_dimensions (Gnonogram_filereader* self, const gchar* body, gboolean is_column) {
	gboolean result = FALSE;
	gint _tmp0_;
	gint dim;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (body == NULL) {
		result = FALSE;
		return result;
	}
	_tmp0_ = atoi (body);
	dim = _tmp0_;
	if (is_column) {
		self->cols = dim;
	} else {
		self->rows = dim;
	}
	if (self->rows > 0) {
		_tmp1_ = self->cols > 0;
	} else {
		_tmp1_ = FALSE;
	}
	self->has_dimensions = _tmp1_;
	result = dim > 0;
	return result;
}


static void _vala_array_add7 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static gboolean gnonogram_filereader_get_gnonogram_clues (Gnonogram_filereader* self, const gchar* body, gboolean is_column) {
	gboolean result = FALSE;
	gchar** _tmp0_ = NULL;
	gchar** arr;
	gint arr_length1;
	gint _arr_size_;
	gchar** _tmp1_;
	gchar** _tmp2_ = NULL;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gint _tmp4_;
	gchar** _tmp5_ = NULL;
	gchar** _tmp6_;
	gchar** s;
	gint s_length1;
	gint _s_size_;
	gboolean _tmp7_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	_tmp0_ = g_new0 (gchar*, 0 + 1);
	arr = _tmp0_;
	arr_length1 = 0;
	_arr_size_ = 0;
	if (body == NULL) {
		result = FALSE;
		arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp2_ = _tmp1_ = g_strsplit (body, "\n", 0);
	_tmp3_ = _tmp2_;
	_tmp3__length1 = _vala_array_length (_tmp1_);
	_tmp5_ = utils_remove_blank_lines (_tmp3_, _vala_array_length (_tmp1_), &_tmp4_);
	s = (_tmp6_ = _tmp5_, _tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL), _tmp6_);
	s_length1 = _tmp4_;
	_s_size_ = _tmp4_;
	if (s == NULL) {
		_tmp7_ = TRUE;
	} else {
		_tmp7_ = s_length1 < 1;
	}
	if (_tmp7_) {
		result = FALSE;
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				gchar* _tmp9_ = NULL;
				if (!_tmp8_) {
					i++;
				}
				_tmp8_ = FALSE;
				if (!(i < s_length1)) {
					break;
				}
				_tmp9_ = gnonogram_filereader_parse_gnonogram_clue (self, s[i]);
				_vala_array_add7 (&arr, &arr_length1, &_arr_size_, _tmp9_);
			}
		}
	}
	if (is_column) {
		gchar** _tmp10_;
		gchar** _tmp11_;
		gchar** _tmp12_;
		if (arr_length1 != self->cols) {
			result = FALSE;
			s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
			arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
			return result;
		}
		_tmp10_ = (_tmp11_ = arr, (_tmp11_ == NULL) ? ((gpointer) _tmp11_) : _vala_array_dup1 (_tmp11_, arr_length1));
		_tmp12_ = _tmp10_;
		self->col_clues = (_vala_array_free (self->col_clues, self->col_clues_length1, (GDestroyNotify) g_free), NULL);
		self->col_clues_length1 = arr_length1;
		self->col_clues = _tmp12_;
		self->has_col_clues = TRUE;
	} else {
		gchar** _tmp13_;
		gchar** _tmp14_;
		gchar** _tmp15_;
		if (arr_length1 != self->rows) {
			result = FALSE;
			s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
			arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
			return result;
		}
		_tmp13_ = (_tmp14_ = arr, (_tmp14_ == NULL) ? ((gpointer) _tmp14_) : _vala_array_dup2 (_tmp14_, arr_length1));
		_tmp15_ = _tmp13_;
		self->row_clues = (_vala_array_free (self->row_clues, self->row_clues_length1, (GDestroyNotify) g_free), NULL);
		self->row_clues_length1 = arr_length1;
		self->row_clues = _tmp15_;
		self->has_row_clues = TRUE;
	}
	result = TRUE;
	s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	arr = (_vala_array_free (arr, arr_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gchar** _vala_array_dup3 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static gchar** _vala_array_dup4 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		result[i] = g_strdup (self[i]);
	}
	return result;
}


static gboolean gnonogram_filereader_get_gnonogram_cellstate_array (Gnonogram_filereader* self, const gchar* body, gboolean is_solution) {
	gboolean result = FALSE;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gchar** s;
	gint s_length1;
	gint _s_size_;
	gboolean _tmp6_ = FALSE;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (body == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = _tmp0_ = g_strsplit (body, "\n", 0);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _vala_array_length (_tmp0_);
	_tmp4_ = utils_remove_blank_lines (_tmp2_, _vala_array_length (_tmp0_), &_tmp3_);
	s = (_tmp5_ = _tmp4_, _tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL), _tmp5_);
	s_length1 = _tmp3_;
	_s_size_ = _tmp3_;
	if (s == NULL) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = s_length1 != self->rows;
	}
	if (_tmp6_) {
		result = FALSE;
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				gint _tmp8_;
				CellState* _tmp9_ = NULL;
				CellState* arr;
				gint arr_length1;
				gint _arr_size_;
				if (!_tmp7_) {
					i++;
				}
				_tmp7_ = FALSE;
				if (!(i < s_length1)) {
					break;
				}
				_tmp9_ = utils_cellstate_array_from_string (s[i], &_tmp8_);
				arr = _tmp9_;
				arr_length1 = _tmp8_;
				_arr_size_ = _tmp8_;
				if (arr_length1 != self->cols) {
					result = FALSE;
					arr = (g_free (arr), NULL);
					s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				arr = (g_free (arr), NULL);
			}
		}
	}
	if (is_solution) {
		gchar** _tmp10_;
		gchar** _tmp11_;
		gchar** _tmp12_;
		_tmp10_ = (_tmp11_ = s, (_tmp11_ == NULL) ? ((gpointer) _tmp11_) : _vala_array_dup3 (_tmp11_, s_length1));
		_tmp12_ = _tmp10_;
		self->solution = (_vala_array_free (self->solution, self->solution_length1, (GDestroyNotify) g_free), NULL);
		self->solution_length1 = s_length1;
		self->solution = _tmp12_;
		self->has_solution = TRUE;
	} else {
		gchar** _tmp13_;
		gchar** _tmp14_;
		gchar** _tmp15_;
		_tmp13_ = (_tmp14_ = s, (_tmp14_ == NULL) ? ((gpointer) _tmp14_) : _vala_array_dup4 (_tmp14_, s_length1));
		_tmp15_ = _tmp13_;
		self->working = (_vala_array_free (self->working, self->working_length1, (GDestroyNotify) g_free), NULL);
		self->working_length1 = s_length1;
		self->working = _tmp15_;
		self->has_working = TRUE;
	}
	result = TRUE;
	s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean gnonogram_filereader_parse_picto_grid_data (Gnonogram_filereader* self) {
	gboolean result = FALSE;
	gint _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gboolean _tmp3_ = FALSE;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (self->priv->picto_grid_data == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = utils_remove_blank_lines (self->priv->picto_grid_data, self->priv->picto_grid_data_length1, &_tmp0_);
	_tmp2_ = _tmp1_;
	self->priv->picto_grid_data = (_vala_array_free (self->priv->picto_grid_data, self->priv->picto_grid_data_length1, (GDestroyNotify) g_free), NULL);
	self->priv->picto_grid_data_length1 = _tmp0_;
	self->priv->_picto_grid_data_size_ = self->priv->picto_grid_data_length1;
	self->priv->picto_grid_data = _tmp2_;
	if (self->priv->picto_grid_data == NULL) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = self->priv->picto_grid_data_length1 != self->rows;
	}
	if (_tmp3_) {
		result = FALSE;
		return result;
	}
	_tmp4_ = g_new0 (gchar*, self->rows + 1);
	_tmp5_ = _tmp4_;
	self->solution = (_vala_array_free (self->solution, self->solution_length1, (GDestroyNotify) g_free), NULL);
	self->solution_length1 = self->rows;
	self->solution = _tmp5_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gchar* _tmp7_ = NULL;
				gchar* arr;
				gchar* _tmp8_;
				gchar* _tmp9_;
				if (!_tmp6_) {
					i++;
				}
				_tmp6_ = FALSE;
				if (!(i < self->rows)) {
					break;
				}
				_tmp7_ = utils_gnonogram_string_from_hex_string (self->priv->picto_grid_data[i], self->cols);
				arr = _tmp7_;
				_tmp8_ = g_strdup (arr);
				_tmp9_ = _tmp8_;
				_g_free0 (self->solution[i]);
				self->solution[i] = _tmp9_;
				_g_free0 (arr);
			}
		}
	}
	self->has_solution = TRUE;
	result = TRUE;
	return result;
}


static gboolean gnonogram_filereader_get_gnonogram_state (Gnonogram_filereader* self, const gchar* body) {
	gboolean result = FALSE;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gchar** s;
	gint s_length1;
	gint _s_size_;
	gboolean _tmp6_ = FALSE;
	gchar* _tmp7_;
	gchar* _tmp8_;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (body == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = _tmp0_ = g_strsplit (body, "\n", 0);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _vala_array_length (_tmp0_);
	_tmp4_ = utils_remove_blank_lines (_tmp2_, _vala_array_length (_tmp0_), &_tmp3_);
	s = (_tmp5_ = _tmp4_, _tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL), _tmp5_);
	s_length1 = _tmp3_;
	_s_size_ = _tmp3_;
	if (s == NULL) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = s_length1 < 1;
	}
	if (_tmp6_) {
		result = FALSE;
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp7_ = g_strdup (s[0]);
	_tmp8_ = _tmp7_;
	_g_free0 (self->state);
	self->state = _tmp8_;
	self->has_state = TRUE;
	result = TRUE;
	s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gboolean gnonogram_filereader_get_game_description (Gnonogram_filereader* self, const gchar* body) {
	gboolean result = FALSE;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gchar** s;
	gint s_length1;
	gint _s_size_;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), FALSE);
	if (body == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = _tmp0_ = g_strsplit (body, "\n", 0);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _vala_array_length (_tmp0_);
	_tmp4_ = utils_remove_blank_lines (_tmp2_, _vala_array_length (_tmp0_), &_tmp3_);
	s = (_tmp5_ = _tmp4_, _tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL), _tmp5_);
	s_length1 = _tmp3_;
	_s_size_ = _tmp3_;
	if (s_length1 >= 1) {
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		_tmp6_ = utils_convert_html (s[0]);
		_tmp7_ = _tmp6_;
		_g_free0 (self->name);
		self->name = _tmp7_;
	}
	if (s_length1 >= 2) {
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp8_ = utils_convert_html (s[1]);
		_tmp9_ = _tmp8_;
		_g_free0 (self->author);
		self->author = _tmp9_;
	}
	if (s_length1 >= 3) {
		gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp10_ = g_strdup (s[2]);
		_tmp11_ = _tmp10_;
		_g_free0 (self->date);
		self->date = _tmp11_;
	}
	if (s_length1 >= 4) {
		gchar* _tmp12_;
		gchar* _tmp13_;
		_tmp12_ = g_strdup (s[3]);
		_tmp13_ = _tmp12_;
		_g_free0 (self->score);
		self->score = _tmp13_;
	}
	result = TRUE;
	s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gchar* gnonogram_filereader_parse_gnonogram_clue (Gnonogram_filereader* self, const gchar* line) {
	gchar* result = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint _tmp3_;
	gchar** _tmp4_ = NULL;
	gchar** _tmp5_;
	gchar** s;
	gint s_length1;
	gint _s_size_;
	gint b = 0;
	gint zero_count;
	GString* _tmp7_ = NULL;
	GString* sb;
	gchar* _tmp12_;
	g_return_val_if_fail (IS_GNONOGRAM_FILEREADER (self), NULL);
	g_return_val_if_fail (line != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit_set (line, ", ", 0);
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _vala_array_length (_tmp0_);
	_tmp4_ = utils_remove_blank_lines (_tmp2_, _vala_array_length (_tmp0_), &_tmp3_);
	s = (_tmp5_ = _tmp4_, _tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL), _tmp5_);
	s_length1 = _tmp3_;
	_s_size_ = _tmp3_;
	zero_count = 0;
	if (s == NULL) {
		gchar* _tmp6_;
		_tmp6_ = g_strdup ("");
		result = _tmp6_;
		s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp7_ = g_string_new ("");
	sb = _tmp7_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				gint _tmp9_;
				gboolean _tmp10_ = FALSE;
				gchar* _tmp11_;
				if (!_tmp8_) {
					i++;
				}
				_tmp8_ = FALSE;
				if (!(i < s_length1)) {
					break;
				}
				_tmp9_ = atoi (s[i]);
				b = _tmp9_;
				if (b == 0) {
					_tmp10_ = zero_count > 0;
				} else {
					_tmp10_ = FALSE;
				}
				if (_tmp10_) {
					continue;
				} else {
					zero_count++;
				}
				_tmp11_ = g_strconcat (s[i], RESOURCE_BLOCKSEPARATOR, NULL);
				g_string_append (sb, _tmp11_);
				_g_free0 (_tmp11_);
			}
		}
	}
	g_string_truncate (sb, (gsize) (sb->len - 1));
	_tmp12_ = g_strdup (sb->str);
	result = _tmp12_;
	_g_string_free0 (sb);
	s = (_vala_array_free (s, s_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void value_gnonogram_filereader_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_gnonogram_filereader_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gnonogram_filereader_unref (value->data[0].v_pointer);
	}
}


static void value_gnonogram_filereader_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gnonogram_filereader_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_gnonogram_filereader_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_gnonogram_filereader_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Gnonogram_filereader* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gnonogram_filereader_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_gnonogram_filereader_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Gnonogram_filereader** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gnonogram_filereader_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_gnonogram_filereader (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecGnonogram_filereader* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_GNONOGRAM_FILEREADER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_gnonogram_filereader (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_FILEREADER), NULL);
	return value->data[0].v_pointer;
}


void value_set_gnonogram_filereader (GValue* value, gpointer v_object) {
	Gnonogram_filereader* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_FILEREADER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_FILEREADER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gnonogram_filereader_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_filereader_unref (old);
	}
}


void value_take_gnonogram_filereader (GValue* value, gpointer v_object) {
	Gnonogram_filereader* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_GNONOGRAM_FILEREADER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_GNONOGRAM_FILEREADER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gnonogram_filereader_unref (old);
	}
}


static void gnonogram_filereader_class_init (Gnonogram_filereaderClass * klass) {
	gnonogram_filereader_parent_class = g_type_class_peek_parent (klass);
	GNONOGRAM_FILEREADER_CLASS (klass)->finalize = gnonogram_filereader_finalize;
	g_type_class_add_private (klass, sizeof (Gnonogram_filereaderPrivate));
}


static void gnonogram_filereader_instance_init (Gnonogram_filereader * self) {
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	self->priv = GNONOGRAM_FILEREADER_GET_PRIVATE (self);
	self->rows = 0;
	self->cols = 0;
	_tmp0_ = g_strdup ("");
	self->name = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->author = _tmp1_;
	_tmp2_ = g_strdup ("");
	self->date = _tmp2_;
	_tmp3_ = g_strdup ("");
	self->score = _tmp3_;
	self->in_error = FALSE;
	self->has_dimensions = FALSE;
	self->has_row_clues = FALSE;
	self->has_col_clues = FALSE;
	self->has_solution = FALSE;
	self->has_working = FALSE;
	self->has_state = FALSE;
	self->ref_count = 1;
}


static void gnonogram_filereader_finalize (Gnonogram_filereader* obj) {
	Gnonogram_filereader * self;
	self = GNONOGRAM_FILEREADER (obj);
	_g_free0 (self->filename);
	self->row_clues = (_vala_array_free (self->row_clues, self->row_clues_length1, (GDestroyNotify) g_free), NULL);
	self->col_clues = (_vala_array_free (self->col_clues, self->col_clues_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->state);
	_g_free0 (self->name);
	_g_free0 (self->author);
	_g_free0 (self->date);
	_g_free0 (self->score);
	self->solution = (_vala_array_free (self->solution, self->solution_length1, (GDestroyNotify) g_free), NULL);
	self->working = (_vala_array_free (self->working, self->working_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->stream);
	self->priv->headings = (_vala_array_free (self->priv->headings, self->priv->headings_length1, (GDestroyNotify) g_free), NULL);
	self->priv->bodies = (_vala_array_free (self->priv->bodies, self->priv->bodies_length1, (GDestroyNotify) g_free), NULL);
	self->priv->picto_grid_data = (_vala_array_free (self->priv->picto_grid_data, self->priv->picto_grid_data_length1, (GDestroyNotify) g_free), NULL);
}


GType gnonogram_filereader_get_type (void) {
	static volatile gsize gnonogram_filereader_type_id__volatile = 0;
	if (g_once_init_enter (&gnonogram_filereader_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_gnonogram_filereader_init, value_gnonogram_filereader_free_value, value_gnonogram_filereader_copy_value, value_gnonogram_filereader_peek_pointer, "p", value_gnonogram_filereader_collect_value, "p", value_gnonogram_filereader_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (Gnonogram_filereaderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnonogram_filereader_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Gnonogram_filereader), 0, (GInstanceInitFunc) gnonogram_filereader_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gnonogram_filereader_type_id;
		gnonogram_filereader_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Gnonogram_filereader", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gnonogram_filereader_type_id__volatile, gnonogram_filereader_type_id);
	}
	return gnonogram_filereader_type_id__volatile;
}


gpointer gnonogram_filereader_ref (gpointer instance) {
	Gnonogram_filereader* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void gnonogram_filereader_unref (gpointer instance) {
	Gnonogram_filereader* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GNONOGRAM_FILEREADER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




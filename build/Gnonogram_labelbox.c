/* Gnonogram_labelbox.c generated by valac 0.11.6, the Vala compiler
 * generated from Gnonogram_labelbox.vala, do not modify */

/*  Copyright (C) 2010-2011  Jeremy Wootten
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * As a special exception, if you use inline functions from this file, this
 * file does not by itself cause the resulting executable to be covered by
 * the GNU Lesser General Public License.
 *
 *  Author:
 * 	Jeremy Wootten <jeremwootten@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdio.h>


#define TYPE_GNONOGRAM_LABELBOX (gnonogram_labelbox_get_type ())
#define GNONOGRAM_LABELBOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBox))
#define GNONOGRAM_LABELBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBoxClass))
#define IS_GNONOGRAM_LABELBOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_LABELBOX))
#define IS_GNONOGRAM_LABELBOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_LABELBOX))
#define GNONOGRAM_LABELBOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBoxClass))

typedef struct _Gnonogram_LabelBox Gnonogram_LabelBox;
typedef struct _Gnonogram_LabelBoxClass Gnonogram_LabelBoxClass;
typedef struct _Gnonogram_LabelBoxPrivate Gnonogram_LabelBoxPrivate;

#define TYPE_GNONOGRAM_LABEL (gnonogram_label_get_type ())
#define GNONOGRAM_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GNONOGRAM_LABEL, Gnonogram_label))
#define GNONOGRAM_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GNONOGRAM_LABEL, Gnonogram_labelClass))
#define IS_GNONOGRAM_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GNONOGRAM_LABEL))
#define IS_GNONOGRAM_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GNONOGRAM_LABEL))
#define GNONOGRAM_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GNONOGRAM_LABEL, Gnonogram_labelClass))

typedef struct _Gnonogram_label Gnonogram_label;
typedef struct _Gnonogram_labelClass Gnonogram_labelClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _Gnonogram_LabelBox {
	GtkFrame parent_instance;
	Gnonogram_LabelBoxPrivate * priv;
};

struct _Gnonogram_LabelBoxClass {
	GtkFrameClass parent_class;
};

struct _Gnonogram_LabelBoxPrivate {
	gboolean _is_column;
	gint _size;
	gint _other_size;
	Gnonogram_label** _labels;
	gint _labels_length1;
	gint __labels_size_;
	GtkContainer* _box;
	gchar* _attribstart;
	gchar* _attribend;
	gdouble _fontheight;
};


static gpointer gnonogram_labelbox_parent_class = NULL;
extern gint resource_MAXCOLSIZE;
extern gint resource_MAXROWSIZE;
extern gchar* resource_font_desc;
extern gint resource_MINFONTSIZE;
extern gint resource_MAXFONTSIZE;

GType gnonogram_labelbox_get_type (void) G_GNUC_CONST;
GType gnonogram_label_get_type (void) G_GNUC_CONST;
#define GNONOGRAM_LABELBOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GNONOGRAM_LABELBOX, Gnonogram_LabelBoxPrivate))
enum  {
	GNONOGRAM_LABELBOX_DUMMY_PROPERTY
};
Gnonogram_LabelBox* gnonogram_labelbox_new (gint size, gint other_size, gboolean is_col);
Gnonogram_LabelBox* gnonogram_labelbox_construct (GType object_type, gint size, gint other_size, gboolean is_col);
Gnonogram_label* gnonogram_label_new (const gchar* label_text, gboolean is_column);
Gnonogram_label* gnonogram_label_construct (GType object_type, const gchar* label_text, gboolean is_column);
void gnonogram_labelbox_resize (Gnonogram_LabelBox* self, gint new_size, gint other_size);
static void gnonogram_labelbox_unhighlight_all (Gnonogram_LabelBox* self);
static void gnonogram_labelbox_remove_label (Gnonogram_LabelBox* self);
static void gnonogram_labelbox_set_default_fontheight (Gnonogram_LabelBox* self, gint size, gint other_size);
static void gnonogram_labelbox_set_attribs (Gnonogram_LabelBox* self, gdouble fontheight);
static void gnonogram_labelbox_set_all_to_zero (Gnonogram_LabelBox* self);
void gnonogram_labelbox_change_font_height (Gnonogram_LabelBox* self, gboolean increase);
void gnonogram_labelbox_update_label (Gnonogram_LabelBox* self, gint idx, const gchar* txt);
gchar* gnonogram_labelbox_get_label_text (Gnonogram_LabelBox* self, gint idx);
void gnonogram_labelbox_highlight (Gnonogram_LabelBox* self, gint idx, gboolean is_highlight);
void gnonogram_label_highlight (Gnonogram_label* self, gboolean is_highlight);
void gnonogram_label_set_markup (Gnonogram_label* self, const gchar* start, const gchar* text, const gchar* end);
void gnonogram_label_set_size (Gnonogram_label* self, gint s);
gchar* gnonogram_label_get_text (Gnonogram_label* self);
gchar* gnonogram_labelbox_to_string (Gnonogram_LabelBox* self);
static void gnonogram_labelbox_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Gnonogram_LabelBox* gnonogram_labelbox_construct (GType object_type, gint size, gint other_size, gboolean is_col) {
	Gnonogram_LabelBox * self = NULL;
	self = (Gnonogram_LabelBox*) g_object_new (object_type, NULL);
	self->priv->_is_column = is_col;
	gtk_frame_set_shadow_type (GTK_FRAME (self), GTK_SHADOW_NONE);
	if (self->priv->_is_column) {
		GtkHBox* _tmp0_ = NULL;
		GtkHBox* _tmp1_;
		GtkContainer* _tmp2_;
		Gnonogram_label** _tmp3_ = NULL;
		Gnonogram_label** _tmp4_;
		_tmp0_ = (GtkHBox*) gtk_hbox_new (TRUE, 0);
		_tmp2_ = (_tmp1_ = g_object_ref_sink (_tmp0_), GTK_IS_CONTAINER (_tmp1_) ? ((GtkContainer*) _tmp1_) : NULL);
		_g_object_unref0 (self->priv->_box);
		self->priv->_box = _tmp2_;
		_tmp3_ = g_new0 (Gnonogram_label*, resource_MAXCOLSIZE + 1);
		_tmp4_ = _tmp3_;
		self->priv->_labels = (_vala_array_free (self->priv->_labels, self->priv->_labels_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_labels_length1 = resource_MAXCOLSIZE;
		self->priv->__labels_size_ = self->priv->_labels_length1;
		self->priv->_labels = _tmp4_;
	} else {
		GtkVBox* _tmp5_ = NULL;
		GtkVBox* _tmp6_;
		GtkContainer* _tmp7_;
		Gnonogram_label** _tmp8_ = NULL;
		Gnonogram_label** _tmp9_;
		_tmp5_ = (GtkVBox*) gtk_vbox_new (TRUE, 0);
		_tmp7_ = (_tmp6_ = g_object_ref_sink (_tmp5_), GTK_IS_CONTAINER (_tmp6_) ? ((GtkContainer*) _tmp6_) : NULL);
		_g_object_unref0 (self->priv->_box);
		self->priv->_box = _tmp7_;
		_tmp8_ = g_new0 (Gnonogram_label*, resource_MAXROWSIZE + 1);
		_tmp9_ = _tmp8_;
		self->priv->_labels = (_vala_array_free (self->priv->_labels, self->priv->_labels_length1, (GDestroyNotify) g_object_unref), NULL);
		self->priv->_labels_length1 = resource_MAXROWSIZE;
		self->priv->__labels_size_ = self->priv->_labels_length1;
		self->priv->_labels = _tmp9_;
	}
	{
		gint i;
		i = 0;
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				Gnonogram_label* _tmp11_ = NULL;
				Gnonogram_label* l;
				Gnonogram_label* _tmp12_;
				Gnonogram_label* _tmp13_;
				if (!_tmp10_) {
					i++;
				}
				_tmp10_ = FALSE;
				if (!(i < self->priv->_labels_length1)) {
					break;
				}
				_tmp11_ = gnonogram_label_new ("", is_col);
				l = g_object_ref_sink (_tmp11_);
				_tmp12_ = _g_object_ref0 (l);
				_tmp13_ = _tmp12_;
				_g_object_unref0 (self->priv->_labels[i]);
				self->priv->_labels[i] = _tmp13_;
				_g_object_unref0 (l);
			}
		}
	}
	self->priv->_size = 0;
	gnonogram_labelbox_resize (self, size, other_size);
	gtk_container_add (GTK_CONTAINER (self), GTK_WIDGET (self->priv->_box));
	return self;
}


Gnonogram_LabelBox* gnonogram_labelbox_new (gint size, gint other_size, gboolean is_col) {
	return gnonogram_labelbox_construct (TYPE_GNONOGRAM_LABELBOX, size, other_size, is_col);
}


void gnonogram_labelbox_resize (Gnonogram_LabelBox* self, gint new_size, gint other_size) {
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	gnonogram_labelbox_unhighlight_all (self);
	if (new_size != self->priv->_size) {
		gint diff;
		diff = new_size - self->priv->_size;
		if (diff > 0) {
			{
				gint i;
				i = 0;
				{
					gboolean _tmp0_;
					_tmp0_ = TRUE;
					while (TRUE) {
						if (!_tmp0_) {
							i++;
						}
						_tmp0_ = FALSE;
						if (!(i < diff)) {
							break;
						}
						gtk_container_add (self->priv->_box, GTK_WIDGET (self->priv->_labels[self->priv->_size]));
						self->priv->_size++;
					}
				}
			}
		} else {
			{
				gint i;
				i = 0;
				{
					gboolean _tmp1_;
					_tmp1_ = TRUE;
					while (TRUE) {
						if (!_tmp1_) {
							i--;
						}
						_tmp1_ = FALSE;
						if (!(i > diff)) {
							break;
						}
						gnonogram_labelbox_remove_label (self);
						self->priv->_size--;
					}
				}
			}
		}
		if (self->priv->_size != new_size) {
			fprintf (stdout, "Error adding or removing labels");
		}
	}
	self->priv->_other_size = other_size;
	gnonogram_labelbox_set_default_fontheight (self, self->priv->_size, self->priv->_other_size);
	gnonogram_labelbox_set_attribs (self, self->priv->_fontheight);
	gnonogram_labelbox_set_all_to_zero (self);
}


static void gnonogram_labelbox_remove_label (Gnonogram_LabelBox* self) {
	GList* _tmp0_ = NULL;
	GList* l;
	guint _tmp1_;
	gconstpointer _tmp2_ = NULL;
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	_tmp0_ = gtk_container_get_children (self->priv->_box);
	l = _tmp0_;
	_tmp1_ = g_list_length (l);
	_tmp2_ = g_list_nth_data (l, ((guint) _tmp1_) - 1);
	gtk_container_remove (self->priv->_box, (GtkWidget*) _tmp2_);
	_g_list_free0 (l);
}


void gnonogram_labelbox_change_font_height (Gnonogram_LabelBox* self, gboolean increase) {
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	if (increase) {
		self->priv->_fontheight = self->priv->_fontheight + 1.0;
	} else {
		self->priv->_fontheight = self->priv->_fontheight - 1.0;
	}
	gnonogram_labelbox_set_attribs (self, self->priv->_fontheight);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gchar* _tmp1_ = NULL;
				gchar* _tmp2_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_size)) {
					break;
				}
				_tmp1_ = gnonogram_labelbox_get_label_text (self, i);
				_tmp2_ = _tmp1_;
				gnonogram_labelbox_update_label (self, i, _tmp2_);
				_g_free0 (_tmp2_);
			}
		}
	}
}


void gnonogram_labelbox_highlight (Gnonogram_LabelBox* self, gint idx, gboolean is_highlight) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	if (idx >= self->priv->_size) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = idx < 0;
	}
	if (_tmp0_) {
		return;
	}
	gnonogram_label_highlight (self->priv->_labels[idx], is_highlight);
}


static void gnonogram_labelbox_unhighlight_all (Gnonogram_LabelBox* self) {
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < self->priv->_size)) {
					break;
				}
				gnonogram_labelbox_highlight (self, i, FALSE);
			}
		}
	}
}


void gnonogram_labelbox_update_label (Gnonogram_LabelBox* self, gint idx, const gchar* txt) {
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	g_return_if_fail (txt != NULL);
	gnonogram_label_set_markup (self->priv->_labels[idx], self->priv->_attribstart, txt, self->priv->_attribend);
	gnonogram_label_set_size (self->priv->_labels[idx], self->priv->_other_size);
}


gchar* gnonogram_labelbox_get_label_text (Gnonogram_LabelBox* self, gint idx) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	g_return_val_if_fail (IS_GNONOGRAM_LABELBOX (self), NULL);
	_tmp0_ = gnonogram_label_get_text (self->priv->_labels[idx]);
	result = _tmp0_;
	return result;
}


gchar* gnonogram_labelbox_to_string (Gnonogram_LabelBox* self) {
	gchar* result = NULL;
	GString* _tmp0_ = NULL;
	GString* sb;
	gchar* _tmp4_;
	g_return_val_if_fail (IS_GNONOGRAM_LABELBOX (self), NULL);
	_tmp0_ = g_string_new ("");
	sb = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gchar* _tmp2_ = NULL;
				gchar* _tmp3_;
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < self->priv->_size)) {
					break;
				}
				_tmp2_ = gnonogram_labelbox_get_label_text (self, i);
				_tmp3_ = _tmp2_;
				g_string_append (sb, _tmp3_);
				_g_free0 (_tmp3_);
				g_string_append (sb, "\n");
			}
		}
	}
	_tmp4_ = g_strdup (sb->str);
	result = _tmp4_;
	_g_string_free0 (sb);
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void gnonogram_labelbox_set_attribs (Gnonogram_LabelBox* self, gdouble fontheight) {
	gint fontsize;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	fontsize = 1024 * ((gint) fontheight);
	_tmp0_ = string_to_string (resource_font_desc);
	_tmp1_ = g_strdup_printf ("%i", fontsize);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("<span font_desc='", _tmp0_, "' size='", _tmp2_, "'>", NULL);
	_tmp4_ = _tmp3_;
	_g_free0 (self->priv->_attribstart);
	self->priv->_attribstart = _tmp4_;
	_g_free0 (_tmp2_);
	_tmp5_ = g_strdup ("</span>");
	_tmp6_ = _tmp5_;
	_g_free0 (self->priv->_attribend);
	self->priv->_attribend = _tmp6_;
}


static void gnonogram_labelbox_set_default_fontheight (Gnonogram_LabelBox* self, gint size, gint other_size) {
	gdouble _tmp0_;
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	if (self->priv->_is_column) {
		self->priv->_fontheight = 30.0 - (((gdouble) other_size) / 2.0);
	} else {
		self->priv->_fontheight = 30.0 - (((gdouble) size) / 2.0);
	}
	_tmp0_ = CLAMP (self->priv->_fontheight, (gdouble) resource_MINFONTSIZE, (gdouble) resource_MAXFONTSIZE);
	self->priv->_fontheight = _tmp0_;
}


static void gnonogram_labelbox_set_all_to_zero (Gnonogram_LabelBox* self) {
	g_return_if_fail (IS_GNONOGRAM_LABELBOX (self));
	{
		gint l;
		l = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					l++;
				}
				_tmp0_ = FALSE;
				if (!(l < self->priv->_size)) {
					break;
				}
				gnonogram_labelbox_update_label (self, l, "0");
			}
		}
	}
}


static void gnonogram_labelbox_class_init (Gnonogram_LabelBoxClass * klass) {
	gnonogram_labelbox_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (Gnonogram_LabelBoxPrivate));
	G_OBJECT_CLASS (klass)->finalize = gnonogram_labelbox_finalize;
}


static void gnonogram_labelbox_instance_init (Gnonogram_LabelBox * self) {
	self->priv = GNONOGRAM_LABELBOX_GET_PRIVATE (self);
}


static void gnonogram_labelbox_finalize (GObject* obj) {
	Gnonogram_LabelBox * self;
	self = GNONOGRAM_LABELBOX (obj);
	self->priv->_labels = (_vala_array_free (self->priv->_labels, self->priv->_labels_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (self->priv->_box);
	_g_free0 (self->priv->_attribstart);
	_g_free0 (self->priv->_attribend);
	G_OBJECT_CLASS (gnonogram_labelbox_parent_class)->finalize (obj);
}


GType gnonogram_labelbox_get_type (void) {
	static volatile gsize gnonogram_labelbox_type_id__volatile = 0;
	if (g_once_init_enter (&gnonogram_labelbox_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (Gnonogram_LabelBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gnonogram_labelbox_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Gnonogram_LabelBox), 0, (GInstanceInitFunc) gnonogram_labelbox_instance_init, NULL };
		GType gnonogram_labelbox_type_id;
		gnonogram_labelbox_type_id = g_type_register_static (GTK_TYPE_FRAME, "Gnonogram_LabelBox", &g_define_type_info, 0);
		g_once_init_leave (&gnonogram_labelbox_type_id__volatile, gnonogram_labelbox_type_id);
	}
	return gnonogram_labelbox_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}




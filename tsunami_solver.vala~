//=========================================================================	
//=========================================================================	
public class Tsunami_solver {
//=========================================================================	
//=========================================================================	
	private int _rows;
	private int _cols;
	private int _region_count;
	private My2DArray _grid;
	private Tsunami_region[] _regions;

//=========================================================================	
	public Tsunami_solver(string[] row_clues, string[] col_clues, ref My2DArray grid, bool testing, bool debug, bool test_column, int test_idx) {
//=========================================================================	
		_rows=row_clues.length;
		_cols=col_clues.length;
		_region_count=0;
		_grid=grid;
		bool log;
		_regions=new Tsunami_region[_rows+_cols];
		for (int r=0; r<_rows; r++) {
			log=debug||!test_column && (r==test_idx);
			_regions[r]=new Tsunami_region(ref _grid, r, false, 0, _cols-1, row_clues[r], log);
			_region_count++;
		}
		if (testing) {stdout.printf("IN TESTING MODE - not columns\n");}
		else {
			for (int c=0; c<_cols; c++) {
			log=debug||test_column && (c==test_idx);
				_regions[c+_rows]=new Tsunami_region(ref _grid, c, true, 0, _rows-1, col_clues[c], log);	
			_region_count++;		
			}
		}
	}
	
//=========================================================================	
	public bool valid() {
//=========================================================================	
		bool valid=true;
		for (int i=0; i<_region_count; i++) {
			if (_regions[i].in_error()) {valid=false; break;}
		}
		return valid;
	}
	
//=========================================================================	
	public int solve() {
//=========================================================================	
		bool changed=true; int pass=0;
		while (changed) {
			changed=false;
			for (int i=0; i<_region_count; i++) {
				if (_regions[i].completed()) {continue;}
				if (_regions[i].solve(pass)) {
					if (_regions[i].in_error()) {
						stdout.printf("Region %d in error\n",i); changed=false;
						break;	
					}
					else {changed=true;}
				}
			}
			pass++;
			if (pass>20) {stdout.printf("Exceeded 20 passes"); break;}
		}
		return pass;
	}
	
//=========================================================================	
	public bool solved() {
//=========================================================================	
		bool solved=true;
		for (int i=0; i<_region_count; i++) {
			if (!_regions[i].completed()) {solved=false; break;}
		}
		return solved;
	}
}
//=====================================================================
//=========================================================================	
public class Tsunami_region {
//=========================================================================	
//=========================================================================	
	private bool _is_column;
	private bool _in_error=false;
	private bool _region_completed=false;
	private bool[] _completed_blocks;
	private bool[,] _tags;
	private int [,] _ranges; //format: start,length,unfilled?,complete?
	private int _ncells;
	private int _nblocks;
	private int _last_block;
	private int _block_total=0;
	private int _block_extent;
	private int _index;
	private int _cycles=0;
	private int _pass=0;
	private int _unknown=99; //impossible value - must be different to real value
	private int _filled=99; //impossible values - must be different to real value
	private int _start; //only needed if truncate implemented?
	private int _end;  //only needed if truncate implemented?
	private int _can_be_empty;
	private int _is_finished;
	private int[] _blocks;
	private My2DArray _grid;
	private CellState[] _status;
	private CellState[] _temp_status;
	private bool _debug=false;		
//=========================================================================	
	public Tsunami_region (ref My2DArray grid, int index, bool is_column, int start, int end, string blocks, bool debug) {
//=========================================================================	
		_grid=grid; _start=start; _end=end;	_ncells=end-start+1;	_index=index;
		_is_column=is_column; _debug=debug; 
		string[] sa;
		split_string(blocks,',',out sa);
		_nblocks=sa.length; _last_block=_nblocks-1;
		_blocks=new int[_nblocks];
		_completed_blocks=new bool[_nblocks];
		_ranges=new int[_ncells/2+1, 4];

		for (int i=0;i<_nblocks;i++) {
			_blocks[i]=sa[i].to_int();
			_block_total=_block_total+_blocks[i];
			_completed_blocks[i]=false;
		}	

		_block_extent=_block_total+_last_block;
		_status=new CellState[_ncells];
		_temp_status=new CellState[_ncells];
	
		for (int i=0; i<_ncells;i++) {
			_status[i]=CellState.UNKNOWN;	_temp_status[i]=CellState.UNKNOWN;
		}
		//two extra flags for "can be empty" and "in completed block".
		_tags=new bool[_ncells, _nblocks+2];
		_can_be_empty=_nblocks; //flag for cell that may be empty
		_is_finished=_nblocks+1; //flag for finished cell (filled or empty?)
		for (int i=0;i<_ncells;i++) {
			for (int j=0; j<_nblocks; j++) {
					 _tags[i,j]=false;
			}
			_tags[i,_can_be_empty]=true;	_tags[i,_is_finished]=false;
		}	
	} 
//=========================================================================	
	public bool in_error() {return _in_error;}
//=========================================================================	
//=========================================================================	
	public bool completed() {return _region_completed;}
//=========================================================================	
//=========================================================================	
	public bool solve(int pass) {
//=========================================================================	
		if (_region_completed) {return false;}
		_pass=pass;
		bool made_changes=false;
		bool still_changing=false;
		get_status();
		still_changing=totals_changed(); //always true when _cycles==0
		while (still_changing && !_region_completed) {
				_cycles++;
				if (_cycles==1) {initial_fix();}
				else {full_fix(); tags_to_status();}	
				if (_in_error) {break;}			
				still_changing=totals_changed(); //always true when _cycles==1
				if (still_changing) {
					made_changes=true;
					_region_completed=(count_cell_state(CellState.UNKNOWN)==0);
//					log (@"Made changes - Is complete? - $_region_completed");
				}
				else {log("============Could not make any more changes=================");}
		}
		if (made_changes) {put_status();}
		if (_debug||_in_error) {print_tags();}
		return made_changes;
	}
//=========================================================================	
	private void initial_fix() {
//=========================================================================	
		log("Initial fix");
		if (_blocks[0]==0) {log(" Zero block only");
			_completed_blocks[0]=true; _region_completed=true;
		}
		else {
			int freedom=_ncells-_block_extent;
			if (freedom==0) {_region_completed=true;}
			int start=0; int length=0;
			for (int i=0; i<_nblocks; i++) {
				length=_blocks[i]+freedom;
				for (int j=start; j<start+length; j++) {_tags[j,i]=true;}
//				fix_block_in_range(i,start,length,false);
				start=start+_blocks[i]+1; //leave a gap between blocks
			}			
		}
		tags_to_status();
	}
//=========================================================================	
	private void full_fix() {
//=========================================================================	
		status_to_tags();
//		if (do_edge(1)||_in_error) {return;}
//		tags_to_status();
//		if (do_edge(-1)||_in_error) {return;}
//		tags_to_status();
//		if (fill_gaps()||_in_error) {return;}
//		tags_to_status();
//		if (possibilities_audit()||_in_error) {return;}
//		tags_to_status();
//		if (filled_subregion_audit()||_in_error) {return;}
//		tags_to_status();
//		if (free_cell_audit()||_in_error) {return;}
//		tags_to_status();
//		if (only_possibility()||_in_error) {return;}
//		tags_to_status();
		if (available_range_audit()||_in_error) {return;}
	}
//=========================================================================	
	private bool fill_gaps() {
//=========================================================================	
		// Find unknown gap between filled cells and complete accordingly.
		// Find an owned cell followed by an unknown gap
		// Find next filled cell - if same owner complete between 
		log("=======fill_gaps=======");
		bool changed=false;
		for (int idx=0; idx<_ncells-1; idx++) {
			if (_status[idx]!=CellState.FILLED) {continue;}
			if (_status[idx+1]!=CellState.UNKNOWN) {continue;}
			if (!one_owner(idx)) {continue;}
			idx++; int cell1=idx-1; //start of block
			while (idx<_ncells-1 && _status[idx]==CellState.UNKNOWN) {idx++;}
			if (_status[idx]!=CellState.FILLED) {continue;}
			int owner;
			if (same_owner(cell1,idx, out owner)) {
				set_range_owner(owner,cell1,idx-cell1+1);	changed=true;
			}
		}
		return changed;
	}
//=========================================================================	
	private bool possibilities_audit() {
//=========================================================================	
		//find a unique possible range for block if there is one.
		//eliminates ranges that are too small
		log("=========possibilities audit===========");
		bool changed=false;
		int start=0;int length; int count=0;
		for (int i=0;i<_nblocks;i++) {
			if (_completed_blocks[i]) {continue;} //skip completed block
			length=0; count=0;
			for (int idx=0;idx<_ncells;idx++) {
				if (count>1) {log(@"Discontinuous for block $i"); break;}
				if (!_tags[idx,i]||_tags[idx,_is_finished]) {continue;}
				int l=count_next_owner(i,idx); int s=idx;	
				log(@"Range $count found for block $i start $s, length $l");
				if (l<_blocks[i]) {//cant be here
					log("Too small");
					remove_block_from_range(i,s,l);
				}
				else {length=l;start=s;count++;}
				idx+=l;
			}
			if (count!=1) {continue;} //no usable range found
			else {//at least some cells can be assigned
				changed=fix_block_in_range(i,start,length)||changed;
			}
		}
		return changed;
	}
//=========================================================================	
	private bool filled_subregion_audit() {
//=========================================================================	
//find a range of filled cells not completed and see if can be associated
// with a unique block.
		log("============sub region audit============");
		bool changed=false;int idx=0;	int length;
		while (idx<_ncells) {//find a filled sub-region
			if (skip_while_not_status(CellState.FILLED,ref idx)) {
				//idx points to first filled cell
				if (_tags[idx,_is_finished]) {continue;}//ignore if completed already
				length=count_next_state(CellState.FILLED, idx);//idx not changed
				log(@"length of filled range starting $idx is $length");
				int largest=find_largest_possible_in_cell(idx);
				log(@"largest block available in range = $largest");
				if (largest==length) {//there is **at least one** largest block that fits exactly 
					assign_and_cap_range(idx,length); changed=true;
				}
				else if (largest<length) {print_error(@"largest available block has length $largest which is less than filled range length $length");
				}				
				else {//remove blocks that are smaller than length and one cell either side
					for(int i=idx-1;i<=idx+length;i++) {
						if (i<0||i>_ncells-1) {continue;}
						for (int bl=0;bl<_nblocks;bl++) {
							if (_tags[i,bl] && _blocks[bl]<length) {_tags[i,bl]=false;}
						}
					}
				} 
				idx+=length;//move past block
			}
			else {break;}
		}
	return changed;	
	}
//=========================================================================	
	private void assign_and_cap_range(int start, int length) {
//=========================================================================	
		log(@"=========assign and cap - start $start length $length============");
		//make list of possible blocks with right length in max_blocks[]
		//record which is first and which last (in order).
		int count=0; int[] max_blocks=new int[_nblocks];
		int first=_nblocks; int last=0;
		for (int i=0;i<_nblocks;i++) {
			if (_completed_blocks[i]) {continue;}
			if (_blocks[i]!=length) {continue;}
			if (!_tags[start,i]) {continue;}
			max_blocks[count]=i;
			if (i<first) {first=i;}
			if (i>last) {last=i;}
			count++;			
		}
		if (count==1) {//unique owner
			log(@"one possibility - range start $start");
			set_block_complete_and_cap(max_blocks[0],start);
		}
		else {//ambiguous owner
			log(@"more than one possibility - range start $start, first=$first last=$last" );
			//delete out of sequence blocks before end of range
			for (int i=last;i<_nblocks;i++) {
					remove_block_from_cell_to_end(i,start+length-1,-1);
			}		
			//delete out of sequence blocks after start of range
			for (int i=0;i<=first;i++) {
					remove_block_from_cell_to_end(i,start,1);
			}
			//for each possible mark as possible owner of subregion (not exclusive)
			for (int i=0;i<count;i++) {
				set_range_owner(max_blocks[i],start,length,false);
			}	
			//remove as possible owner blocks between first and last that are wrong length
			for (int i=first+1;i<last;i++) {
				if (_blocks[i]==length) {continue;}
				remove_block_from_range(i,start,length,1);
			}
			// cap range
			if (start>0) {set_cell_empty(start-1);}
			if (start+length<_ncells) {set_cell_empty(start+length);}
		}
	}	
//=========================================================================	
	private bool only_possibility() { 
//=========================================================================
//find an unfinished cell with only one possibility
		log("In only_possibility");
		bool changed=false; int owner; int length; int start;
		for (int i=0;i<_ncells;i++) {
			if (_tags[i,_is_finished]) {continue;}
			if (_status[i]==CellState.FILLED && one_owner(i)) {
				owner=-1; //find the owner
				for (int j=0;j<_nblocks;j++) {if (_tags[i,j]) {owner=j;break;}}
				if (owner>=0) {//should always be true!
					length=_blocks[owner]; start=i-length;
					if (start>=0) {remove_block_from_cell_to_end(owner,start,-1);}
					start=i+length;
					if (start<_ncells) {remove_block_from_cell_to_end(owner,start,+1);}					
				}
			}
		}
		return changed;
	}	

//=========================================================================	
	private bool free_cell_audit() { 
//=========================================================================	
//
		log("free_cell_audit:");
		bool changed=false;
		int free_cells=count_cell_state(CellState.UNKNOWN);
		if (free_cells==0) {return false;}
		int filled_cells=count_cell_state(CellState.FILLED);
		int completed_cells=count_cell_state(CellState.COMPLETED);
		int to_locate=_block_total-filled_cells-completed_cells;					
		if (free_cells==to_locate) {//free_cells>0
			log(@"free_cells=to_locate, setting COMPLETE");
			for (int i=0;i<_ncells;i++) {
				if (_status[i]==CellState.UNKNOWN) {set_cell_complete(i);}
			}
			for (int i=0;i<_nblocks;i++) {_completed_blocks[i]=true;}
			changed=true;
		}
		else if (to_locate==0) {log(@"no available blocks, setting rest EMPTY");
			for (int i=0;i<_ncells;i++) {
				if (_status[i]==CellState.UNKNOWN) {set_cell_empty(i);}
			}	
			changed=true;
		}
		else if (to_locate<0) {print_error("Too many filled cells");}
	return changed;
	}	

//=========================================================================	
	private bool do_edge(int direction) {
//=========================================================================	
		//1=forward -1=backward
		log (@"In do_edge, direction $direction"); 
		int idx; //pointer to current cell
		int blocknum; //current block
		int blength; // length of current block
		int limit; //first out of range value of idx depending on direction
		bool changed=false; //tags changed?
		bool dir=(direction>0);
		
		if (dir) {idx=0; blocknum=0; limit=_ncells;}
		else {idx=_ncells-1; blocknum=_last_block; limit=-1;}
		if (!find_edge(ref idx,ref blocknum,limit,direction)) {log("No edge"); return false;
		} 
		blength=_blocks[blocknum];
		if (_status[idx]==CellState.FILLED) { //start of unassigned filled block
				set_block_complete_and_cap(blocknum,idx,direction); changed=true;
		}
		else {// see if filled cell in range of first block and complete after that
			int edge_start=idx; int fill_start=-1; 
			int blocklimit=(dir? idx+blength : idx-blength);
			if (skip_while_not_status(CellState.FILLED,ref idx,blocklimit,direction)) {
				fill_start=idx;
				while (idx!=blocklimit) {
					if (_status[idx]==CellState.UNKNOWN) {set_cell_owner(idx,blocknum); changed=true;}
					if (dir) {idx++;} else {idx--;}
				} 
				//idx now points to cell after earliest possible end of block
				// if this is a filled cell then first cell in range must be empty
				// continue until an unfilled cell found setting cells at beginning of 
				//range empty
				while (idx!=blocklimit && _status[idx]==CellState.FILLED) {
						set_cell_owner(idx,blocknum);	set_cell_empty(edge_start);changed=true;
						if (dir) {idx++; edge_start++;} else {idx--; edge_start--;}
				}
				//if a fillable cell was found then fill_start>0
				if (fill_start>0) {//delete block  than block length from where filling started
					idx= dir ? fill_start+blength : fill_start-blength;
					if (idx>=0 && idx<_ncells) {remove_block_from_cell_to_end(blocknum,idx,direction);}
				}
			}
		}
		return changed;
	}	
//=========================================================================
	private bool find_edge(ref int idx,ref int blocknum, int limit, int direction) {
//=========================================================================
		bool dir=(direction==1); bool found=false;
		for (int i=idx; (dir ? i<limit : i>limit); (dir ? i++ : i--)) {
			if (_status[i]==CellState.EMPTY) {continue;}
			if (_tags[i,_is_finished]) {//skip to end of finished block
				i = (dir ? i+_blocks[blocknum]-1 : i-_blocks[blocknum]+1);
				if (dir) {blocknum++;} else {blocknum--;}
				continue;
			}
			idx=i; found=true; break;			
		}
		return found;
	}
//=========================================================================
	private bool available_range_audit() {
//=========================================================================
	log("In available_range_audit");
		int start; int length; int filled; int unknown; int ranges; int nblocks;
		bool changed=false;
		ranges=count_available_ranges();
		log(@"ranges: $ranges");
		for (int i=0;i<ranges;i++) {
			start=_ranges[i,0]; length=_ranges[i,1];
			filled=_ranges[i,2]; unknown=_ranges[i,3];
			log(@"range $i: start $start length $length filled $filled unknown $unknown");
		}
		nblocks=blocks_available();
		log(@"number of available blocks $nblocks");
		if (nblocks!=ranges || nblocks<2) {return false;}
		int[] blocks=new int[nblocks]; int bl=0;
		for (int i=0;i<_nblocks;i++) {
			if (!_completed_blocks[i]) {int l=_blocks[i];	log(@"$bl Available block is $i length $l ");
				blocks[bl]=i; bl++;
			}
		}
		//can more than one block fit? if not fix in range
		bool unique=true;
		for (int r=0; r<ranges; r++) {
			if ((r<ranges-1) && (_ranges[r,1]>=_blocks[blocks[r]]+_blocks[blocks[r+1]]+1)||(r>0)&&(_ranges[r,1]>=_blocks[blocks[r]]+_blocks[blocks[r-1]]+1)) {
			//this range must contain first block abort
				unique=false; break;
			}
		}
		if (unique) {
			for (int r=0; r<ranges; r++) {
				fix_block_in_range(blocks[r],_ranges[r,0],_ranges[r,1]);
				changed=true;
			}
		}		
		else {log(@"at least on range can fit two blocks");}
		return changed;
	}
//=========================================================================	
	private bool skip_while_not_status(CellState cs, ref int idx, int limit=_ncells, int direction=1) {
//=========================================================================	
// increments/decrements idx until cell of required state
// or end of range found.
//returns true if cell with status cs was found

		bool dir=(direction>0); bool found=false;
		for (int i=idx; (dir ? i<limit : i>limit); (dir ? i++ : i--)) {
			if (_status[i]==cs) {idx=i;found=true; break;}		
		}
		return found;	
	}
//=========================================================================	
	private int count_next_state(CellState cs, int start) {
//=========================================================================	
// count how may consecutive cells of state cs starting at given index idx?
		int count=0; int idx=start;
		if (idx<0) {print_error("count_next_state - idx <0  ($idx)");	}
		else {
			while ( _status[idx]==cs && idx<_ncells) {count++; idx++;}
		}
		return count;
	}
//=========================================================================	
	private int count_next_owner(int owner, int start) {
//=========================================================================	
// count how may consecutive cells with owner possible starting at given index idx?
		int count=0; int idx=start;
		if (idx<0) {print_error("count_next_owner - idx <0  ($idx)");	}
		else {
			while ( _tags[idx,owner] && !_tags[idx,_is_finished] && idx<_ncells) {
				count++; idx++;
			}
		}
		return count;
	}	
//=========================================================================	
	private int count_owners_and_empty(int cell) {
//=========================================================================	
// how many possible owners?  Does include can be empty tag!
		int count=0;
		if (invalid_data(cell)) {
			print_error(@"count_owners_and_empty - invalid cell $cell");
		}
		else {
			for (int j=0;j<=_nblocks; j++) {if (_tags[cell,j]) {count++;}}
		}
		return count;
	}	
//=========================================================================	
	private int count_cell_state(CellState cs) {
//=========================================================================	
		//how many times does state cs occur in range.
		int count=0;
		for (int i=0;i<_ncells; i++) {if (_status[i]==cs) {count++;}}
		return count;
	}
//=========================================================================	
	private int count_available_ranges() {
//=========================================================================	
// determine location of ranges of unknown or filled cells and store in _ranges[,]
// _ranges[ ,2] indicates contains filled, _ranges[ ,3] indicates contains unknown
			int range=0; int start=0; int length=0; int idx=0; 
			while (idx<_ncells) {
				length=0; start=idx; _ranges[range,0]=start; _ranges[range,2]=0; _ranges[range,3]=0;
				while (_status[idx]!=CellState.EMPTY && idx<_ncells) {
					if (!_tags[idx,_can_be_empty]) {_ranges[range,2]++;}//contains filled cell
					else {_ranges[range,3]++;} //contains unknown cell
					idx++; length++;
				}
				if (length>0 && _ranges[range,3]!=0) {_ranges[range,1]=length; range++;}	
				while (_status[idx]==CellState.EMPTY && idx<_ncells) {idx++;}	
			}
			return range;
	}
//=========================================================================	
	private int blocks_available() {
//=========================================================================	
	//count incomplete blocks left?
		int available=0;
		for (int i=0; i<_nblocks; i++) {
			if (!_completed_blocks[i]) {available++;}
		}
 		return available;
	}
//=========================================================================	
	private bool same_owner(int cell1, int cell2, out int owner) {
//=========================================================================	
//checks if both the same single possible owner.  
//return true if same owner
//if true, 'owner' is initialised
		int count=0; owner=0;
		if (cell1<0||cell1>=_ncells||cell2<0||cell2>=_ncells) {
			print_error(@"same_owner: range error.  Cell1 $cell1 Cell2 $cell2");
		}
		else {
			for (int i=0; i<_nblocks; i++) {
				if ((_tags[cell1,i]!=_tags[cell2,i])|| count>1) {count=0;break;}
				else if (_tags[cell1,i]) {count++;owner=i;}
			}
		}
		return count==1;
	}
//=========================================================================	
	private bool one_owner(int cell) {
//=========================================================================	
// if only one possible owner (if not empty) then return true 
		int count=0;
		for (int i=0; i<_nblocks; i++) {
			if (_tags[cell,i]) {count++;}
			if (count>1) {break;}
		}
		return count==1;
	}
//=========================================================================	
	private bool fix_block_in_range(int block, int start, int length,bool exclusive=true) {
//=========================================================================	
// block must be limited to range
		bool changed=false;
		if (invalid_data(start,block, length)) {
			print_error(@"possible_block_in_range - cell, or owner out of range cell $start block $block");
		}
		else {
			int block_length=_blocks[block];int freedom = length-block_length; 
			if (freedom<block_length) {
			log(@"Freedom for block $block length $length is $freedom - fixing");
				if (freedom==0) {set_block_complete_and_cap(block,start);changed=true;}
				else {set_range_owner(block,start+freedom,block_length-freedom,exclusive);}
			}
		}
		return changed;
	}	
	
//=========================================================================	
	private int find_largest_possible_in_cell(int cell) {
//=========================================================================	
// find the largest incomplete possible in given range
		int max_size=-1;
		for (int i=0;i<_nblocks;i++) {
			if (_completed_blocks[i]) {continue;} // ignore complete block
			if (!_tags[cell,i]) {continue;} // not possible
			if (_blocks[i]<=max_size) {continue;} // not largest
			max_size=_blocks[i]; //update largest
		}
		return max_size;
	}	
//=========================================================================	
	private void remove_block_from_cell_to_end(int block, int start,int direction=1) {
//=========================================================================	
//remove block as possibility after/before start
//if reverse direction then equivalent forward range is used
		int length=direction>0 ? _ncells-start : start+1;
		start=direction>0 ? start : 0;
		remove_block_from_range(block,start,length);
	}
//=========================================================================	
	private void remove_block_from_range(int block, int start, int length, int direction=1) {
//=========================================================================	
//remove block as possibility in given range
//bi-directional forward=1 backward =-1
//if reverse direction then equivalent forward range is used
		if (direction<0) {start=start-length+1;	}
		if (invalid_data(start,block, length)) {
			print_error(@"remove_block_from_range - cell, or owner out of range. cell $start block $block length $length direction $direction");
		}
		else {
			log(@"Removing block $block from start $start, length $length, direction $direction");
			for (int i=start; i<start+length; i++) {
				_tags[i,block]=false;
			}
		}
	}
//=========================================================================	
	private void set_block_complete_and_cap(int block, int start, int direction=1) {
//=========================================================================	
		int length=_blocks[block];
		if (direction<0) {start=start-length+1;}
		if (invalid_data(start,block, length)) {
			print_error(@"set_block_complete_and_cap - cell, or owner out of range. cell $start block $block length $length direction $direction"); return;	
		}
		if (_completed_blocks[block]==true && _tags[start,block]==false) {
			print_error("cant set block complete - already complete, different owner");
			return;
		}
		_completed_blocks[block]=true;
		set_range_owner(block,start,length);
		log("set block complete - capping block");
		if (start>0) {set_cell_empty(start-1);} 
		if (start+length<_ncells) {set_cell_empty(start+length);}
		for (int cell=start; cell<start+length; cell++) {set_cell_complete(cell);}
		//=======taking into account minimum distance between blocks.
		int l;
		if (block>1) {
			l=0;
			for (int bl=block-2;bl>=0;bl--) {
				l=l+_blocks[bl+1]+1;// length of exclusion zone for this block
				remove_block_from_range(bl,start-2,l,-1);
			}
		}
		if (block<_nblocks-2) {
			l=0;
			for (int bl=block+2;bl<=_nblocks-1;bl++) {
				l=l+_blocks[bl-1]+1;// length of exclusion zone for this block
				remove_block_from_range(bl,start+length+1,l,1);
			}
		}
	}

//=========================================================================	
	private void set_range_owner(int owner, int start, int length, bool exclusive=true) {
//=========================================================================	
		if (invalid_data(start,owner,length)) {
			print_error(@"set_range_owner - start, length or owner out of range. cell $start block $owner length $length");
		}
		else {
		log(@"setting range start $start, length $length to owner $owner exclusive $exclusive");
			int block_length=_blocks[owner];
			for (int cell=start; cell<start+length; cell++) {
				set_cell_owner(cell,owner,exclusive); //this checks owner valid
			}
			//remove block and out of sequence from regions out of reach if exclusive
			if (!exclusive) {return;}
			if (block_length<length) {print_error("exclusive range longer than block length");}
			if (start+length-block_length-1>=0) {
				for (int bl=_nblocks-1;bl>=owner;bl--) {
					remove_block_from_cell_to_end(bl,start+length-block_length-1,-1);
				}
			}
			if (start+block_length<_ncells) {
				for (int bl=0;bl<=owner;bl++) {
					remove_block_from_cell_to_end(bl,start+block_length);
				}
			}
		}		
	}
//========================================================================	
	private void set_cell_owner(int cell, int owner, bool exclusive=true) {
//========================================================================			
		if (invalid_data(cell,owner)) {
			print_error(@"set_cell_owner: out of range cell $cell, owner $owner");
		}
		else if (_status[cell]==CellState.EMPTY) {}// do nothing - not necessarily an error
		else if (_status[cell]==CellState.COMPLETED && _tags[cell,owner]==false) {
			print_error(@"set_cell_owner - completed by another cell $cell");
		}		
		else {
			if (exclusive) {
				_status[cell]=CellState.FILLED;
				_tags[cell,_can_be_empty]=false;
				for (int i=0; i<_nblocks; i++) {_tags[cell,i]=false;}
			}
			_tags[cell,owner]=true;
		}
	}
//=========================================================================		
	private void set_cell_empty(int cell) {
//=========================================================================	
		if (invalid_data(cell)) {
			print_error(@"set_cell_empty -cell out of range $cell");
		}
		else if (_tags[cell,_can_be_empty]==false) {
			print_error(@"set_cell_empty - can be empty false");
		}	
		else if (cell_filled(cell)) {
			print_error(@"set_cell_empty - already filled cell $cell");
		}
		else {
			for (int i=0; i<_nblocks; i++) {_tags[cell,i]=false;}
			_tags[cell,_can_be_empty]=true;
			_tags[cell,_is_finished]=true;
			_status[cell]=CellState.EMPTY;
		}
	}
//=========================================================================		
	private void set_cell_complete(int cell) {
//=========================================================================		
		if (_status[cell]==CellState.EMPTY) {
			print_error(@"set_cell_complete: already set empty - cell $cell");
		}	
		_tags[cell,_is_finished]=true;
		_tags[cell,_can_be_empty]=false;
		_status[cell]=CellState.COMPLETED;
	}
//=========================================================================	
	private bool invalid_data(int start, int block=0, int length=1) {
//=========================================================================	
		return (start<0||start>=_ncells||length<1||start+length>_ncells||block<0||block>_nblocks); 
	}
//=========================================================================	
	private bool cell_filled(int cell) {
//=========================================================================	
		return (_status[cell]==CellState.FILLED||_status[cell]==CellState.COMPLETED);
	}
//=========================================================================	
	private bool totals_changed() {
//=========================================================================	
//has number of filled or unknown cells changed?
		if (_cycles==0) {return true;}
//forces fullfix even if initial fix does not make changes on first visit
// and cells have been set by intersecting ranges.
		bool changed=false;
		int unknown=count_cell_state(CellState.UNKNOWN);
		int filled=count_cell_state(CellState.FILLED);
		if (_unknown!=unknown || _filled!=filled) {
			changed=true; _unknown=unknown; _filled=filled;
			if (_filled>_block_total) {_in_error=true;}
		} 
		return changed;
	}
//=========================================================================	
	private void get_status() {
//=========================================================================	
//transfers cell statuses from grid to internal range status array
		_grid.get_region(_index,_is_column, ref _temp_status, _start,_end);
		for (int i=0;i<_ncells; i++) {
			switch (_temp_status[i]) {
				case CellState.UNKNOWN :
					break;
				case CellState.EMPTY :
					if (cell_filled(i)) {
						print_error(@"get_status - cannot overwrite filled cell $i");
					}
					else {_status[i]=CellState.EMPTY;}
					break;
				case CellState.FILLED :
					//dont overwrite COMPLETE status
					if (_status[i]!=CellState.COMPLETED) {_status[i]=CellState.FILLED;}
					break;
				default : break;
			}
		}
	}
//=========================================================================	
	private void put_status() {
//=========================================================================	
		for (int i=0;i<_ncells; i++) {
			_temp_status[i]=(_status[i]==CellState.COMPLETED ? CellState.FILLED : _status[i]);
		}
		_grid.set_region(_index, _is_column, ref _temp_status, _start, _end);
	}
//=========================================================================	
	private void status_to_tags() {
//=========================================================================	
		for(int i=0;i<_ncells;i++) {
			switch (_status[i]) {
				case CellState.COMPLETED :
					_tags[i,_is_finished]=true; _tags[i,_can_be_empty]=false;
					break;
				case CellState.FILLED :
//					log (@"Setting cell $i as cannot be empty");
					_tags[i,_can_be_empty]=false; 
					break;
				case CellState.EMPTY :
					for (int j=0;j<_nblocks;j++) {_tags[i,j]=false;	}
					_tags[i,_can_be_empty]=true;	_tags[i,_is_finished]=true;
					break;
				default : break;
			}
		}
	}
//=========================================================================	
	private void tags_to_status() {
//=========================================================================	
		for (int i=0;i<_ncells; i++) {
			// skip cells not unknown or with more than one possibility
			if (_status[i]!=CellState.UNKNOWN||count_owners_and_empty(i)>1) {continue;}
			if (_tags[i,_can_be_empty]) {	_status[i]=CellState.EMPTY;}// print_cell_tags(i);
			else {_status[i]=CellState.FILLED;}
		}
	}
	
//=========================================================================	
	private void log(string msg) {
//=========================================================================	
		if (_in_error||_debug) {
			string s=_is_column ? "Col" : "Row";
			stdout.printf("Pass %d Cycle %d %s %d ",_pass, _cycles,s,_index);
			stdout.printf(msg+"\n");
		}
	}
//=========================================================================	
	private void print_error(string msg) {
//=========================================================================	
		_in_error=true;	log("\n*******IN ERROR******* "+msg+"\n");
	}
//=========================================================================	
	private void print_tags() {
//=========================================================================	
			string s=_is_column ? "Column" : "Row" ;
			stdout.printf("Tags for %s %d\n",s, _index);
			for (int i=0; i<_ncells; i++) {
				stdout.printf("Cell %d - ",i);
				for (int j=0; j<_nblocks; j++) {stdout.printf("%d %s,", j, _tags[i,j].to_string());}
				stdout.printf("can be empty %s,",_tags[i,_can_be_empty].to_string());
				stdout.printf("\n");
			}
	}
}
//=========================================================================	
//=========================================================================	
